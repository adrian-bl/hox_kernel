diff --git a/arch/arm/configs/endeavoru_android_defconfig b/arch/arm/configs/endeavoru_android_defconfig
index 5309e50..8524747 100644
--- a/arch/arm/configs/endeavoru_android_defconfig
+++ b/arch/arm/configs/endeavoru_android_defconfig
@@ -30,8 +30,6 @@ CONFIG_TEGRA_PCI=y
 CONFIG_TEGRA_CPU_DVFS=y
 CONFIG_TEGRA_CORE_DVFS=y
 CONFIG_TEGRA_AUTO_HOTPLUG=y
-CONFIG_POWER_KEY_WAKEUP_FAILED_PATCH=y
-
 CONFIG_MACH_ENDEAVORU=y
 CONFIG_TEGRA_DEBUG_UARTA=y
 CONFIG_TEGRA_PWM=y
@@ -148,7 +146,7 @@ CONFIG_NETFILTER_XT_MATCH_MAC=y
 CONFIG_NETFILTER_XT_MATCH_MARK=y
 CONFIG_NETFILTER_XT_MATCH_OWNER=n
 CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=n
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
 CONFIG_NETFILTER_XT_MATCH_POLICY=y
 CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
 CONFIG_NETFILTER_XT_MATCH_QUOTA=y
@@ -187,6 +185,10 @@ CONFIG_NET_CLS_ACT=y
 CONFIG_NET_ACT_POLICE=y
 CONFIG_NET_ACT_GACT=y
 CONFIG_NET_ACT_MIRRED=y
+
+# HTC modify for Klockwork in net
+# CONFIG_HTC_NET_MODIFY=y
+
 CONFIG_BT=m
 CONFIG_BT_L2CAP=y
 CONFIG_BT_SCO=y
@@ -450,7 +452,9 @@ CONFIG_CABLE_DETECT_ACCESSORY=y
 CONFIG_USB_DRV=y
 CONFIG_SENSORS_NFC_PN544=y
 CONFIG_TEGRA_HDMI_MHL=y
+CONFIG_TEGRA_NVHDCP=y
 CONFIG_TEGRA_HDMI_MHL_SUPERDEMO=y
+CONFIG_INTERNAL_CHARGING_SUPPORT=y
 CONFIG_MMC=y
 # CONFIG_MMC_EMBEDDED_SDIO=y
 CONFIG_MMC_BLOCK_MINORS=64
@@ -583,7 +587,6 @@ CONFIG_WL12XX=m
 CONFIG_WL12XX_SDIO=m
 CONFIG_WL12XX_PLATFORM_DATA=y
 CONFIG_DYNAMIC_DEBUG=y
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CRYPTO_ECB=y
 CONFIG_CRYPTO_PCBC=y
 CONFIG_CRYPTO_MD4=y
@@ -639,10 +642,11 @@ CONFIG_PANIC_TIMEOUT=10
 
 # For memory fragementation or leakage
 CONFIG_COMPACTION=y
-#CONFIG_SLUG_DEBUG=y
-#CONFIG_SLUG_DEBUG_ON=y
+#CONFIG_SLUB_DEBUG=y
+#CONFIG_SLUB_DEBUG_ON=y
 
 # TODO On mode suspend charging, should not set y for all build
 CONFIG_HTC_ONMODE_CHARGING=y
 
 CONFIG_TEGRA_NVHDCP=y
+CONFIG_ARM_ERRATA_764369=y
diff --git a/arch/arm/kernel/head-common.S b/arch/arm/kernel/head-common.S
index 8991ab3..6a9f702 100644
--- a/arch/arm/kernel/head-common.S
+++ b/arch/arm/kernel/head-common.S
@@ -49,7 +49,7 @@ __vet_atags:
 	cmp	r5, r6
 	bne	1f
 
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_VERTEXF)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_VERTEXFP)
 #define ATAGS_BLOCK_DISPLACE
 #endif
 
diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index 1b05a30..a0eb12e 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -158,16 +158,16 @@ config MACH_TEGRA_ENTERPRISE
          Support for NVIDIA Enterprise development platform
 
 config MACH_VERTEXF
-       bool "Quattro#F board"
+       bool "Vertex#F board"
        depends on ARCH_TEGRA_3x_SOC
        help
-         Support for HTC Quattro#F tablet
+         Support for HTC Vertex#F tablet
 
 config MACH_VERTEXFP
-       bool "Quattro#F PRM board"
+       bool "Vertex#F PRM board"
        depends on ARCH_TEGRA_3x_SOC
        help
-         Support for HTC Quattro#F PRM tablet
+         Support for HTC Vertex#F PRM tablet
 
 config MACH_ENDEAVORU
 	bool "Edge board"
@@ -183,6 +183,13 @@ config MACH_ENDEAVORTD
 	help
 		Support for HTC EDGE#TD phone
 
+config MACH_ERAU
+	bool "Edge board"
+	default n
+	depends on ARCH_TEGRA_3x_SOC
+	help
+		Support for HTC EDGE#U phone
+
 config BATTERY_TPS80032
 	depends on HTC_BATT_CORE && ADC_TPS80032 && VSYS_ALARM_TPS80032
 	bool "HTC battery driver for tps80032"
@@ -443,7 +450,7 @@ config USB_HOTPLUG
 
 config TIWLAN_SDIO
         bool "TI WLAN Enhanced SDIO Contoller support"
-        depends on MACH_ENDEAVORU || MACH_ENDEAVORTD || MACH_BLUE
+        depends on MACH_ENDEAVORU || MACH_ENDEAVORTD || MACH_ERAU || MACH_BLUE
         help
            Say Y here if you want to be able to use TI's WLAN device using the
            SDIO interface. If unsure, say N.
@@ -565,7 +572,7 @@ config HTC_BATT_CORE
 
 config RESET_REASON
     bool "Enable reset reason for Quattro / Blue"
-    depends on MACH_ENDEAVORU || MACH_ENDEAVORTD || MACH_BLUE || MACH_VERTEXF || MACH_QUATTRO_U
+    depends on MACH_ENDEAVORU || MACH_ENDEAVORTD || MACH_ERAU || MACH_BLUE || MACH_VERTEXFP
     default n
 
 config TEGRA_PLLM_RESTRICTED
@@ -604,5 +611,26 @@ config ANDROID_RAM_CONSOLE_APPEND_PMIC_STATUS_BITS
 	help
 	  Append PMIC status bits to end of /proc/last_kmsg for
 	  checking the boot / reset reason in detail
+
+config BUILD_BOARD_MFG
+	bool
+	option env="CONFIG_BOARD_MFG"
+
+choice
+	prompt "SELECT BUILD_BOARD_MFG"
+	default BOARD_MFG
+
+config BOARD_MFG
+	prompt "BUILD_BOARD_MFG"
+	bool
+	depends on BUILD_BOARD_MFG
+
+config BOARD_NO_MFG
+	prompt "BUILD_BOARD_NO_MFG"
+	bool
+	depends on !BUILD_BOARD_MFG
+
+endchoice
+
 endif
 
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index 37452e8..f800899 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -75,6 +75,7 @@ obj-$(CONFIG_TEGRA_SYSTEM_DMA)          += dma.o
 obj-$(CONFIG_CPU_FREQ)                  += cpu-tegra.o
 ifeq ($(CONFIG_TEGRA_AUTO_HOTPLUG),y)
 obj-$(CONFIG_ARCH_TEGRA_3x_SOC)         += cpu-tegra3.o
+obj-$(CONFIG_ARCH_TEGRA_3x_SOC)         += cpuplug.lib
 endif
 obj-$(CONFIG_TEGRA_PCI)                 += pcie.o
 obj-$(CONFIG_USB_SUPPORT)               += usb_phy.o
@@ -171,31 +172,31 @@ obj-y                                   += htc_audio_power.o
 
 obj-y                                   += power.o
 
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-memory.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-panel.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-kbc.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-pinmux.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-power.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-powermon.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-sdhci.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-sensors.o
-obj-${CONFIG_MACH_VERTEXF}            += baseband-xmm-power.o
-obj-${CONFIG_MACH_VERTEXF}            += devices_htc.o
-obj-${CONFIG_MACH_VERTEXF}            += htc_bdaddress.o
-obj-${CONFIG_MACH_VERTEXF}            += board-vertex-audio.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-memory.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-panel.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-kbc.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-pinmux.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-power.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-powermon.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-sdhci.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-sensors.o
+obj-${CONFIG_MACH_VERTEXFP}            += baseband-xmm-power.o
+obj-${CONFIG_MACH_VERTEXFP}            += devices_htc.o
+obj-${CONFIG_MACH_VERTEXFP}            += htc_bdaddress.o
+obj-${CONFIG_MACH_VERTEXFP}            += board-vertex-audio.o
 
-obj-${CONFIG_MACH_VERTEXF}            += htc_disp_device.o
-obj-${CONFIG_MACH_VERTEXF}            += htc_disp_evm_auo.o
-obj-${CONFIG_MACH_VERTEXF}            += htc_disp_evt_xa_chimei.o
-obj-${CONFIG_MACH_VERTEXF}            += htc_disp_evt_xb_chimei.o
-obj-${CONFIG_MACH_VERTEXF}            += htc_disp_evt_xb_LG.o
-obj-${CONFIG_MACH_VERTEXF}        	+= htc_wifi_nvs.o
+obj-${CONFIG_MACH_VERTEXFP}            += htc_disp_device.o
+obj-${CONFIG_MACH_VERTEXFP}            += htc_disp_evm_auo.o
+obj-${CONFIG_MACH_VERTEXFP}            += htc_disp_evt_xa_chimei.o
+obj-${CONFIG_MACH_VERTEXFP}            += htc_disp_evt_xb_chimei.o
+obj-${CONFIG_MACH_VERTEXFP}            += htc_disp_evt_xb_LG.o
+obj-${CONFIG_MACH_VERTEXFP}        	+= htc_wifi_nvs.o
 
-obj-${CONFIG_MACH_VERTEXF}        	+= drv_callback.o
-obj-${CONFIG_MACH_VERTEXF}        	+= board-vertex-microp.o
-obj-${CONFIG_MACH_VERTEXF}            += charger.o
-obj-${CONFIG_MACH_VERTEXF}            += htc-gpio.o
+obj-${CONFIG_MACH_VERTEXFP}        	+= drv_callback.o
+obj-${CONFIG_MACH_VERTEXFP}        	+= board-vertex-microp.o
+obj-${CONFIG_MACH_VERTEXFP}            += charger.o
+obj-${CONFIG_MACH_VERTEXFP}            += htc-gpio.o
 
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavor-panel.o
@@ -203,19 +204,41 @@ obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-pinmux.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-sdhci.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-memory.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-power.o
-obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-baseband.o
+#obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-baseband.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-kbc.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-sensors.o
+obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-camera.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += tegra_flashlight.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += devices_htc.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += htc-gpio.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += board-endeavoru-audio.o
 obj-${CONFIG_MACH_ENDEAVORU}                 += htc_wifi_nvs.o
+obj-${CONFIG_MACH_ENDEAVORU}                 += baseband-xmm-power.o
+obj-${CONFIG_MACH_ENDEAVORU}                 += htc_simhotswap.o
 obj-y                                        += htc_port_list.o
 ifeq (${CONFIG_MACH_ENDEAVORU},y)
-obj-y += baseband-xmm-power.o
 obj-m += baseband-xmm-power2.o
-obj-y += htc_simhotswap.o
+endif
+
+obj-${CONFIG_MACH_ERAU}      += board-erau.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavor-panel.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-pinmux.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-sdhci.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-memory.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-power.o
+#obj-${CONFIG_MACH_ERAU}      += board-endeavoru-baseband.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-kbc.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-sensors.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-camera.o
+obj-${CONFIG_MACH_ERAU}      += tegra_flashlight.o
+obj-${CONFIG_MACH_ERAU}      += devices_htc.o
+obj-${CONFIG_MACH_ERAU}      += htc-gpio.o
+obj-${CONFIG_MACH_ERAU}      += board-endeavoru-audio.o
+obj-${CONFIG_MACH_ERAU}      += htc_wifi_nvs.o
+obj-${CONFIG_MACH_ERAU}      += baseband-xmm-power.o
+obj-${CONFIG_MACH_ERAU}      += htc_simhotswap.o
+ifeq (${CONFIG_MACH_ERAU},y)
+obj-m += baseband-xmm-power2.o
 endif
 
 obj-${CONFIG_MACH_ENDEAVORTD}                 += board-endeavortd.o
@@ -227,6 +250,7 @@ obj-${CONFIG_MACH_ENDEAVORTD}                 += board-endeavortd-power.o
 obj-${CONFIG_MACH_ENDEAVORTD}                 += board-endeavortd-baseband.o
 obj-${CONFIG_MACH_ENDEAVORTD}                 += board-endeavortd-kbc.o
 obj-${CONFIG_MACH_ENDEAVORTD}                 += board-endeavortd-sensors.o
+obj-${CONFIG_MACH_ENDEAVORTD}                 += board-endeavortd-camera.o
 obj-${CONFIG_MACH_ENDEAVORTD}           	   += tegra_flashlight.o
 obj-${CONFIG_MACH_ENDEAVORTD}                 += devices_htc.o
 obj-${CONFIG_MACH_ENDEAVORTD}					+= htc-gpio.o
@@ -248,13 +272,14 @@ obj-$(CONFIG_HTC_HEADSET_MISC) += htc_headset_misc.o
 obj-$(CONFIG_HTC_HEADSET_8X60) += htc_headset_8x60.o
 
 #Add nand_partitions.c
-obj-${CONFIG_MACH_VERTEXF}            += nand_partitions.o
+obj-${CONFIG_MACH_VERTEXFP}            += nand_partitions.o
 obj-${CONFIG_MACH_ENDEAVORU}          += nand_partitions.o
 obj-${CONFIG_MACH_ENDEAVORTD}         += nand_partitions.o
+obj-${CONFIG_MACH_ERAU}               += nand_partitions.o
 
 # Add ramdump from NV patches
 obj-y                                   += nvdumper.o
 obj-y 					+= htc_util.o
 obj-y 					+= pokecpu.o
 
diff --git a/arch/arm/mach-tegra/baseband-xmm-power.c b/arch/arm/mach-tegra/baseband-xmm-power.c
index 9481852..3ed080e 100644
--- a/arch/arm/mach-tegra/baseband-xmm-power.c
+++ b/arch/arm/mach-tegra/baseband-xmm-power.c
@@ -37,20 +37,17 @@
 #include <mach/board_htc.h>
 #include <linux/pm_qos_params.h>
 
-#if defined(CONFIG_MACH_QUATTRO_U)
-#include "board-quattro.h"
-#elif defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_BLUE)
 #include "board-blue.h"
 #elif defined(CONFIG_MACH_EDGE)
 #include "board-edge.h"
 #elif defined(CONFIG_MACH_EDGE_TD)
 #include "board-edgetd.h"
-#elif defined(CONFIG_MACH_ENDEAVORU)
+#elif defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ERAU)
 #include "board-endeavoru.h"
 #endif
 #include "gpio-names.h"
 #include "baseband-xmm-power.h"
-#include <htc/log.h>
 
 MODULE_LICENSE("GPL");
 
@@ -247,7 +244,7 @@ static int baseband_xmm_power_driver_handle_resume(
 static bool wakeup_pending;
 static int uart_pin_pull_state=1; // 1 for UART, 0 for GPIO
 static bool modem_sleep_flag = false;
-static struct regulator *enterprise_dsi_reg = NULL;//for avdd_csi_dsi
+static struct regulator *endeavor_dsi_reg = NULL;//for avdd_csi_dsi
 static spinlock_t xmm_lock;
 static bool system_suspending;
 
@@ -258,13 +255,13 @@ static struct workqueue_struct *workqueue_susp;
 static struct work_struct work_shortsusp, work_defaultsusp;
 
 /*HTC++*/
-static ssize_t debug_gpio_dump(struct device *dev,
+ssize_t debug_gpio_dump(struct device *dev,
 	struct device_attribute *attr,
 	const char *buf, size_t count)
 {	
 	int rValue=0;
 	
-	pr_info("**********************\n");
+	pr_info("********** dump gpio status start **********\n");
 	int value = gpio_get_value(TEGRA_GPIO_PM4);
 	pr_info("BB_VDD_EN=%d\n", value);
 	value = gpio_get_value(TEGRA_GPIO_PC1);
@@ -286,74 +283,88 @@ static ssize_t debug_gpio_dump(struct device *dev,
 
 	
 	/*set BB2AP_SUSPEND_REQ Pin (TEGRA_GPIO_PV0) to OutPut High to trigger Modem fatal*/
-	int ret=gpio_direction_output(TEGRA_GPIO_PV0,1);
+/*	int ret=gpio_direction_output(TEGRA_GPIO_PV0,1);
 	pr_info("set BB2AP_SUSPEND_REQ Pin (TEGRA_GPIO_PV0) to OutPut High to trigger Modem fatal\n");
 	if (ret < 0)
 		pr_err("%s: set BB2AP_SUSPEND_REQ Pin to Output error\n", __func__);
 	value = gpio_get_value(TEGRA_GPIO_PV0);
-	pr_info("HSIC_SUS_REQ=%d\n", value);
+	pr_info("HSIC_SUS_REQ=%d\n", value);*/
 
 	/*set host_active for interrupet modem*/
-	value = gpio_get_value(TEGRA_GPIO_PN1);
+/*	value = gpio_get_value(TEGRA_GPIO_PN1);
 	pr_info("Oringial IPC_HSIC_ACTIVE =%d\n", value);
 	if(value==1)rValue=0;
 	else if(value==0)rValue=1;
 
 	gpio_set_value(TEGRA_GPIO_PN1,rValue);
 	msleep(100);
-	gpio_set_value(TEGRA_GPIO_PN1,value);
+	gpio_set_value(TEGRA_GPIO_PN1,value);*/
 	
-	pr_info("**********************\n");
+	pr_info("********** dump gpio status end **********\n");
 	
-
-return count;
+	return count;
 }
+EXPORT_SYMBOL_GPL(debug_gpio_dump);
+
 static DEVICE_ATTR(debug_gpio_dump, S_IRUSR | S_IWUSR | S_IRGRP,
 		NULL, debug_gpio_dump);
 
+int trigger_radio_fatal_get_coredump()
+{
+	pr_info("set BB2AP_SUSPEND_REQ Pin (TEGRA_GPIO_PV0) to OutPut High to trigger Modem fatal\n");
+
+	/*set BB2AP_SUSPEND_REQ Pin (TEGRA_GPIO_PV0) to OutPut High to trigger Modem fatal*/
+	int ret=gpio_direction_output(TEGRA_GPIO_PV0,1);
+
+	if (ret < 0)
+		pr_err("%s: set BB2AP_SUSPEND_REQ Pin to Output error\n", __func__);
+}
+EXPORT_SYMBOL_GPL(trigger_radio_fatal_get_coredump);
+
 int enable_avdd_dsi_csi_power()
 {
 	 pr_info(MODULE_NAME "[xmm]%s\n",__func__);
 	int ret=0;
-	if (enterprise_dsi_reg == NULL) {
-		enterprise_dsi_reg = regulator_get(NULL, "avdd_dsi_csi");
+	if (endeavor_dsi_reg == NULL) {
+		endeavor_dsi_reg = regulator_get(NULL, "avdd_dsi_csi");
 		pr_info(MODULE_NAME "[xmm]%s regulator_getED\n",__func__);
-		if (IS_ERR_OR_NULL(enterprise_dsi_reg)) {
+		if (IS_ERR_OR_NULL(endeavor_dsi_reg)) {
 			pr_err("dsi: Could not get regulator avdd_dsi_csi\n");
-				enterprise_dsi_reg = NULL;
-				return PTR_ERR(enterprise_dsi_reg);
+				endeavor_dsi_reg = NULL;
+				return PTR_ERR(endeavor_dsi_reg);
 		}
 	}
-	ret = regulator_enable(enterprise_dsi_reg);
+	ret = regulator_enable(endeavor_dsi_reg);
 	if (ret < 0) {
 		printk(KERN_ERR
 			"DSI regulator avdd_dsi_csi couldn't be enabled\n",ret);
 		
 	}
-		return ret;
+	return ret;
 
 }
 int disable_avdd_dsi_csi_power()
 {
 	 pr_info(MODULE_NAME "[xmm]%s\n",__func__);
 	int ret=0;
-	if (enterprise_dsi_reg == NULL) {
-		enterprise_dsi_reg = regulator_get(NULL, "avdd_dsi_csi");
+	if (endeavor_dsi_reg == NULL) {
+		endeavor_dsi_reg = regulator_get(NULL, "avdd_dsi_csi");
 		pr_info(MODULE_NAME "[xmm]%s regulator_getED\n",__func__);
-		if (IS_ERR_OR_NULL(enterprise_dsi_reg)) {
+		if (IS_ERR_OR_NULL(endeavor_dsi_reg)) {
 			pr_err("dsi: Could not get regulator avdd_dsi_csi\n");
-				enterprise_dsi_reg = NULL;
-				return PTR_ERR(enterprise_dsi_reg);
+				endeavor_dsi_reg = NULL;
+				return PTR_ERR(endeavor_dsi_reg);
 		}
 	}
-	ret = regulator_disable(enterprise_dsi_reg);
+	ret = regulator_disable(endeavor_dsi_reg);
 	if (ret < 0) {
 		printk(KERN_ERR
 			"DSI regulator avdd_dsi_csi couldn't be disabled\n",ret);
-
+		
 	}
-	enterprise_dsi_reg=NULL;
+	endeavor_dsi_reg=NULL;
 	return ret;
+
 }
 
 int gpio_config_only_one(unsigned gpio, unsigned long flags, const char *label)
@@ -552,7 +563,7 @@ static int baseband_modem_power_on(struct baseband_power_platform_data *data)
 	/* HTC: called in atomic context */
 	int ret=0, i=0;
 
-	pr_info("%s VP: 03/08 22.52{\n", __func__);
+	pr_info("%s VP: 05/03 pin_state setting and CP_initiated_L2toL0 error setting{\n", __func__);
 	if (!data) {
 		pr_err("%s: data is NULL\n", __func__);
 		return -1;
@@ -631,7 +642,7 @@ static int baseband_xmm_power_on(struct platform_device *device)
 			__func__);
 		return -EINVAL;
 	}
-#if 1 /*HTC*/	
+#if 1 /*HTC*/
 	pr_debug(MODULE_NAME " htc_get_pcbid_info= %d\n",htcpcbid );
 	if(htcpcbid < PROJECT_PHASE_XE) {
 		enable_avdd_dsi_csi_power();
@@ -1057,6 +1068,12 @@ irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id)
 		if (!value) {
 			pr_debug("%s - falling\n", __func__);
 			/* First check it a CP ack or CP wake  */
+			if (data->pin_state == 0) {
+				/* AP L2 to L0 wakeup */
+				pr_debug("VP: received rising wakeup ap l2->l0\n");
+				data->pin_state = 1;
+				wake_up_interruptible(&data->bb_wait);
+			}
 			value = gpio_get_value
 				(data->modem.xmm.ipc_bb_wake);
 			if (value) {
@@ -1070,9 +1087,14 @@ irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id)
 				spin_unlock(&xmm_lock);
 				pr_info("system_suspending=1, Just set wakup_pending flag=true\n");
 			} else {
-				if (baseband_xmm_powerstate ==
-							BBXMM_PS_L3) {
+				if ((baseband_xmm_powerstate ==
+							BBXMM_PS_L3) ||
+					(baseband_xmm_powerstate ==
+							BBXMM_PS_L3TOL0)) {
 					spin_unlock(&xmm_lock);
+
+					if(baseband_xmm_powerstate == BBXMM_PS_L3TOL0)
+						pr_info("*****bug 966077 fix*****\n");
 					pr_info(" CP L3 -> L0\n");
 					pr_info("set wakeup_pending=true, wait for no-irq-resuem if you are not under LP0 yet !.\n");
 					pr_info("set wakeup_pending=true, wait for system resume if you already under LP0.\n");
@@ -1113,15 +1135,16 @@ irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id)
                                reenable_autosuspend = false;
                                struct usb_interface *intf;
                                intf = usb_ifnum_to_if(usbdev, 0);
-                               if (usb_autopm_get_interface_async(intf) >= 0) {
-                                       pr_info("get_interface_async succeeded"
-                                               " - call put_interface\n");
-                                       usb_autopm_put_interface_async(intf);
-                               } else {
-                                       pr_info("get_interface_async failed"
-                                               " - do not call put_interface\n");
+                               if( NULL != intf ){
+                                   if (usb_autopm_get_interface_async(intf) >= 0) {
+                                           pr_info("get_interface_async succeeded"
+                                                   " - call put_interface\n");
+                                           usb_autopm_put_interface_async(intf);
+                                   } else {
+                                           pr_info("get_interface_async failed"
+                                                   " - do not call put_interface\n");
+                                   }
                                }
-
 			}
 			if (short_autosuspend&& (&usbdev->dev)) {
 				 pr_debug("set autosuspend delay %d ms\n", SHORT_AUTOSUSPEND_DELAY);
@@ -1207,9 +1230,9 @@ static void baseband_xmm_power_L2_resume(void)
 {
 	struct baseband_power_platform_data *data = baseband_power_driver_data;
 	int value;
-	int delay = 10000; /* maxmum delay in msec */
+	int delay = 1000; /* maxmum delay in msec */
 	unsigned long flags;
-
+	int ret, rcount = 0;
 
 	pr_debug("%s\n", __func__);
 
@@ -1241,19 +1264,30 @@ static void baseband_xmm_power_L2_resume(void)
 		pr_info("AP L2->L0\n");
 		value = gpio_get_value(data->modem.xmm.ipc_ap_wake);
 		if (value) {
-			pr_debug("waiting for host wakeup from CP...\n");
+			data->pin_state = 0;
 			/* wake bb */
 			gpio_set_value(data->modem.xmm.ipc_bb_wake, 1);
-			do {
-				hr_msleep(1);
-				value = gpio_get_value(
-					data->modem.xmm.ipc_ap_wake);
-				delay--;
-			} while ((value) && (delay));
-			if (delay)
-				pr_debug("Get gpio host wakeup low <-\n");
-			else
+retry:
+			/* wait for cp */
+			pr_debug("waiting for host wakeup from CP...\n");
+
+			ret = wait_event_interruptible_timeout(data->bb_wait,
+					data->pin_state == 1 || (gpio_get_value(data->modem.xmm.ipc_ap_wake)== 0), msecs_to_jiffies(delay));
+
+			if (ret == 0) {
 				pr_info("!!AP L2->L0 Failed\n");
+				return;
+			}
+			if (ret == -ERESTARTSYS ) {
+				if (rcount == 2) {
+					pr_info("!!AP L2->L0 Failed\n");
+					return;
+				}
+				pr_debug("%s: caught signal, restarting\n", __func__);
+				rcount++;
+				goto retry;
+			}
+			pr_debug("Get gpio host wakeup low <-\n");
 		} else {
 			pr_info("CP already ready\n");
 		}
@@ -1298,8 +1332,10 @@ static void baseband_xmm_power_L2_resume_work(struct work_struct *work)
 
 	usb_lock_device(usbdev);
 	intf = usb_ifnum_to_if(usbdev, 0);
-	if (usb_autopm_get_interface(intf) == 0)
-		usb_autopm_put_interface(intf);
+	if( NULL != intf ){
+		if (usb_autopm_get_interface(intf) == 0)
+			usb_autopm_put_interface(intf);
+	}
 	usb_unlock_device(usbdev);
 
 	pr_info("} %s\n", __func__);
@@ -1537,7 +1573,7 @@ static int baseband_xmm_power_driver_probe(struct platform_device *device)
 	unsigned long flags;
 	int err, ret=0;
 
-	 pr_info(MODULE_NAME"%s 0316 hr_sleep and jiffe - CPU Freq. \n", __func__);
+	 pr_info(MODULE_NAME"%s 0425 - CP_initiated_L2toL0 error setting and data->pin_state setting. \n", __func__);
 	 pr_info(MODULE_NAME"enum_delay_ms=%d\n", enum_delay_ms);
 	 htcpcbid=htc_get_pcbid_info();
 	 pr_info(MODULE_NAME"htcpcbid=%d\n", htcpcbid);
@@ -1554,6 +1590,9 @@ static int baseband_xmm_power_driver_probe(struct platform_device *device)
 
 	/* save platform data */
 	baseband_power_driver_data = data;
+	/* init wait queue */
+	data->pin_state = 1;
+	init_waitqueue_head(&data->bb_wait);
 
 	/* create device file */
 	err = device_create_file(dev, &dev_attr_xmm_onoff);
diff --git a/arch/arm/mach-tegra/baseband-xmm-power.h b/arch/arm/mach-tegra/baseband-xmm-power.h
index 740f373..6dc25e7 100644
--- a/arch/arm/mach-tegra/baseband-xmm-power.h
+++ b/arch/arm/mach-tegra/baseband-xmm-power.h
@@ -26,7 +26,7 @@
 #if defined(CONFIG_MACH_EDGE)\
 	|| defined(CONFIG_MACH_EDGE_TD)\
 	|| defined(CONFIG_MACH_BLUE)\
-	|| defined(CONFIG_MACH_QUATTRO_U)\
+	|| defined(CONFIG_MACH_ERAU) \
 	|| defined(CONFIG_MACH_ENDEAVORU)
 
 #include <linux/completion.h>
@@ -60,6 +60,8 @@ struct baseband_power_platform_data {
 	enum baseband_type baseband_type;
 	struct platform_device* (*hsic_register)(void);
 	void (*hsic_unregister)(struct platform_device *);
+	wait_queue_head_t bb_wait;
+	unsigned int pin_state;
 	union {
 		struct {
 			int mdm_reset;
@@ -125,5 +127,9 @@ enum baseband_xmm_powerstate_t {
 irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id);
 
 void baseband_xmm_set_power_status(unsigned int status);
+ssize_t debug_gpio_dump(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count);
+int trigger_radio_fatal_get_coredump();
 
 #endif  /* BASREBAND_XMM_POWER_H */
diff --git a/arch/arm/mach-tegra/baseband-xmm-power2.c b/arch/arm/mach-tegra/baseband-xmm-power2.c
index cdb0dcc..dfa5614 100644
--- a/arch/arm/mach-tegra/baseband-xmm-power2.c
+++ b/arch/arm/mach-tegra/baseband-xmm-power2.c
@@ -55,7 +55,7 @@
 
 MODULE_LICENSE("GPL");
 
-#if defined(CONFIG_MACH_EDGE) || defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE)
 #if 0//sim move to other driver
     #define SIM_DETECT_LOW_ACTIVE TEGRA_GPIO_PI5
 #endif//sim move to other driver
@@ -79,7 +79,7 @@ MODULE_LICENSE("GPL");
 #endif
 
 
-#if defined(CONFIG_MACH_EDGE) || defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_BLUE)   
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE)
 	#define CORE_DUMP_DETECT TEGRA_GPIO_PN2
 	//radio fatal
 
@@ -344,7 +344,7 @@ static void sim_detect_work_handler(struct work_struct *work)
 #endif//sim move to other driver
 
 /*SIM detection IRQ*/
-#if defined(CONFIG_MACH_EDGE) || defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE)
 #if 0//sim move to other driver
 static irqreturn_t sim_det_irq(int irq, void *dev_id)
 {
@@ -417,6 +417,10 @@ static void radio_detect_work_handler(struct work_struct *work)
 			strncat(message, "READY", 5);
 			*/
 
+	int value = gpio_get_value(TEGRA_GPIO_PV0);
+	pr_info("gpio_direction_input(TEGRA_GPIO_PV0), original=%d\n", value);
+	gpio_direction_input(TEGRA_GPIO_PV0);
+
     pr_info("[FLS] coredump uevent\n");
     //kobject_uevent(&baseband_power2_driver_data->modem.xmm6260.hsic_device->dev.kobj, KOBJ_ADD);
     //kobject_uevent(  &modem_info.modem_core_dump_kobj, KOBJ_ADD);
@@ -902,7 +906,7 @@ static int baseband_xmm_power2_driver_probe(struct platform_device *device)
 			device->dev.platform_data;
 
 	int err=0;
-	pr_debug("%s 0309 - CPU Freq with data protect.\n", __func__);
+	pr_debug("%s 0412 - CPU Freq with data protect and dummy kobj.\n", __func__);
 
 	if (data == NULL) {
 		pr_err("%s: no platform data\n", __func__);
@@ -918,7 +922,7 @@ static int baseband_xmm_power2_driver_probe(struct platform_device *device)
 
 	/* OEM specific initialization */
 #ifdef BB_XMM_OEM1
-#if defined(CONFIG_MACH_EDGE) || defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE)
 #if 0//sim move to other driver
 		/* may be better to put this in init2()??*/
 		sim_detect_status = SIM_STATUS_UNKNOWN;
@@ -947,7 +951,7 @@ static int baseband_xmm_power2_driver_probe(struct platform_device *device)
 		pr_info("gpio 32 value is %d\n", err);
 
 
-#if defined(CONFIG_MACH_EDGE) || defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE)
 	if(err) /*if GPIO_PI5 is high, set as high*/
 	{
 	    gpio_set_value(SIM_INIT, 1);
@@ -962,8 +966,9 @@ static int baseband_xmm_power2_driver_probe(struct platform_device *device)
 	}
 #endif
 #endif
-		kobj_hsic_device =
-			 kobject_get(&baseband_power2_driver_data->modem.xmm.hsic_device->dev.kobj);
+		/*kobj_hsic_device =
+			 kobject_get(&baseband_power2_driver_data->modem.xmm.hsic_device->dev.kobj);*/
+		kobj_hsic_device = kobject_create_and_add("modem-dump-kobj", NULL);
 		if (!kobj_hsic_device) {
 			pr_err("[FLS] can not get modem_kobject\n");
 			goto fail;
@@ -1054,7 +1059,7 @@ static int baseband_xmm_power2_driver_probe(struct platform_device *device)
 
 	/* OEM specific - init work queue */
 #ifdef BB_XMM_OEM1
-#if defined(CONFIG_MACH_EDGE) || defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE)
 #if 0//sim move to other driver
 	INIT_WORK(&sim_detect_work_struct, sim_detect_work_handler);
 #endif//sim move to other driver
@@ -1086,7 +1091,7 @@ static int baseband_xmm_power2_driver_remove(struct platform_device *device)
 
 	/* OEM specific - free sim detect irq */
 #ifdef BB_XMM_OEM1
-#if defined(CONFIG_MACH_EDGE) || defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_EDGE_TD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE)
 #if 0//sim move to other driver
     free_irq(gpio_to_irq(SIM_DETECT), &modem_info);
 #endif//sim move to other driver
diff --git a/arch/arm/mach-tegra/board-endeavoru-audio.c b/arch/arm/mach-tegra/board-endeavoru-audio.c
index 6259772..5204cb6 100644
--- a/arch/arm/mach-tegra/board-endeavoru-audio.c
+++ b/arch/arm/mach-tegra/board-endeavoru-audio.c
@@ -5,6 +5,7 @@
 #include <linux/regulator/consumer.h>
 #include "htc_audio_power.h"
 #include <mach/board_htc.h>
+#include <asm/mach-types.h>
 
 #undef LOG_TAG
 #define LOG_TAG "AUD"
@@ -29,16 +30,12 @@ extern void config_tegra_desk_aud_gpios(bool output, bool out_val);
 
 static void aic3008_powerinit(void)
 {
-	int value = htc_get_pcbid_info();
-
-	if (value >= PROJECT_PHASE_XA) {
-		power_config("AUD_MCLK_EN", TEGRA_GPIO_PX7, INIT_OUTPUT_HIGH);
-		power_config("AUD_MCLK_EN", TEGRA_GPIO_PX7, GPIO_OUTPUT);
-		power_config("AUD_AIC3008_RST#", TEGRA_GPIO_PW5, INIT_OUTPUT_HIGH);
-		power_config("AUD_AIC3008_RST#", TEGRA_GPIO_PW5, GPIO_OUTPUT);
-		power_config("v_aud_a1v8", TEGRA_GPIO_PD2, REGULATOR_METHOD);
-		power_config("v_aud_3v3", TEGRA_GPIO_PB2, REGULATOR_METHOD);
-	} else AUD_ERR("%s: no pcbid satisfy.", __func__);
+	power_config("AUD_MCLK_EN", TEGRA_GPIO_PX7, INIT_OUTPUT_HIGH);
+	power_config("AUD_MCLK_EN", TEGRA_GPIO_PX7, GPIO_OUTPUT);
+	power_config("AUD_AIC3008_RST#", TEGRA_GPIO_PW5, INIT_OUTPUT_HIGH);
+	power_config("AUD_AIC3008_RST#", TEGRA_GPIO_PW5, GPIO_OUTPUT);
+	power_config("v_aud_a1v8", TEGRA_GPIO_PD2, REGULATOR_METHOD);
+	power_config("v_aud_3v3", TEGRA_GPIO_PB2, REGULATOR_METHOD);
 
 	power_config("AUD_MCLK", TEGRA_GPIO_PW4, INIT_OUTPUT_LOW);
 	sfio_deconfig("AUD_MCLK", TEGRA_GPIO_PW4);
diff --git a/arch/arm/mach-tegra/board-endeavoru-baseband.c b/arch/arm/mach-tegra/board-endeavoru-baseband.c
deleted file mode 100644
index 991eed2..0000000
--- a/arch/arm/mach-tegra/board-endeavoru-baseband.c
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * arch/arm/mach-tegra/board-endeavoru-baseband.c
- *
- * Copyright (c) 2011, NVIDIA Corporation.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include <linux/resource.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/err.h>
-#include <linux/wakelock.h>
-#include <linux/platform_data/tegra_usb.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <mach/pinmux.h>
-#include <mach/usb_phy.h>
-#include <mach/tegra_usb_modem_power.h>
-#include "devices.h"
-#include "gpio-names.h"
-
-/* Tegra3 BB GPIO */
-#define MODEM_PWR_ON    TEGRA_GPIO_PE0
-#define MODEM_RESET     TEGRA_GPIO_PE1
-#define BB_RST_OUT      TEGRA_GPIO_PV1
-
-/* Icera BB GPIO */
-#define AP2MDM_ACK      TEGRA_GPIO_PE3
-#define MDM2AP_ACK      TEGRA_GPIO_PU5
-#define AP2MDM_ACK2     TEGRA_GPIO_PE2
-#define MDM2AP_ACK2     TEGRA_GPIO_PV0
-
-static struct wake_lock mdm_wake_lock;
-
-static struct gpio modem_gpios[] = {
-	{MODEM_PWR_ON, GPIOF_OUT_INIT_LOW, "MODEM PWR ON"},
-	{MODEM_RESET, GPIOF_IN, "MODEM RESET"},
-	{BB_RST_OUT, GPIOF_IN, "BB RST OUT"},
-	{MDM2AP_ACK, GPIOF_IN, "MDM2AP_ACK"},
-	{AP2MDM_ACK2, GPIOF_OUT_INIT_HIGH, "AP2MDM ACK2"},
-	{AP2MDM_ACK, GPIOF_OUT_INIT_LOW, "AP2MDM ACK"},
-	{TEGRA_GPIO_PY3, GPIOF_IN, "ULPI_STP"},
-	{TEGRA_GPIO_PO1, GPIOF_OUT_INIT_LOW, "ULPI_D0"},
-	{TEGRA_GPIO_PO2, GPIOF_OUT_INIT_LOW, "ULPI_D1"},
-};
-
-static int baseband_phy_on(void);
-static int baseband_phy_off(void);
-static void baseband_phy_restore_start(void);
-static void baseband_phy_restore_end(void);
-
-static struct tegra_ulpi_trimmer e1219_trimmer = { 10, 1, 1, 1 };
-
-static struct tegra_ulpi_config ehci2_null_ulpi_phy_config = {
-	.trimmer = &e1219_trimmer,
-	.post_phy_on = baseband_phy_on,
-	.pre_phy_off = baseband_phy_off,
-	.phy_restore_start = baseband_phy_restore_start,
-	.phy_restore_end = baseband_phy_restore_end,
-};
-
-static struct tegra_ehci_platform_data ehci2_null_ulpi_platform_data = {
-	.operating_mode = TEGRA_USB_HOST,
-	.power_down_on_bus_suspend = 0,
-	.phy_config = &ehci2_null_ulpi_phy_config,
-	.phy_type = TEGRA_USB_PHY_TYPE_NULL_ULPI,
-};
-
-static int __init tegra_null_ulpi_init(void)
-{
-	tegra_ehci2_device.dev.platform_data = &ehci2_null_ulpi_platform_data;
-	platform_device_register(&tegra_ehci2_device);
-	return 0;
-}
-
-static irqreturn_t mdm_start_thread(int irq, void *data)
-{
-	if (gpio_get_value(BB_RST_OUT)) {
-		pr_info("BB_RST_OUT high\n");
-	} else {
-		pr_info("BB_RST_OUT low\n");
-		/* hold wait lock to complete the enumeration */
-		wake_lock_timeout(&mdm_wake_lock, HZ * 10);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int baseband_phy_on(void)
-{
-	static bool phy_init = false;
-
-	if (!phy_init) {
-		/* set AP2MDM_ACK2 low */
-		gpio_set_value(AP2MDM_ACK2, 0);
-		phy_init = true;
-	}
-	pr_info("%s\n", __func__);
-	return 0;
-}
-
-static int baseband_phy_off(void)
-{
-	pr_info("%s\n", __func__);
-	return 0;
-}
-
-static void baseband_phy_restore_start(void)
-{
-	/* set AP2MDM_ACK2 high */
-	gpio_set_value(AP2MDM_ACK2, 1);
-}
-
-static void baseband_phy_restore_end(void)
-{
-	/* set AP2MDM_ACK2 low */
-	gpio_set_value(AP2MDM_ACK2, 0);
-}
-
-static void baseband_start(void)
-{
-	/*
-	 *  Leave baseband powered OFF.
-	 *  User-space daemons will take care of powering it up.
-	 */
-	pr_info("%s\n", __func__);
-	gpio_set_value(MODEM_PWR_ON, 0);
-}
-
-static void baseband_reset(void)
-{
-	/* Initiate power cycle on baseband sub system */
-	pr_info("%s\n", __func__);
-	gpio_set_value(MODEM_PWR_ON, 0);
-	mdelay(200);
-	gpio_set_value(MODEM_PWR_ON, 1);
-}
-
-static int baseband_init(void)
-{
-	int irq;
-	int ret;
-
-	ret = gpio_request_array(modem_gpios, ARRAY_SIZE(modem_gpios));
-	if (ret)
-		return ret;
-
-	/* enable pull-up for ULPI STP */
-	tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_ULPI_STP,
-				    TEGRA_PUPD_PULL_UP);
-
-	/* enable pull-up for MDM2AP_ACK2 */
-	tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_GPIO_PV0,
-				    TEGRA_PUPD_PULL_UP);
-
-	tegra_gpio_enable(MODEM_PWR_ON);
-	tegra_gpio_enable(MODEM_RESET);
-	tegra_gpio_enable(AP2MDM_ACK2);
-	tegra_gpio_enable(BB_RST_OUT);
-	tegra_gpio_enable(AP2MDM_ACK);
-	tegra_gpio_enable(MDM2AP_ACK);
-	tegra_gpio_enable(TEGRA_GPIO_PY3);
-	tegra_gpio_enable(TEGRA_GPIO_PO1);
-	tegra_gpio_enable(TEGRA_GPIO_PO2);
-
-	/* export GPIO for user space access through sysfs */
-	gpio_export(MODEM_PWR_ON, false);
-
-	/* phy init */
-	tegra_null_ulpi_init();
-
-	wake_lock_init(&mdm_wake_lock, WAKE_LOCK_SUSPEND, "mdm_lock");
-
-	/* enable IRQ for BB_RST_OUT */
-	irq = gpio_to_irq(BB_RST_OUT);
-
-	ret = request_threaded_irq(irq, NULL, mdm_start_thread,
-				   IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
-				   "mdm_start", NULL);
-	if (ret < 0) {
-		pr_err("%s: request_threaded_irq error\n", __func__);
-		return ret;
-	}
-
-	ret = enable_irq_wake(irq);
-	if (ret) {
-		pr_err("%s: enable_irq_wake error\n", __func__);
-		free_irq(irq, NULL);
-		return ret;
-	}
-
-	return 0;
-}
-
-static const struct tegra_modem_operations baseband_operations = {
-	.init = baseband_init,
-	.start = baseband_start,
-	.reset = baseband_reset,
-};
-
-static struct tegra_usb_modem_power_platform_data baseband_pdata = {
-	.ops = &baseband_operations,
-	.wake_gpio = MDM2AP_ACK2,
-	.flags = IRQF_TRIGGER_FALLING,
-};
-
-static struct platform_device icera_baseband_device = {
-	.name = "tegra_usb_modem_power",
-	.id = -1,
-	.dev = {
-		.platform_data = &baseband_pdata,
-	},
-};
-
-int __init enterprise_modem_init(void)
-{
-	platform_device_register(&icera_baseband_device);
-	return 0;
-}
diff --git a/arch/arm/mach-tegra/board-endeavoru-camera.c b/arch/arm/mach-tegra/board-endeavoru-camera.c
new file mode 100644
index 0000000..a31925d
--- /dev/null
+++ b/arch/arm/mach-tegra/board-endeavoru-camera.c
@@ -0,0 +1,700 @@
+/*
+ * arch/arm/mach-tegra/board-endeavoru-camera.c
+ *
+ * Copyright (c) 2011, NVIDIA CORPORATION, All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * Neither the name of NVIDIA CORPORATION nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <mach/gpio.h>
+#include <media/s5k3h2y.h>
+#include <media/s5k6a1gx03.h>
+#include <media/ad5823.h>
+#include <media/ov9726.h>
+#include <mach/board_htc.h>
+#include "cpu-tegra.h"
+#include "gpio-names.h"
+#include "board-endeavoru.h"
+#include "board.h"
+
+#define RAWCHIP 1
+#include <media/rawchip/Yushan_API.h>
+//#define CAMERA_REGULATOR
+
+static struct regulator *cam_vcm_2v85_en = NULL;
+static struct regulator *cam_vddio_1v8_en = NULL;
+static struct regulator *cam_a2v85_en = NULL;
+static struct regulator *cam_d1v2_en = NULL;
+static struct regulator *cam2_d1v2_en = NULL;
+
+static inline void ENR_msleep(u32 t)
+{
+	/*
+	 If timer value is between ( 10us - 20ms),
+	 ENR_usleep_range() is recommended.
+	 Please read Documentation/timers/timers-howto.txt.
+	 */
+	usleep_range(t * 1000, t * 1000 + 500);
+}
+
+static inline void ENR_usleep(u32 t)
+{
+	usleep_range(t, t + 500);
+}
+
+static int endeavor_s5k3h2y_power_state = 0;
+static int endeavor_s5k3h2y_get_power(void)
+{
+	return endeavor_s5k3h2y_power_state;
+}
+
+static int endeavor_s5k3h2y_power_on(void)
+{
+	int ret;
+
+	pr_info("[CAM] s5k3h2y power on ++\n");
+
+	if (endeavor_s5k3h2y_power_state)
+		return 0;
+
+	tegra_gpio_disable(RAW_SPI_CLK);
+	tegra_gpio_disable(RAW_SPI_CS);
+	tegra_gpio_disable(RAW_SPI_DI);
+	tegra_gpio_disable(RAW_SPI_DO);
+	//tegra_gpio_disable(RAW_INTR0);
+	//tegra_gpio_disable(RAW_INTR1);
+	tegra_gpio_disable(CAM_I2C_SCL_GPIO);
+	tegra_gpio_disable(CAM_I2C_SDA_GPIO);
+	tegra_gpio_disable(CAM_MCLK_GPIO);
+
+	gpio_direction_output(CAM_PWDN, 0);
+	gpio_direction_output(CAM1_VCM_PD_GPIO, 0);
+#if RAWCHIP
+	gpio_direction_output(RAW_RSTN, 0);
+#endif
+	//ENR_msleep(1); //TODO
+
+#ifdef CAMERA_REGULATOR
+	//pr_info("[CAM] use regurator to get power\n");
+
+#if RAWCHIP
+	/*RAW_1V8_EN */
+	gpio_direction_output(RAW_1V8_EN, 1);
+	ENR_usleep(200);
+#endif
+
+	/* VCM */
+	ret = regulator_enable(cam_vcm_2v85_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator v_cam1_vcm_2v85\n");
+		regulator_put(cam_vcm_2v85_en);
+		cam_vcm_2v85_en = NULL;
+		return ret;
+	}
+
+	/* main/front cam analog*/
+	ret = regulator_enable(cam_a2v85_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator cam_a2v85_en\n");
+		regulator_put(cam_a2v85_en);
+		cam_a2v85_en = NULL;
+		return ret;
+	}
+	ENR_usleep(200);
+
+	/*main cam core 1v2 & rawchip external 1v2 */
+	ret = regulator_enable(cam_d1v2_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator cam_d1v2_en\n");
+		regulator_put(cam_d1v2_en);
+		cam_d1v2_en = NULL;
+		return ret;
+	}
+	ENR_usleep(200);
+
+#if RAWCHIP
+	/*RAW_1V2_EN */
+	if ((htc_get_pcbid_info() < PROJECT_PHASE_XE) && machine_is_endeavoru())
+	{
+		gpio_direction_output(RAW_1V2_EN, 1);
+		ENR_usleep(200);
+	}
+#endif
+
+	/* IO */
+	ret = regulator_enable(cam_vddio_1v8_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator cam_vddio_1v8_en\n");
+		regulator_put(cam_vddio_1v8_en);
+		cam_vddio_1v8_en = NULL;
+		return ret;
+	}
+	ENR_usleep(100);
+
+	/*CAM SEL */
+	gpio_direction_output(CAM_SEL_GPIO, 0);
+	ENR_usleep(100);
+
+#if RAWCHIP
+	/*RAW_RSTN */
+	gpio_direction_output(RAW_RSTN, 1);
+	ENR_msleep(3);
+	/*SPI send command to configure RAWCHIP here!*/
+	yushan_spi_write(0x0008, 0x7f);
+	ENR_msleep(1);
+#endif
+
+	/* XSHUTDOWM */
+	gpio_direction_output(CAM_PWDN, 1);
+	ENR_usleep(100);
+
+	/* VCM PD*/
+	gpio_direction_output(CAM1_VCM_PD_GPIO, 1);
+	ENR_usleep(100);
+
+#else/* use gpio pull up to get power*/
+#if RAWCHIP
+	/*RAW_1V8_EN */
+	gpio_direction_output(RAW_1V8_EN, 1);
+	ENR_usleep(200);
+#endif
+
+	/* VCM */
+	gpio_direction_output(CAM_VCM2V85, 1);
+	ENR_usleep(200);
+
+	/* analog */
+	gpio_direction_output(CAM_A2V85_EN, 1);
+	ENR_usleep(200);
+
+	/*core*/
+	gpio_direction_output(CAM_D1V2_EN, 1);
+	ENR_usleep(200);
+
+#if RAWCHIP
+	/*RAW_1V2_EN */
+	if ((htc_get_pcbid_info() < PROJECT_PHASE_XE) && machine_is_endeavoru())
+	{
+		ret = gpio_direction_output(RAW_1V2_EN, 1);
+		ENR_usleep(200);
+	}
+#endif
+
+	/* IO */
+	gpio_direction_output(CAMIO_1V8_EN, 1);
+	ENR_usleep(100);
+
+	/*CAM SEL */
+	gpio_direction_output(CAM_SEL_GPIO, 0);
+	ENR_usleep(100);
+
+#if RAWCHIP
+	/*RAW_RSTN */
+	ret = gpio_direction_output(RAW_RSTN, 1);
+	ENR_msleep(3);
+
+	/*SPI send command to configure RAWCHIP here!*/
+	yushan_spi_write(0x0008, 0x7f);
+	ENR_msleep(1);
+#endif
+
+	/* XSHUTDOWM */
+	gpio_direction_output(CAM_PWDN, 1);
+	ENR_usleep(100);
+	/* VCM PD*/
+	gpio_direction_output(CAM1_VCM_PD_GPIO, 1);
+	ENR_usleep(100);
+#endif
+	endeavor_s5k3h2y_power_state = 1;
+	//pr_info("[CAM] s5k3h2y power on --\n");
+	return 0;
+}
+
+static int endeavor_s5k3h2y_power_off(void)
+{
+	pr_info("[CAM] s5k3h2y power off ++\n");
+	if (!endeavor_s5k3h2y_power_state)
+		return 0;
+	endeavor_s5k3h2y_power_state = 0;
+#ifdef CAMERA_REGULATOR
+	/* VCM PD*/
+	gpio_direction_output(CAM1_VCM_PD_GPIO, 0);
+	ENR_msleep(1);
+
+	/* XSHUTDOWN */
+	gpio_direction_output(CAM_PWDN, 0);
+	ENR_msleep(1);
+
+#if RAWCHIP
+	/* RAW RSTN*/
+	gpio_direction_output(RAW_RSTN, 0);
+	ENR_msleep(3);
+#endif
+
+	/* VCM */
+	regulator_disable(cam_vcm_2v85_en);
+	ENR_msleep(1);
+
+#if RAWCHIP
+	/*RAW_1V2_EN */
+	if ((htc_get_pcbid_info() < PROJECT_PHASE_XE) && machine_is_endeavoru())
+	{
+		gpio_direction_output(RAW_1V2_EN, 0);
+		ENR_msleep(5);
+	}
+#endif
+
+	/* digital */
+	regulator_disable(cam_d1v2_en);
+	ENR_msleep(1);
+
+#if RAWCHIP
+	/*RAW_1V8_EN */
+	gpio_direction_output(RAW_1V8_EN, 0);
+	ENR_msleep(1);
+#endif
+
+	/* analog */
+	regulator_disable(cam_a2v85_en);
+	ENR_msleep(5);
+	/* IO */
+	regulator_disable(cam_vddio_1v8_en);
+	ENR_msleep(10);
+
+#else/* use gpio pull down to disable power */
+	/* VCM PD*/
+	gpio_direction_output(CAM1_VCM_PD_GPIO, 0);
+	ENR_msleep(1);
+	/* TODO: Set 0x0100[0] = 0 (Enter SW Standby mode)*/
+
+	/* XSHUTDOWN */
+	gpio_direction_output(CAM_PWDN, 0);
+	ENR_msleep(1);
+
+#if RAWCHIP
+	/* RAW RSTN*/
+	gpio_direction_output(RAW_RSTN, 0);
+	ENR_msleep(3);
+#endif
+
+	/* VCM */
+	gpio_direction_output(CAM_VCM2V85, 0);
+	ENR_msleep(1);
+
+#if RAWCHIP
+	/*RAW_1V2_EN */
+	if ((htc_get_pcbid_info() < PROJECT_PHASE_XE) && machine_is_endeavoru())
+	{
+		gpio_direction_output(RAW_1V2_EN, 0);
+		ENR_msleep(5);
+	}
+#endif
+
+	/* digital */
+	gpio_direction_output(CAM_D1V2_EN, 0);
+	ENR_msleep(1);
+
+#if RAWCHIP
+	/*RAW_1V8_EN */
+	gpio_direction_output(RAW_1V8_EN, 0);
+	ENR_msleep(1);
+#endif
+
+	/* analog */
+	gpio_direction_output(CAM_A2V85_EN, 0);
+	ENR_msleep(5);
+	/* IO */
+	gpio_direction_output(CAMIO_1V8_EN, 0);
+	ENR_msleep(10);
+#endif
+
+	/* set gpio output low : O(L) */
+	tegra_gpio_enable(RAW_SPI_CLK);
+	tegra_gpio_enable(RAW_SPI_CS);
+	tegra_gpio_enable(RAW_SPI_DI);
+	tegra_gpio_enable(RAW_SPI_DO);
+	//tegra_gpio_enable(RAW_INTR0);
+	//tegra_gpio_enable(RAW_INTR1);
+	tegra_gpio_enable(CAM_I2C_SCL_GPIO);
+	tegra_gpio_enable(CAM_I2C_SDA_GPIO);
+	tegra_gpio_enable(CAM_MCLK_GPIO);
+
+	return 0;
+}
+
+struct s5k3h2y_platform_data endeavor_s5k3h2y_data =
+{
+	.get_power_state = endeavor_s5k3h2y_get_power,
+	.power_on = endeavor_s5k3h2y_power_on,
+	.power_off = endeavor_s5k3h2y_power_off,
+};
+
+struct ad5823_platform_data endeavor_ad5823_data =
+{
+	.get_power_state = endeavor_s5k3h2y_get_power,
+};
+
+static int endeavor_s5k6a1gx03_power_on(void)
+{
+	int ret;
+	pr_info("[CAM] s5k6a1g power on ++\n");
+	gpio_direction_output(FRONT_CAM_RST_GPIO, 0);
+	gpio_direction_output(CAM_SEL_GPIO, 0);
+
+	tegra_gpio_disable(CAM_I2C_SCL_GPIO);
+	tegra_gpio_disable(CAM_I2C_SDA_GPIO);
+	tegra_gpio_disable(CAM_MCLK_GPIO);
+
+#ifdef CAMERA_REGULATOR
+	pr_info("[CAM] use regurator to get power\n");
+	/* analog */
+	ret = regulator_enable(cam_a2v85_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator cam_a2v85_en\n");
+		regulator_put(cam_a2v85_en);
+		cam_a2v85_en = NULL;
+		return ret;
+	}
+	ENR_usleep(200);
+	/*vcm*/
+	ret = regulator_enable(cam_vcm_2v85_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator cam_vcm_2v85_en\n");
+		regulator_put(cam_vcm_2v85_en);
+		cam_vcm_2v85_en = NULL;
+		return ret;
+	}
+	ENR_usleep(200);
+	/*IO*/
+	ret = regulator_enable(cam_vddio_1v8_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator cam_vddio_1v8_en\n");
+		regulator_put(cam_vddio_1v8_en);
+		cam_vddio_1v8_en = NULL;
+		return ret;
+	}
+	ENR_usleep(200);
+	/*RSTN */
+	gpio_direction_output(FRONT_CAM_RST_GPIO, 1);
+	/* digital */
+	ret = regulator_enable(cam2_d1v2_en);
+	if (ret < 0)
+	{
+		pr_err("[CAM] couldn't enable regulator cam_d1v2_en\n");
+		regulator_put(cam_d1v2_en);
+		cam_d1v2_en = NULL;
+		return ret;
+	}
+	/*CAM SEL */
+	gpio_direction_output(CAM_SEL_GPIO, 1);
+	ENR_msleep(1);
+#else /* use gpio pull up to get power */
+	/* vcm */
+	gpio_direction_output(CAM_VCM2V85, 1);
+	ENR_usleep(200);
+	/* analog */
+	gpio_direction_output(CAM_A2V85_EN, 1);
+	ENR_usleep(200);
+	/*IO*/
+	gpio_direction_output(CAMIO_1V8_EN, 1);
+	ENR_usleep(200);
+	/*RSTN */
+	gpio_direction_output(FRONT_CAM_RST_GPIO, 1);
+	/* digital */
+	gpio_direction_output(CAM2_D1V2_EN, 1);
+	/*CAM SEL */
+	gpio_direction_output(CAM_SEL_GPIO, 1);
+	ENR_msleep(1);
+#endif
+	return 0;
+}
+
+static int endeavor_s5k6a1gx03_power_off(void)
+{
+	pr_info("[CAM] s5k6a1g power off ++\n");
+#ifdef CAMERA_REGULATOR
+	/*CAM SEL */
+	gpio_direction_output(CAM_SEL_GPIO, 0);
+	ENR_msleep(1);
+	/* vcm */
+	regulator_disable(cam_vcm_2v85_en);
+	ENR_msleep(1);
+	/* analog */
+	regulator_disable(cam_a2v85_en);
+	ENR_msleep(5);
+	/*RSTN */
+	gpio_direction_output(FRONT_CAM_RST_GPIO, 0);
+	/* digital */
+	regulator_disable(cam2_d1v2_en);
+	ENR_msleep(1);
+	/* IO */
+	regulator_disable(cam_vddio_1v8_en);
+	ENR_msleep(10);
+
+#else/* use gpio pull down to disable power*/
+	/*CAM SEL */
+	gpio_direction_output(CAM_SEL_GPIO, 0);
+	ENR_msleep(1);
+	/* vcm */
+	gpio_direction_output(CAM_VCM2V85, 0);
+	ENR_msleep(5);
+	/* analog */
+	gpio_direction_output(CAM_A2V85_EN, 0);
+	ENR_msleep(5);
+	/*RSTN */
+	gpio_direction_output(FRONT_CAM_RST_GPIO, 0);
+	/* digital */
+	gpio_direction_output(CAM2_D1V2_EN, 0);
+	ENR_msleep(1);
+	/* IO */
+	gpio_direction_output(CAMIO_1V8_EN, 0);
+	ENR_msleep(10);
+#endif
+
+	tegra_gpio_enable(CAM_I2C_SCL_GPIO);
+	tegra_gpio_enable(CAM_I2C_SDA_GPIO);
+	tegra_gpio_enable(CAM_MCLK_GPIO);
+
+	return 0;
+}
+
+struct s5k6a1gx03_platform_data endeavor_s5k6a1gx03_data =
+{
+	.power_on = endeavor_s5k6a1gx03_power_on,
+	.power_off = endeavor_s5k6a1gx03_power_off,
+};
+
+static struct i2c_board_info endeavor_i2c3_board_info[] =
+{
+	{ I2C_BOARD_INFO("s5k3h2y", 0x10), .platform_data = &endeavor_s5k3h2y_data, },
+	{ I2C_BOARD_INFO("ad5823", 0x0C), .platform_data = &endeavor_ad5823_data, }
+};
+
+static struct i2c_board_info endeavor_i2c4_board_info[] =
+{
+	{ I2C_BOARD_INFO("s5k6a1gx03", 0x36), .platform_data = &endeavor_s5k6a1gx03_data, },
+};
+
+struct endeavor_cam_gpio
+{
+	int gpio;
+	const char *label;
+	int value;
+};
+
+#define TEGRA_CAMERA_GPIO(_gpio, _label, _value)	\
+	{						\
+		.gpio = _gpio,				\
+		.label = _label,			\
+		.value = _value,			\
+	}
+
+#ifndef CAMERA_REGULATOR
+static struct endeavor_cam_gpio endeavor_cam_gpio_output_data[] =
+{
+	[0] = TEGRA_CAMERA_GPIO(CAM_SEL_GPIO, "cam_sel_gpio", 0),
+	[1] = TEGRA_CAMERA_GPIO(FRONT_CAM_RST_GPIO, "front_cam_rst_gpio", 0),
+	[2] = TEGRA_CAMERA_GPIO(CAM_A2V85_EN, "cam_a2v85_en", 0),
+	[3] = TEGRA_CAMERA_GPIO(CAM_PWDN, "cam_pwdn", 0),
+	[4] = TEGRA_CAMERA_GPIO(CAM_D1V2_EN, "cam_d1v2_en", 0),
+	[5] = TEGRA_CAMERA_GPIO(CAM2_D1V2_EN, "cam2_d1v2_en", 0),
+	[6] = TEGRA_CAMERA_GPIO(CAM_VCM2V85, "cam_vcm2v85", 0),
+	[7] = TEGRA_CAMERA_GPIO(CAMIO_1V8_EN, "camio_1v8_en", 0),
+	[8] = TEGRA_CAMERA_GPIO(CAM1_VCM_PD_GPIO, "cam1_vcm_pd", 0),
+	[9] = TEGRA_CAMERA_GPIO(CAM_I2C_SCL_GPIO, "CAM_I2C_SCL_GPIO", 0),
+	[10] = TEGRA_CAMERA_GPIO(CAM_I2C_SDA_GPIO, "CAM_I2C_SDA_GPIO", 0),
+	[11] = TEGRA_CAMERA_GPIO(CAM_MCLK_GPIO, "CAM_MCLK_GPIO", 0),
+	/*for rawchip */
+	[12] = TEGRA_CAMERA_GPIO(RAW_1V8_EN, "RAW_1V8_EN", 0),
+	[13] = TEGRA_CAMERA_GPIO(RAW_1V2_EN, "RAW_1V2_EN", 0),
+	[14] = TEGRA_CAMERA_GPIO(RAW_RSTN, "RAW_RSTN", 0),
+	[15] = TEGRA_CAMERA_GPIO(RAW_SPI_CLK, "RAW_SPI_CLK", 0),
+	[16] = TEGRA_CAMERA_GPIO(RAW_SPI_CS, "RAW_SPI_CS", 0),
+	[17] = TEGRA_CAMERA_GPIO(RAW_SPI_DI, "RAW_SPI_DI", 0),
+	[18] = TEGRA_CAMERA_GPIO(RAW_SPI_DO, "RAW_SPI_DO", 0),
+};
+#else
+static struct endeavor_cam_gpio endeavor_cam_gpio_output_data[] =
+{
+	[0] = TEGRA_CAMERA_GPIO(CAM_SEL_GPIO, "cam_sel_gpio", 0),
+	[1] = TEGRA_CAMERA_GPIO(FRONT_CAM_RST_GPIO, "front_cam_rst_gpio", 0),
+	[2] = TEGRA_CAMERA_GPIO(CAM_PWDN, "cam_pwdn", 0),
+	[3] = TEGRA_CAMERA_GPIO(CAM1_VCM_PD_GPIO, "cam1_vcm_pd", 0),
+	[4] = TEGRA_CAMERA_GPIO(CAM_I2C_SCL_GPIO, "CAM_I2C_SCL_GPIO", 0),
+	[5] = TEGRA_CAMERA_GPIO(CAM_I2C_SDA_GPIO, "CAM_I2C_SDA_GPIO", 0),
+	[6] = TEGRA_CAMERA_GPIO(CAM_MCLK_GPIO, "CAM_MCLK_GPIO", 0),
+	/*for rawchip */
+	[7] = TEGRA_CAMERA_GPIO(RAW_1V8_EN, "RAW_1V8_EN", 0),
+	[8] = TEGRA_CAMERA_GPIO(RAW_1V2_EN, "RAW_1V2_EN", 0),
+	[9] = TEGRA_CAMERA_GPIO(RAW_RSTN, "RAW_RSTN", 0),
+	[10] = TEGRA_CAMERA_GPIO(RAW_SPI_CLK, "RAW_SPI_CLK", 0),
+	[11] = TEGRA_CAMERA_GPIO(RAW_SPI_CS, "RAW_SPI_CS", 0),
+	[12] = TEGRA_CAMERA_GPIO(RAW_SPI_DI, "RAW_SPI_DI", 0),
+	[13] = TEGRA_CAMERA_GPIO(RAW_SPI_DO, "RAW_SPI_DO", 0),
+};
+#endif
+static struct endeavor_cam_gpio endeavor_cam_gpio_input_data[] =
+{
+	[0] = TEGRA_CAMERA_GPIO(CAM1_ID_GPIO, "cam1_id_gpio", 0),
+	[1] = TEGRA_CAMERA_GPIO(FRONT_CAM_ID_GPIO, "front_cam_id_gpio", 0),
+	[2] = TEGRA_CAMERA_GPIO(RAW_INTR0, "RAW_INTR0", 0),
+	[3] = TEGRA_CAMERA_GPIO(RAW_INTR1, "RAW_INTR1", 0),
+};
+
+int endeavor_cam_init(void)
+{
+	int ret;
+	int i = 0, j = 0;
+
+	for (i = 0; i < ARRAY_SIZE(endeavor_cam_gpio_output_data); i++)
+	{
+		/* for XE, raw_1v2_en is removed */
+		if ((htc_get_pcbid_info() >= PROJECT_PHASE_XE &&
+			endeavor_cam_gpio_output_data[i].gpio == RAW_1V2_EN) ||
+			(machine_is_erau() &&
+			endeavor_cam_gpio_output_data[i].gpio == RAW_1V2_EN))
+		{
+			continue;
+		}
+		ret = gpio_request(endeavor_cam_gpio_output_data[i].gpio,
+				endeavor_cam_gpio_output_data[i].label);
+		if (ret < 0)
+		{
+			pr_err("[CAM] %s: gpio_request failed for gpio #%d\n", __func__, i);
+			goto fail_free_gpio;
+		}
+		gpio_direction_output(endeavor_cam_gpio_output_data[i].gpio,
+				endeavor_cam_gpio_output_data[i].value);
+		gpio_export(endeavor_cam_gpio_output_data[i].gpio, false);
+		tegra_gpio_enable(endeavor_cam_gpio_output_data[i].gpio);
+	}
+
+	for (j = 0; j < ARRAY_SIZE(endeavor_cam_gpio_input_data); j++)
+	{
+		ret = gpio_request(endeavor_cam_gpio_input_data[j].gpio,
+				endeavor_cam_gpio_input_data[j].label);
+		if (ret < 0)
+		{
+			pr_err("[CAM] %s: gpio_request failed for gpio #%d\n", __func__, j);
+			goto fail_free_gpio;
+		}
+		gpio_direction_input(endeavor_cam_gpio_input_data[j].gpio);
+		gpio_export(endeavor_cam_gpio_input_data[j].gpio, false);
+		tegra_gpio_enable(endeavor_cam_gpio_input_data[j].gpio);
+	}
+	/* set gpio input no pull: I(NP) */
+	tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_KB_ROW6, TEGRA_PUPD_NORMAL);/* CAM1_ID_GPIO */
+	tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_KB_ROW0, TEGRA_PUPD_NORMAL);/* RAW_INTR0 */
+	tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_CLK3_REQ, TEGRA_PUPD_NORMAL);/* RAW_INTR1 */
+	/* set gpio input no pull: I(PU) */
+	tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_KB_ROW7, TEGRA_PUPD_PULL_UP);/* FRONT_CAM_ID_GPIO */
+
+	i2c_register_board_info(2, endeavor_i2c3_board_info,
+			ARRAY_SIZE(endeavor_i2c3_board_info));
+
+	i2c_register_board_info(2, endeavor_i2c4_board_info,
+			ARRAY_SIZE(endeavor_i2c4_board_info));
+
+	return 0;
+
+	fail_free_gpio: pr_err("[CAM] %s endeavor_cam_init failed!\n", __func__);
+	while (i--)
+		gpio_free(endeavor_cam_gpio_output_data[i].gpio);
+	while (j--)
+		gpio_free(endeavor_cam_gpio_input_data[j].gpio);
+	return ret;
+}
+
+int __init endeavor_cam_late_init(void)
+{
+	int ret = 0;
+	printk("%s: \n", __func__);
+	/* vcm */
+	cam_vcm_2v85_en = regulator_get(NULL, "v_cam_vcm_2v85");
+	if (IS_ERR_OR_NULL(cam_vcm_2v85_en))
+	{
+		ret = PTR_ERR(cam_vcm_2v85_en);
+		pr_err("[CAM] couldn't get regulator v_cam_vcm_2v85\n");
+		cam_vcm_2v85_en = NULL;
+		return ret;
+	}
+	/* io */
+	cam_vddio_1v8_en = regulator_get(NULL, "v_camio_1v8");
+	if (IS_ERR_OR_NULL(cam_vddio_1v8_en))
+	{
+		ret = PTR_ERR(cam_vddio_1v8_en);
+		pr_err("[CAM] couldn't get regulator v_camio_1v8\n");
+		cam_vddio_1v8_en = NULL;
+		return ret;
+	}
+	/* analog */
+	cam_a2v85_en = regulator_get(NULL, "v_cam_a2v85");
+	if (IS_ERR_OR_NULL(cam_a2v85_en))
+	{
+		ret = PTR_ERR(cam_a2v85_en);
+		pr_err("[CAM] couldn't get regulator v_cam_a2v85\n");
+		cam_a2v85_en = NULL;
+		return ret;
+	}
+	/* cam_d1v2 */
+	cam_d1v2_en = regulator_get(NULL, "v_cam_d1v2");
+	if (IS_ERR_OR_NULL(cam_d1v2_en))
+	{
+		ret = PTR_ERR(cam_d1v2_en);
+		pr_err("[CAM] couldn't get regulator v_cam_d1v2\n");
+		cam_d1v2_en = NULL;
+		return ret;
+	}
+	/* cam2_d1v2 */
+	cam2_d1v2_en = regulator_get(NULL, "v_cam2_d1v2");
+	if (IS_ERR_OR_NULL(cam2_d1v2_en))
+	{
+		ret = PTR_ERR(cam2_d1v2_en);
+		pr_err("[CAM] couldn't get regulator v_cam2_d1v2\n");
+		cam2_d1v2_en = NULL;
+		return ret;
+	}
+	return ret;
+}
+
+#ifdef CAMERA_REGULATOR
+late_initcall(endeavor_cam_late_init);
+#endif
diff --git a/arch/arm/mach-tegra/board-endeavoru-power.c b/arch/arm/mach-tegra/board-endeavoru-power.c
index 9e6fdfa..28ddb2e 100644
--- a/arch/arm/mach-tegra/board-endeavoru-power.c
+++ b/arch/arm/mach-tegra/board-endeavoru-power.c
@@ -38,6 +38,8 @@
 #include <mach/pinmux.h>
 #include <mach/board_htc.h>
 
+#include <asm/mach-types.h>
+
 #include "gpio-names.h"
 #include "board.h"
 #include "board-endeavoru.h"
@@ -379,7 +381,7 @@ static struct tps80031_platform_data tps_platform = {
 	.clk32k_init_data_size	= ARRAY_SIZE(clk32k_idata),
 };
 
-static struct i2c_board_info __initdata enterprise_regulators[] = {
+static struct i2c_board_info __initdata endeavor_regulators[] = {
 	{
 		I2C_BOARD_INFO("tps80031", 0x4A),
 		.irq		= INT_EXTERNAL_PMU,
@@ -591,13 +593,19 @@ static struct platform_device gswitch_regulator_pdata = {
 	},
 };
 
-static int __init enterprise_gpio_switch_regulator_init(void)
+static int __init endeavor_gpio_switch_regulator_init(void)
 {
 	int i;
-	if(htc_get_pcbid_info() >= PROJECT_PHASE_XD) {
+	if( machine_is_endeavoru() && (htc_get_pcbid_info() >= PROJECT_PHASE_XD) ) {
 		gswitch_pdata.num_subdevs = ARRAY_SIZE(gswitch_subdevs_xd);
 		gswitch_pdata.subdevs = gswitch_subdevs_xd;
 	}
+	else if (machine_is_erau()) {
+                gswitch_pdata.num_subdevs = ARRAY_SIZE(gswitch_subdevs_xd);
+                gswitch_pdata.subdevs = gswitch_subdevs_xd;
+        }
+
+
 	for (i = 0; i < gswitch_pdata.num_subdevs; ++i) {
 		struct gpio_switch_regulator_subdev_data *gswitch_data =
 						gswitch_pdata.subdevs[i];
@@ -646,28 +654,28 @@ fail:
 	return ret;
 }
 
-static void enterprise_power_off(void)
+static void endeavor_power_off(void)
 {
 	int ret;
 #if 0
-        pr_info("enterprise: Powering off the device\n");
+        pr_info("endeavoru: Powering off the device\n");
         ret = tps80031_power_off();
 #else
-        pr_info("enterprise: Powering off the device or"
+        pr_info("endeavoru: Powering off the device or"
                 " enter offmode charging\n");
         tps80031_power_off_or_reboot();
 #endif
 	if (ret)
-		pr_err("enterprise: failed to power off\n");
+		pr_err("endeavoru: failed to power off\n");
 	while(1);
 }
 
-void __init enterprise_tsensor_init(void)
+void __init endeavor_tsensor_init(void)
 {
 	tegra3_tsensor_init(NULL);
 }
 
-int __init enterprise_regulator_init(void)
+int __init endeavor_regulator_init(void)
 {
 	void __iomem *pmc = IO_ADDRESS(TEGRA_PMC_BASE);
 	u32 pmc_ctrl;
@@ -686,19 +694,28 @@ int __init enterprise_regulator_init(void)
 
 	int projectPhase = htc_get_pcbid_info();
 
-	if (projectPhase == PROJECT_PHASE_XD){
-		tps_platform.num_subdevs = ARRAY_SIZE(tps80031_devs_xd);
-		tps_platform.subdevs = tps80031_devs_xd;
-	} else if (projectPhase >= PROJECT_PHASE_XE){
+	if (machine_is_endeavoru())
+	{
+		if (projectPhase == PROJECT_PHASE_XD){
+			tps_platform.num_subdevs = ARRAY_SIZE(tps80031_devs_xd);
+			tps_platform.subdevs = tps80031_devs_xd;
+		} else if (projectPhase >= PROJECT_PHASE_XE){
+			tps_platform.num_subdevs = ARRAY_SIZE(tps80031_devs_xe);
+			tps_platform.subdevs = tps80031_devs_xe;
+		}
+	}
+	else if (machine_is_erau())
+	{
 		tps_platform.num_subdevs = ARRAY_SIZE(tps80031_devs_xe);
 		tps_platform.subdevs = tps80031_devs_xe;
 	}
-	i2c_register_board_info(4, enterprise_regulators, 1);
-	enterprise_gpio_switch_regulator_init();
-	pm_power_off = enterprise_power_off;
+
+	i2c_register_board_info(4, endeavor_regulators, 1);
+	endeavor_gpio_switch_regulator_init();
+	pm_power_off = endeavor_power_off;
 
 
-	if (htc_get_pcbid_info() <= PROJECT_PHASE_XC) {
+	if ( machine_is_endeavoru() && (htc_get_pcbid_info() <= PROJECT_PHASE_XC) ) {
 		pr_info("[PMIC]Registering the device FAN53555\n");
 		i2c_register_board_info(4, fan53555_boardinfo, 1);
 	}
@@ -706,55 +723,55 @@ int __init enterprise_regulator_init(void)
 	return 0;
 }
 
-static void enterprise_board_suspend(int lp_state, enum suspend_stage stg)
+static void endeavor_board_suspend(int lp_state, enum suspend_stage stg)
 {
 	if ((lp_state == TEGRA_SUSPEND_LP1) && (stg == TEGRA_SUSPEND_BEFORE_CPU))
 		tegra_console_uart_suspend();
 }
 
-static void enterprise_board_resume(int lp_state, enum resume_stage stg)
+static void endeavor_board_resume(int lp_state, enum resume_stage stg)
 {
 	if ((lp_state == TEGRA_SUSPEND_LP1) && (stg == TEGRA_RESUME_AFTER_CPU))
 		tegra_console_uart_resume();
 }
 
-static struct tegra_suspend_platform_data enterprise_suspend_data = {
-	.cpu_timer	= 2000,
+static struct tegra_suspend_platform_data endeavor_suspend_data = {
+	.cpu_timer	= 600,
 	.cpu_off_timer	= 200,
 	.suspend_mode	= TEGRA_SUSPEND_LP0,
-	.core_timer	= 0x7e7e,
+	.core_timer	= 0x0b21,
 	.core_off_timer = 0,
 	.corereq_high	= true,
 	.sysclkreq_high	= true,
-	.board_suspend = enterprise_board_suspend,
-	.board_resume = enterprise_board_resume,
+	.board_suspend = endeavor_board_suspend,
+	.board_resume = endeavor_board_resume,
 	.cpu_resume_boost	= 1500000,
 	.boost_resume_reason	= 0x80,
 };
 
-static void enterprise_init_deep_sleep_mode(void)
+static void endeavor_init_deep_sleep_mode(void)
 {
 	struct board_info bi;
 	tegra_get_board_info(&bi);
 
 	if (bi.board_id == BOARD_E1205 && bi.fab == BOARD_FAB_A01)
-		enterprise_suspend_data.suspend_mode = TEGRA_SUSPEND_LP1;
+		endeavor_suspend_data.suspend_mode = TEGRA_SUSPEND_LP1;
 
 	if ((bi.board_id == BOARD_E1205 && (bi.sku & BOARD_SKU_VF_BIT) == 0) ||
 	    (bi.board_id == BOARD_E1197 && (bi.sku & BOARD_SKU_VF_BIT)))
-		enterprise_suspend_data.cpu_timer = 8000;
+		endeavor_suspend_data.cpu_timer = 8000;
 }
 
-int __init enterprise_suspend_init(void)
+int __init endeavor_suspend_init(void)
 {
-	enterprise_init_deep_sleep_mode();
-	tegra_init_suspend(&enterprise_suspend_data);
+	endeavor_init_deep_sleep_mode();
+	tegra_init_suspend(&endeavor_suspend_data);
 	return 0;
 }
 
 #ifdef CONFIG_TEGRA_EDP_LIMITS
 
-int __init enterprise_edp_init(void)
+int __init endeavor_edp_init(void)
 {
 	unsigned int regulator_mA;
 
@@ -776,7 +793,7 @@ static struct tegra_bpc_mgmt_platform_data bpc_mgmt_platform_data = {
 	.bpc_mgmt_timeout = TEGRA_BPC_TIMEOUT,
 };
 
-static struct platform_device enterprise_bpc_mgmt_device = {
+static struct platform_device endeavor_bpc_mgmt_device = {
 	.name		= "tegra-bpc-mgmt",
 	.id		= -1,
 	.dev		= {
@@ -784,7 +801,7 @@ static struct platform_device enterprise_bpc_mgmt_device = {
 	},
 };
 
-void __init enterprise_bpc_mgmt_init(void)
+void __init endeavor_bpc_mgmt_init(void)
 {
 	int int_gpio;
 
@@ -798,7 +815,7 @@ void __init enterprise_bpc_mgmt_init(void)
 				&(bpc_mgmt_platform_data.affinity_mask));
 	irq_set_affinity(int_gpio, &(bpc_mgmt_platform_data.affinity_mask));
 #endif
-	platform_device_register(&enterprise_bpc_mgmt_device);
+	platform_device_register(&endeavor_bpc_mgmt_device);
 
 	return;
 }
diff --git a/arch/arm/mach-tegra/board-endeavoru-sdhci.c b/arch/arm/mach-tegra/board-endeavoru-sdhci.c
index 3f24cd6..b83a290 100644
--- a/arch/arm/mach-tegra/board-endeavoru-sdhci.c
+++ b/arch/arm/mach-tegra/board-endeavoru-sdhci.c
@@ -35,40 +35,42 @@
 #include <linux/wl12xx.h>
 /* HTC_WIFI_END */
 
-#define ENTERPRISE_WLAN_PWR	TEGRA_GPIO_PV2
-#define ENTERPRISE_WLAN_RST	TEGRA_GPIO_PV3
-#define ENTERPRISE_WLAN_WOW	TEGRA_GPIO_PO4
+#define ENDEAVOR_WLAN_PWR	TEGRA_GPIO_PV2
+#define ENDEAVOR_WLAN_RST	TEGRA_GPIO_PV3
+#define ENDEAVOR_WLAN_WOW	TEGRA_GPIO_PO4
 
-//#define ENTERPRISE_SD_CD TEGRA_GPIO_PI5
+#define SDIO_CLK TEGRA_GPIO_PA6
+
+//#define ENDEAVOR_SD_CD TEGRA_GPIO_PI5
 
 static void (*wifi_status_cb)(int card_present, void *dev_id);
 static void *wifi_status_cb_devid;
-static int enterprise_wifi_status_register(void (*callback)(int , void *), void *);
+static int endeavor_wifi_status_register(void (*callback)(int , void *), void *);
 
-static int enterprise_wifi_reset(int on);
+static int endeavor_wifi_reset(int on);
 /* HTC_WIFI_START */
-//static int enterprise_wifi_power(int on);
-//static int enterprise_wifi_set_carddetect(int val);
-int enterprise_wifi_power(int on);
-int enterprise_wifi_set_carddetect(int val);
-int enterprise_wifi_status(struct device *dev);
-static int enterprise_wifi_cd;		/* WIFI virtual 'card detect' status */
+//static int endeavor_wifi_power(int on);
+//static int endeavor_wifi_set_carddetect(int val);
+int endeavor_wifi_power(int on);
+int endeavor_wifi_set_carddetect(int val);
+int endeavor_wifi_status(struct device *dev);
+static int endeavor_wifi_cd;		/* WIFI virtual 'card detect' status */
 /* HTC_WIFI_END */
 
 
 /* HTC_WIFI_START */
-static struct wl12xx_platform_data enterprise_wlan_data __initdata = {
-	.irq = TEGRA_GPIO_TO_IRQ(ENTERPRISE_WLAN_WOW),
+static struct wl12xx_platform_data endeavor_wlan_data __initdata = {
+	.irq = TEGRA_GPIO_TO_IRQ(ENDEAVOR_WLAN_WOW),
 	.board_ref_clock = WL12XX_REFCLOCK_26,
 	.board_tcxo_clock = 1,
 //	.platform_quirks = WL12XX_PLATFORM_QUIRK_EDGE_IRQ,
 };
 /* HTC_WIFI_END */
 
-static struct wifi_platform_data enterprise_wifi_control = {
-	.set_power      = enterprise_wifi_power,
-	.set_reset      = enterprise_wifi_reset,
-	.set_carddetect = enterprise_wifi_set_carddetect,
+static struct wifi_platform_data endeavor_wifi_control = {
+	.set_power      = endeavor_wifi_power,
+	.set_reset      = endeavor_wifi_reset,
+	.set_carddetect = endeavor_wifi_set_carddetect,
 };
 
 static struct resource wifi_resource[] = {
@@ -80,13 +82,13 @@ static struct resource wifi_resource[] = {
 	},
 };
 
-static struct platform_device enterprise_wifi_device = {
+static struct platform_device endeavor_wifi_device = {
 	.name           = "bcm4329_wlan",
 	.id             = 1,
 	.num_resources	= 1,
 	.resource	= wifi_resource,
 	.dev            = {
-		.platform_data = &enterprise_wifi_control,
+		.platform_data = &endeavor_wifi_control,
 	},
 };
 
@@ -162,7 +164,7 @@ static struct embedded_sdio_data embedded_sdio_data0 = {
 #if 0
 static struct tegra_sdhci_platform_data tegra_sdhci_platform_data0 = {
 	.mmc_data = {
-		.register_status_notify	= enterprise_wifi_status_register,
+		.register_status_notify	= endeavor_wifi_status_register,
 		.embedded_sdio = &embedded_sdio_data0,
 		/* FIXME need to revert the built_in change
 		once we use get the signal strength fix of
@@ -178,8 +180,8 @@ static struct tegra_sdhci_platform_data tegra_sdhci_platform_data0 = {
 
 static struct tegra_sdhci_platform_data tegra_sdhci_platform_data2 = {
 	.mmc_data = {
-		.status = enterprise_wifi_status,
-		.register_status_notify	= enterprise_wifi_status_register,
+		.status = endeavor_wifi_status,
+		.register_status_notify	= endeavor_wifi_status_register,
 		/* HTC_WIFI_START */
 		//.embedded_sdio = &embedded_sdio_data0,
 		/* HTC_WIFI_END */
@@ -235,7 +237,7 @@ static struct platform_device tegra_sdhci_device3 = {
 	},
 };
 
-static int enterprise_wifi_status_register(
+static int endeavor_wifi_status_register(
 		void (*callback)(int card_present, void *dev_id),
 		void *dev_id)
 {
@@ -247,26 +249,36 @@ static int enterprise_wifi_status_register(
 }
 
 /* HTC_WIFI_START */
-int enterprise_wifi_status(struct device *dev)
+int endeavor_wifi_status(struct device *dev)
 {
-	return enterprise_wifi_cd;
+	return endeavor_wifi_cd;
 }
 
-//static int enterprise_wifi_set_carddetect(int val)
-int enterprise_wifi_set_carddetect(int val)
+//static int endeavor_wifi_set_carddetect(int val)
+int endeavor_wifi_set_carddetect(int val)
 {
 	printk("%s: %d\n", __func__, val);
-	enterprise_wifi_cd = val;
+	endeavor_wifi_cd = val;
 	if (wifi_status_cb)
 		wifi_status_cb(val, wifi_status_cb_devid);
 	else
 		pr_warning("%s: Nobody to notify\n", __func__);
 	return 0;
 }
-EXPORT_SYMBOL(enterprise_wifi_set_carddetect);
+EXPORT_SYMBOL(endeavor_wifi_set_carddetect);
+
+int enterprise_wifi_sdclk (int enable){
+    printk("set sdio clk:%d\n",enable);
+    if(enable) {
+        tegra_gpio_disable(SDIO_CLK);
+    }else{
+        tegra_gpio_enable(SDIO_CLK);
+        gpio_direction_output(SDIO_CLK, 0);
+    }
+}
 
-//static int enterprise_wifi_power(int on)
-int enterprise_wifi_power(int on)
+//static int endeavor_wifi_power(int on)
+int endeavor_wifi_power(int on)
 {
 	static int power_state;
 
@@ -276,74 +288,76 @@ int enterprise_wifi_power(int on)
 	printk("%s: Powering %s wifi\n", __func__, (on ? "on" : "off"));
 
 	power_state = on;
+	enterprise_wifi_sdclk(on);
+	
 	if (on) {
-		gpio_set_value(ENTERPRISE_WLAN_PWR, 1);
+		gpio_set_value(ENDEAVOR_WLAN_PWR, 1);
 		mdelay(20);
 	} else {
-		gpio_set_value(ENTERPRISE_WLAN_PWR, 0);
+		gpio_set_value(ENDEAVOR_WLAN_PWR, 0);
 	}
 
 	return 0;
 /*	
 	pr_debug("%s: %d\n", __func__, on);
-	gpio_set_value(ENTERPRISE_WLAN_PWR, on);
+	gpio_set_value(ENDEAVOR_WLAN_PWR, on);
 	mdelay(100);
-	gpio_set_value(ENTERPRISE_WLAN_RST, on);
+	gpio_set_value(ENDEAVOR_WLAN_RST, on);
 	mdelay(200);
 
 	return 0;
 */
 }
-EXPORT_SYMBOL(enterprise_wifi_power);
+EXPORT_SYMBOL(endeavor_wifi_power);
 /* HTC_WIFI_END */
 
-static int enterprise_wifi_reset(int on)
+static int endeavor_wifi_reset(int on)
 {
 	pr_debug("%s: do nothing\n", __func__);
 	return 0;
 }
 
-static int __init enterprise_wifi_init(void)
+static int __init endeavor_wifi_init(void)
 {
 	int rc;
 
-	rc = gpio_request(ENTERPRISE_WLAN_PWR, "wlan_power");
+	rc = gpio_request(ENDEAVOR_WLAN_PWR, "wlan_power");
 	if (rc)
 		pr_err("WLAN_PWR gpio request failed:%d\n", rc);
-	rc = gpio_request(ENTERPRISE_WLAN_RST, "wlan_rst");
+	rc = gpio_request(ENDEAVOR_WLAN_RST, "wlan_rst");
 	if (rc)
 		pr_err("WLAN_RST gpio request failed:%d\n", rc);
-	rc = gpio_request(ENTERPRISE_WLAN_WOW, "bcmsdh_sdmmc");
+	rc = gpio_request(ENDEAVOR_WLAN_WOW, "bcmsdh_sdmmc");
 	if (rc)
 		pr_err("WLAN_WOW gpio request failed:%d\n", rc);
 
-	tegra_gpio_enable(ENTERPRISE_WLAN_PWR);
-	tegra_gpio_enable(ENTERPRISE_WLAN_RST);
-	tegra_gpio_enable(ENTERPRISE_WLAN_WOW);
+	tegra_gpio_enable(ENDEAVOR_WLAN_PWR);
+	tegra_gpio_enable(ENDEAVOR_WLAN_RST);
+	tegra_gpio_enable(ENDEAVOR_WLAN_WOW);
 
-	rc = gpio_direction_output(ENTERPRISE_WLAN_PWR, 0);
+	rc = gpio_direction_output(ENDEAVOR_WLAN_PWR, 0);
 	if (rc)
 		pr_err("WLAN_PWR gpio direction configuration failed:%d\n", rc);
-	gpio_direction_output(ENTERPRISE_WLAN_RST, 0);
+	gpio_direction_output(ENDEAVOR_WLAN_RST, 0);
 	if (rc)
 		pr_err("WLAN_RST gpio direction configuration failed:%d\n", rc);
-	rc = gpio_direction_input(ENTERPRISE_WLAN_WOW);
+	rc = gpio_direction_input(ENDEAVOR_WLAN_WOW);
 	if (rc)
 		pr_err("WLAN_WOW gpio direction configuration failed:%d\n", rc);
 
 	/* HTC_WIFI_START */
-	// platform_device_register(&enterprise_wifi_device);
-	if (wl12xx_set_platform_data(&enterprise_wlan_data))
+	// platform_device_register(&endeavor_wifi_device);
+	if (wl12xx_set_platform_data(&endeavor_wlan_data))
 		pr_err("Error setting wl12xx_data\n");
 	/* HTC_WIFI_END */
 	return 0;
 }
 
-int __init enterprise_sdhci_init(void)
+int __init endeavor_sdhci_init(void)
 {
 	platform_device_register(&tegra_sdhci_device3);
 	platform_device_register(&tegra_sdhci_device2);
-	enterprise_wifi_init();
+	endeavor_wifi_init();
 	return 0;
 }
 
diff --git a/arch/arm/mach-tegra/board-endeavoru-sensors.c b/arch/arm/mach-tegra/board-endeavoru-sensors.c
index 6bafbeb..a87f324 100644
--- a/arch/arm/mach-tegra/board-endeavoru-sensors.c
+++ b/arch/arm/mach-tegra/board-endeavoru-sensors.c
@@ -37,7 +37,6 @@
 #include <linux/err.h>
 #include <linux/mpu_htc.h>
 #include <linux/nct1008.h>
-#include <linux/err.h>
 #include <linux/mpu.h>
 #include <linux/platform_data/ina230.h>
 #include <linux/regulator/consumer.h>
@@ -48,11 +47,7 @@
 #include <linux/pn544.h>
 #include <mach/gpio.h>
 #include <media/ar0832_main.h>
-#include <media/s5k3h2y.h>
-#include <media/s5k6a1gx03.h>
-#include <media/ad5823.h>
 #include <media/tps61050.h>
-#include <media/ov9726.h>
 #include <mach/edp.h>
 #include <mach/thermal.h>
 #include "cpu-tegra.h"
@@ -75,7 +70,7 @@ static struct regulator *v_sdmmc_2v85_en ;
 static struct regulator *v_srio_1v8_en ;
 void cm3629_enable_power(int enable)
 {
-	if(htc_get_pcbid_info() >= PROJECT_PHASE_XD) {
+	if(htc_get_pcbid_info() >= PROJECT_PHASE_XD || machine_is_erau()) {
 		if(enable == 1) {
 			if (v_sdmmc_2v85_en == NULL) {
 		  		v_sdmmc_2v85_en = regulator_get(NULL, "v_sdmmc_2v85");
@@ -214,11 +209,6 @@ static void psensor_init(void)
 	}
 #endif
 }
-static struct regulator *cam_vcm_2v85_en = NULL;
-static struct regulator *cam_vddio_1v8_en = NULL;
-static struct regulator *cam_a2v85_en = NULL;
-static struct regulator *cam_d1v2_en = NULL;
-static struct regulator *cam2_d1v2_en = NULL;
 
 #ifndef CONFIG_TEGRA_INTERNAL_TSENSOR_EDP_SUPPORT
 static int nct_get_temp(void *_data, long *temp)
@@ -282,7 +272,7 @@ static void nct1008_probe_callback(struct nct1008_data *data)
 }
 #endif
 
-static struct nct1008_platform_data enterprise_nct1008_pdata = {
+static struct nct1008_platform_data endeavor_nct1008_pdata = {
 	.supported_hwrev = true,
 	.ext_range = true,
 	.conv_rate = 0x08,
@@ -291,18 +281,19 @@ static struct nct1008_platform_data enterprise_nct1008_pdata = {
 	.probe_callback = nct1008_probe_callback,
 #endif
 	.reg_name = "v_usb_3v3",
+	.gpio = TEGRA_GPIO_PCC2,
 };
 
-static struct i2c_board_info enterprise_i2c4_nct1008_board_info[] = {
+static struct i2c_board_info endeavor_i2c4_nct1008_board_info[] = {
 	{
 		I2C_BOARD_INFO("nct1008", 0x4C),
 		//.irq = TEGRA_GPIO_TO_IRQ(TEGRA_GPIO_PH7),
 		.irq = TEGRA_GPIO_TO_IRQ(TEGRA_GPIO_PCC2),
-		.platform_data = &enterprise_nct1008_pdata,
+		.platform_data = &endeavor_nct1008_pdata,
 	}
 };
 
-static void enterprise_nct1008_init(void)
+static void endeavor_nct1008_init(void)
 {
 	int ret;
 
@@ -336,8 +327,8 @@ tegra_gpio_enable(TEGRA_GPIO_PCC2);
 		return;
 	}
 
-	i2c_register_board_info(4, enterprise_i2c4_nct1008_board_info,
-				ARRAY_SIZE(enterprise_i2c4_nct1008_board_info));
+	i2c_register_board_info(4, endeavor_i2c4_nct1008_board_info,
+				ARRAY_SIZE(endeavor_i2c4_nct1008_board_info));
 }
 void config_ruby_gyro_diag_gpios(bool pulldown)
 {
@@ -415,7 +406,7 @@ static struct i2c_board_info i2c_akm8975_devices_xc[] = {
 #define SENSOR_MPU_NAME "mpu3050"
 static struct mpu3050_platform_data mpu3050_data = {
 	.int_config  = 0x10,
-	/* Orientation matrix for MPU on enterprise */
+	/* Orientation matrix for MPU on endeavoru */
 	#if defined(CONFIG_BOARD_EVT)
 	#warning "EVT board"
 	  .en_1v8 = 1,
@@ -432,7 +423,7 @@ static struct mpu3050_platform_data mpu3050_data = {
 		.bus         = EXT_SLAVE_BUS_SECONDARY,
 		//.address     = 0x0F,
 		.address     = 0x19, //for A-project
-		/* Orientation matrix for Kionix on enterprise */
+		/* Orientation matrix for Kionix on endeavoru */
 		#if defined(CONFIG_BOARD_EVT)
 		#warning "EVT board"
 		  .orientation = { -1, 0, 0, 0, 1, 0, 0, 0,-1 }, // EVT .orientation = { -1, 0, 0, 0, 1, 0, 0, 0,-1 }, // EVT
@@ -448,7 +439,7 @@ static struct mpu3050_platform_data mpu3050_data = {
 		.bus         = EXT_SLAVE_BUS_PRIMARY,
 		//.address     = 0x0C,
 		.address     = 0x0D,//for A-project
-		/* Orientation matrix for AKM on enterprise */
+		/* Orientation matrix for AKM on endeavoru */
 		#if defined(CONFIG_BOARD_EVT)
 		#warning "EVT board"
 		  .orientation = { 1, 0, 0, 0, 1, 0, 0, 0, 1 }, // EVT
@@ -541,14 +532,14 @@ static inline void ENR_usleep(u32 t)
         usleep_range(t, t + 500);
 }
 
-static void enterprise_gsensor_irq_init(void)
+static void endeavor_gsensor_irq_init(void)
 {
 	int ret = 0;
 
 	//tegra_gpio_enable(TEGRA_GPIO_PH4);
 	//ret = gpio_request(TEGRA_GPIO_PH4, SENSOR_MPU_NAME);
 	pr_info("[GSNR] g-sensor irq_start...\n");
-	if(htc_get_pcbid_info() <= PROJECT_PHASE_XB){
+	if(htc_get_pcbid_info() <= PROJECT_PHASE_XB && !(machine_is_erau())){
 		ret = gpio_request(TEGRA_GPIO_PO5, "GSNR_INT");
 		if (ret < 0) {
 			pr_err("%s: gpio_request failed %d\n", __func__, ret);
@@ -586,7 +577,7 @@ static void enterprise_gsensor_irq_init(void)
 
 }
 
-static void enterprise_gyro_diag_init(void)
+static void endeavor_gyro_diag_init(void)
 {
 	int ret = 0;
 
@@ -612,31 +603,47 @@ static void enterprise_gyro_diag_init(void)
 
 }
 
-static void enterprise_mpuirq_init(void)
+static void endeavor_mpuirq_init(void)
 {
 	int ret = 0;
+	if(machine_is_endeavoru()){
+		tegra_gpio_enable(TEGRA_GPIO_PI6);
+		ret = gpio_request(TEGRA_GPIO_PI6, SENSOR_MPU_NAME);
+		if (ret < 0) {
+			pr_err("%s: gpio_request failed %d\n", __func__, ret);
+			return;
+		}
 
-	tegra_gpio_enable(TEGRA_GPIO_PI6);
-	ret = gpio_request(TEGRA_GPIO_PI6, SENSOR_MPU_NAME);
-	if (ret < 0) {
-		pr_err("%s: gpio_request failed %d\n", __func__, ret);
-		return;
+		ret = gpio_direction_input(TEGRA_GPIO_PI6);
+		if (ret < 0) {
+			pr_err("%s: gpio_direction_input failed %d\n", __func__, ret);
+			gpio_free(TEGRA_GPIO_PI6);
+			return;
+		}
+		tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_GMI_CS7_N, TEGRA_PUPD_NORMAL);
 	}
 
-	ret = gpio_direction_input(TEGRA_GPIO_PI6);
-	if (ret < 0) {
-		pr_err("%s: gpio_direction_input failed %d\n", __func__, ret);
-		gpio_free(TEGRA_GPIO_PI6);
-		return;
-	}
-	tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_GMI_CS7_N, TEGRA_PUPD_NORMAL);
+	if(machine_is_erau()){
+		tegra_gpio_enable(TEGRA_GPIO_PS0);
+                ret = gpio_request(TEGRA_GPIO_PS0, SENSOR_MPU_NAME);
+                if (ret < 0) {
+                        pr_err("%s: gpio_request failed %d\n", __func__, ret);
+                        return;
+                }
+
+                ret = gpio_direction_input(TEGRA_GPIO_PS0);
+                if (ret < 0) {
+                        pr_err("%s: gpio_direction_input failed %d\n", __func__, ret);
+                        gpio_free(TEGRA_GPIO_PS0);
+                        return;
+                }
+                tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_KB_ROW8, TEGRA_PUPD_NORMAL);
 
-	if(htc_get_pcbid_info() == PROJECT_PHASE_XA){
 		i2c_register_board_info(0, mpu3050_i2c0_boardinfo,
 					ARRAY_SIZE(mpu3050_i2c0_boardinfo));
 	}
 }
-static void enterprise_gyro_sleep_pin(void)
+static void endeavor_gyro_sleep_pin(void)
 {
 
 	int ret = 0;
@@ -659,13 +666,13 @@ static void enterprise_gyro_sleep_pin(void)
 
 }
 
-static struct i2c_board_info enterprise_i2c0_isl_board_info[] = {
+static struct i2c_board_info endeavor_i2c0_isl_board_info[] = {
 	{
 		I2C_BOARD_INFO("isl29028", 0x44),
 	}
 };
 
-static void enterprise_comp_irq_init(void)
+static void endeavor_comp_irq_init(void)
 {
 	int ret = 0;
 
@@ -688,638 +695,25 @@ static void enterprise_comp_irq_init(void)
 	gpio_free(TEGRA_GPIO_PJ2);
 }
 
-static void enterprise_isl_init(void)
+static void endeavor_isl_init(void)
 {
-	i2c_register_board_info(0, enterprise_i2c0_isl_board_info,
-				ARRAY_SIZE(enterprise_i2c0_isl_board_info));
+	i2c_register_board_info(0, endeavor_i2c0_isl_board_info,
+				ARRAY_SIZE(endeavor_i2c0_isl_board_info));
 }
 
-static int endeavor_s5k3h2y_power_state = 0;
-static int endeavor_s5k3h2y_get_power(void)
-{
-	return endeavor_s5k3h2y_power_state;
-}
-
-static int endeavor_s5k3h2y_power_on(void)
-{
-    int ret;
-
-    pr_info("[CAM] s5k3h2y power on ++\n");
-
-	if (endeavor_s5k3h2y_power_state)
-		return 0;
-
-	tegra_gpio_disable(RAW_SPI_CLK);
-	tegra_gpio_disable(RAW_SPI_CS);
-	tegra_gpio_disable(RAW_SPI_DI);
-	tegra_gpio_disable(RAW_SPI_DO);
-	//tegra_gpio_disable(RAW_INTR0);
-	//tegra_gpio_disable(RAW_INTR1);
-	tegra_gpio_disable(CAM_I2C_SCL_GPIO);
-	tegra_gpio_disable(CAM_I2C_SDA_GPIO);
-	tegra_gpio_disable(CAM_MCLK_GPIO);
-
-    gpio_direction_output(CAM_PWDN, 0);
-    gpio_direction_output(CAM1_VCM_PD_GPIO, 0);
-    #if RAWCHIP
-    gpio_direction_output(RAW_RSTN, 0);
-    #endif
-    //ENR_msleep(1); //TODO
-
-#ifdef CAMERA_REGULATOR
-    //pr_info("[CAM] use regurator to get power\n");
-
-	#if RAWCHIP
-	/*RAW_1V8_EN */
-	gpio_direction_output(RAW_1V8_EN, 1);
-	ENR_usleep(200);
-	#endif
-
-	/* VCM */
-	ret = regulator_enable(cam_vcm_2v85_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator v_cam1_vcm_2v85\n");
-		regulator_put(cam_vcm_2v85_en);
-		cam_vcm_2v85_en = NULL;
-		return ret;
-	}
-
-    /* main/front cam analog*/
-	ret = regulator_enable(cam_a2v85_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator cam_a2v85_en\n");
-		regulator_put(cam_a2v85_en);
-		cam_a2v85_en = NULL;
-		return ret;
-	}
-    ENR_usleep(200);
- 
-    /*main cam core 1v2 & rawchip external 1v2 */
-	ret = regulator_enable(cam_d1v2_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator cam_d1v2_en\n");
-		regulator_put(cam_d1v2_en);
-		cam_d1v2_en = NULL;
-		return ret;
-	}
-	ENR_usleep(200);
- 
-	#if RAWCHIP
-	/*RAW_1V2_EN */
-    if (htc_get_pcbid_info() < PROJECT_PHASE_XE) {
-        gpio_direction_output(RAW_1V2_EN, 1);
-	    ENR_usleep(200);
-    }
-	#endif
-
-    /* IO */
-	ret = regulator_enable(cam_vddio_1v8_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator cam_vddio_1v8_en\n");
-		regulator_put(cam_vddio_1v8_en);
-		cam_vddio_1v8_en = NULL;
-		return ret;
-	}
-    ENR_usleep(100);
-
-    /*CAM SEL */
-    gpio_direction_output(CAM_SEL_GPIO, 0);
-    ENR_usleep(100);
-
-    #if RAWCHIP
-    /*RAW_RSTN */
-    gpio_direction_output(RAW_RSTN, 1);
-    ENR_msleep(3);
-    /*SPI send command to configure RAWCHIP here!*/
-	yushan_spi_write(0x0008, 0x7f);
-	ENR_msleep(1);
-    #endif
-
-    /* XSHUTDOWM */
-    gpio_direction_output(CAM_PWDN, 1);
-    ENR_usleep(100);
-
-     /* VCM PD*/
-    gpio_direction_output(CAM1_VCM_PD_GPIO, 1);
-    ENR_usleep(100);
-
-#else/* use gpio pull up to get power*/
-      #if RAWCHIP
-	/*RAW_1V8_EN */
-	gpio_direction_output(RAW_1V8_EN, 1);
-	ENR_usleep(200);
-      #endif
-
-	/* VCM */
-	gpio_direction_output(CAM_VCM2V85, 1);
-	ENR_usleep(200);
-
-	/* analog */
-	gpio_direction_output(CAM_A2V85_EN, 1);
-	ENR_usleep(200);
-
-	/*core*/
-	gpio_direction_output(CAM_D1V2_EN, 1);
-	ENR_usleep(200);
-
-	#if RAWCHIP
-	/*RAW_1V2_EN */
-    if (htc_get_pcbid_info() < PROJECT_PHASE_XE) {
-	    ret = gpio_direction_output(RAW_1V2_EN, 1);
-	    ENR_usleep(200);
-    }
-    #endif
-
-	/* IO */
-	gpio_direction_output(CAMIO_1V8_EN, 1);
-	ENR_usleep(100);
-
-	/*CAM SEL */
-	gpio_direction_output(CAM_SEL_GPIO, 0);
-	ENR_usleep(100);
-
-      #if RAWCHIP
-	/*RAW_RSTN */
-	ret = gpio_direction_output(RAW_RSTN, 1);
-	ENR_msleep(3);
-
-      /*SPI send command to configure RAWCHIP here!*/
-	  yushan_spi_write(0x0008, 0x7f);
-		ENR_msleep(1);
-      #endif
-
-	/* XSHUTDOWM */
-	gpio_direction_output(CAM_PWDN, 1);
-	ENR_usleep(100);
-	/* VCM PD*/
-	gpio_direction_output(CAM1_VCM_PD_GPIO, 1);
-	ENR_usleep(100);
-#endif
-	endeavor_s5k3h2y_power_state = 1;
-    //pr_info("[CAM] s5k3h2y power on --\n");
-    return 0;
-}
-
-static int endeavor_s5k3h2y_power_off(void)
-{
-    pr_info("[CAM] s5k3h2y power off ++\n");
-    if (!endeavor_s5k3h2y_power_state)
-	return 0;
-    endeavor_s5k3h2y_power_state = 0;
-#ifdef CAMERA_REGULATOR
-    /* VCM PD*/
-    gpio_direction_output(CAM1_VCM_PD_GPIO, 0);
-    ENR_msleep(1);
-
-    /* XSHUTDOWN */
-    gpio_direction_output(CAM_PWDN, 0);
-    ENR_msleep(1);
-
-    #if RAWCHIP
-    /* RAW RSTN*/
-    gpio_direction_output(RAW_RSTN, 0);
-    ENR_msleep(3);
-    #endif
-
-   /* VCM */
-   regulator_disable(cam_vcm_2v85_en);
-   ENR_msleep(1);
-
-    #if RAWCHIP
-    /*RAW_1V2_EN */
-    if (htc_get_pcbid_info() < PROJECT_PHASE_XE) {
-        gpio_direction_output(RAW_1V2_EN, 0);
-        ENR_msleep(5);
-    }
-    #endif
-
-   /* digital */
-   regulator_disable(cam_d1v2_en);
-   ENR_msleep(1);
-
-   #if RAWCHIP
-   /*RAW_1V8_EN */
-   gpio_direction_output(RAW_1V8_EN, 0);
-   ENR_msleep(1);
-   #endif
-
-   /* analog */
-   regulator_disable(cam_a2v85_en);
-   ENR_msleep(5);
-   /* IO */
-   regulator_disable(cam_vddio_1v8_en);
-   ENR_msleep(10);
-
-#else/* use gpio pull down to disable power */
-    /* VCM PD*/
-    gpio_direction_output(CAM1_VCM_PD_GPIO, 0);
-    ENR_msleep(1);
-    /* TODO: Set 0x0100[0] = 0 (Enter SW Standby mode)*/
-
-    /* XSHUTDOWN */
-    gpio_direction_output(CAM_PWDN, 0);
-    ENR_msleep(1);
-
-    #if RAWCHIP
-    /* RAW RSTN*/
-    gpio_direction_output(RAW_RSTN, 0);
-    ENR_msleep(3);
-    #endif
-
-    /* VCM */
-    gpio_direction_output(CAM_VCM2V85, 0);
-    ENR_msleep(1);
-
-    #if RAWCHIP
-    /*RAW_1V2_EN */
-    if (htc_get_pcbid_info() < PROJECT_PHASE_XE) {
-        gpio_direction_output(RAW_1V2_EN, 0);
-        ENR_msleep(5);
-    }
-    #endif
-
-    /* digital */
-    gpio_direction_output(CAM_D1V2_EN, 0);
-	ENR_msleep(1);
-
-   #if RAWCHIP
-   /*RAW_1V8_EN */
-   gpio_direction_output(RAW_1V8_EN, 0);
-   ENR_msleep(1);
-   #endif
-
-    /* analog */
-    gpio_direction_output(CAM_A2V85_EN, 0);
-	ENR_msleep(5);
-    /* IO */
-    gpio_direction_output(CAMIO_1V8_EN, 0);
-    ENR_msleep(10);
-#endif
-
-	/* set gpio output low : O(L) */
-	tegra_gpio_enable(RAW_SPI_CLK);
-	tegra_gpio_enable(RAW_SPI_CS);
-	tegra_gpio_enable(RAW_SPI_DI);
-	tegra_gpio_enable(RAW_SPI_DO);
-	//tegra_gpio_enable(RAW_INTR0);
-	//tegra_gpio_enable(RAW_INTR1);
-	tegra_gpio_enable(CAM_I2C_SCL_GPIO);
-	tegra_gpio_enable(CAM_I2C_SDA_GPIO);
-	tegra_gpio_enable(CAM_MCLK_GPIO);
-
-    return 0;
-}
-
-struct s5k3h2y_platform_data endeavor_s5k3h2y_data = {
-	.get_power_state = endeavor_s5k3h2y_get_power,
-	.power_on = endeavor_s5k3h2y_power_on,
-	.power_off = endeavor_s5k3h2y_power_off,
-};
-
-struct ad5823_platform_data endeavor_ad5823_data = {
-	.get_power_state = endeavor_s5k3h2y_get_power,
-};
-
-static int endeavor_s5k6a1gx03_power_on(void)
-{
-    int ret;
-    pr_info("[CAM] s5k6a1g power on ++\n");
-    gpio_direction_output(FRONT_CAM_RST_GPIO, 0);
-    gpio_direction_output(CAM_SEL_GPIO, 0);
-
-	tegra_gpio_disable(CAM_I2C_SCL_GPIO);
-	tegra_gpio_disable(CAM_I2C_SDA_GPIO);
-	tegra_gpio_disable(CAM_MCLK_GPIO);
-
-#ifdef CAMERA_REGULATOR
-    pr_info("[CAM] use regurator to get power\n");
-    /* analog */
-	ret = regulator_enable(cam_a2v85_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator cam_a2v85_en\n");
-		regulator_put(cam_a2v85_en);
-		cam_a2v85_en = NULL;
-		return ret;
-	}
-    ENR_usleep(200);
-    /*vcm*/
-	ret = regulator_enable(cam_vcm_2v85_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator cam_vcm_2v85_en\n");
-		regulator_put(cam_vcm_2v85_en);
-		cam_vcm_2v85_en = NULL;
-		return ret;
-	}
-    ENR_usleep(200);
-    /*IO*/
-	ret = regulator_enable(cam_vddio_1v8_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator cam_vddio_1v8_en\n");
-		regulator_put(cam_vddio_1v8_en);
-		cam_vddio_1v8_en = NULL;
-		return ret;
-	}
-    ENR_usleep(200);
-    /*RSTN */
-    gpio_direction_output(FRONT_CAM_RST_GPIO, 1);
-    /* digital */
-	ret = regulator_enable(cam2_d1v2_en);
-	if (ret < 0) {
-		pr_err("[CAM] couldn't enable regulator cam_d1v2_en\n");
-		regulator_put(cam_d1v2_en);
-		cam_d1v2_en = NULL;
-		return ret;
-	}
-    /*CAM SEL */
-    gpio_direction_output(CAM_SEL_GPIO, 1);
-    ENR_msleep(1);
-#else /* use gpio pull up to get power */
-    /* vcm */
-    gpio_direction_output(CAM_VCM2V85, 1);
-    ENR_usleep(200);
-    /* analog */
-    gpio_direction_output(CAM_A2V85_EN, 1);
-    ENR_usleep(200);
-    /*IO*/
-    gpio_direction_output(CAMIO_1V8_EN, 1);
-    ENR_usleep(200);
-    /*RSTN */
-    gpio_direction_output(FRONT_CAM_RST_GPIO, 1);
-    /* digital */
-    gpio_direction_output(CAM2_D1V2_EN, 1);
-    /*CAM SEL */
-    gpio_direction_output(CAM_SEL_GPIO, 1);
-    ENR_msleep(1);
-#endif
-    return 0;
-}
-
-static int endeavor_s5k6a1gx03_power_off(void)
-{
-    pr_info("[CAM] s5k6a1g power off ++\n");
-#ifdef CAMERA_REGULATOR
-    /*CAM SEL */
-    gpio_direction_output(CAM_SEL_GPIO, 0);
-    ENR_msleep(1);
-    /* vcm */
-    regulator_disable(cam_vcm_2v85_en);
-    ENR_msleep(1);
-    /* analog */
-    regulator_disable(cam_a2v85_en);
-    ENR_msleep(5);
-    /*RSTN */
-    gpio_direction_output(FRONT_CAM_RST_GPIO, 0);
-    /* digital */
-    regulator_disable(cam2_d1v2_en);
-    ENR_msleep(1);
-      /* IO */
-    regulator_disable(cam_vddio_1v8_en);
-    ENR_msleep(10);
-
-#else/* use gpio pull down to disable power*/
-    /*CAM SEL */
-    gpio_direction_output(CAM_SEL_GPIO, 0);
-    ENR_msleep(1);
-    /* vcm */
-    gpio_direction_output(CAM_VCM2V85, 0);
-    ENR_msleep(5);
-    /* analog */
-    gpio_direction_output(CAM_A2V85_EN, 0);
-    ENR_msleep(5);
-    /*RSTN */
-    gpio_direction_output(FRONT_CAM_RST_GPIO, 0);
-    /* digital */
-    gpio_direction_output(CAM2_D1V2_EN, 0);
-    ENR_msleep(1);
-      /* IO */
-    gpio_direction_output(CAMIO_1V8_EN, 0);
-    ENR_msleep(10);
-#endif
-
-	tegra_gpio_enable(CAM_I2C_SCL_GPIO);
-	tegra_gpio_enable(CAM_I2C_SDA_GPIO);
-	tegra_gpio_enable(CAM_MCLK_GPIO);
-
-    return 0;
-}
-
-struct s5k6a1gx03_platform_data endeavor_s5k6a1gx03_data = {
-	.power_on = endeavor_s5k6a1gx03_power_on,
-	.power_off = endeavor_s5k6a1gx03_power_off,
-};
-
-static struct i2c_board_info endeavor_i2c3_board_info[] = {
-	{
-		I2C_BOARD_INFO("s5k3h2y", 0x10),
-		.platform_data = &endeavor_s5k3h2y_data,
-	},
-	{
-		I2C_BOARD_INFO("ad5823", 0x0C),
-		.platform_data = &endeavor_ad5823_data,
-	}
-};
-
-static struct i2c_board_info endeavor_i2c4_board_info[] = {
-	{
-		I2C_BOARD_INFO("s5k6a1gx03", 0x36),
-		.platform_data = &endeavor_s5k6a1gx03_data,
-	},
-};
-
-struct endeavor_cam_gpio {
-	int gpio;
-	const char *label;
-	int value;
-};
-
-/*static struct tps61050_pin_state enterprise_tps61050_pinstate = {
-	.mask		= 0x0008,*/ /*VGP3*/
-/*	.values		= 0x0008,
-};*/
-
-/* I2C bus becomes active when vdd_1v8_cam is enabled */
-/*static int enterprise_tps61050_pm(int pwr)
-{
-	static struct regulator *enterprise_flash_reg = NULL;
-	int ret = 0;
-
-	pr_info("%s: ++%d\n", __func__, pwr);
-	switch (pwr) {
-	case TPS61050_PWR_OFF:
-		if (enterprise_flash_reg)
-			regulator_disable(enterprise_flash_reg);
-		break;
-	case TPS61050_PWR_STDBY:
-	case TPS61050_PWR_COMM:
-	case TPS61050_PWR_ON:
-		if (!enterprise_flash_reg) {
-			enterprise_flash_reg = regulator_get(NULL, "vdd_1v8_cam");
-			if (IS_ERR_OR_NULL(enterprise_flash_reg)) {
-				pr_err("%s: failed to get flash pwr\n", __func__);
-				return PTR_ERR(enterprise_flash_reg);
-			}
-		}
-		ret = regulator_enable(enterprise_flash_reg);
-		if (ret) {
-			pr_err("%s: failed to enable flash pwr\n", __func__);
-			goto fail_regulator_flash_reg;
-		}
-		ENR_msleep(1);
-		break;
-	default:
-		ret = -1;
-	}
-	return ret;
-
-fail_regulator_flash_reg:
-	regulator_put(enterprise_flash_reg);
-	enterprise_flash_reg = NULL;
-	return ret;
-}*/
-
-#define TEGRA_CAMERA_GPIO(_gpio, _label, _value)	\
-	{						\
-		.gpio = _gpio,				\
-		.label = _label,			\
-		.value = _value,			\
-	}
-#ifndef CAMERA_REGULATOR
-static struct endeavor_cam_gpio endeavor_cam_gpio_output_data[] = {
-	[0] = TEGRA_CAMERA_GPIO(CAM_SEL_GPIO, "cam_sel_gpio", 0),
-	[1] = TEGRA_CAMERA_GPIO(FRONT_CAM_RST_GPIO, "front_cam_rst_gpio", 0),
-	[2] = TEGRA_CAMERA_GPIO(CAM_A2V85_EN, "cam_a2v85_en", 0),
-	[3] = TEGRA_CAMERA_GPIO(CAM_PWDN, "cam_pwdn", 0),
-	[4] = TEGRA_CAMERA_GPIO(CAM_D1V2_EN, "cam_d1v2_en", 0),
-	[5] = TEGRA_CAMERA_GPIO(CAM2_D1V2_EN, "cam2_d1v2_en", 0),
-	[6] = TEGRA_CAMERA_GPIO(CAM_VCM2V85, "cam_vcm2v85", 0),
-	[7] = TEGRA_CAMERA_GPIO(CAMIO_1V8_EN, "camio_1v8_en", 0),
-	[8] = TEGRA_CAMERA_GPIO(CAM1_VCM_PD_GPIO, "cam1_vcm_pd", 0),
-	[9] = TEGRA_CAMERA_GPIO(CAM_I2C_SCL_GPIO, "CAM_I2C_SCL_GPIO", 0),
-	[10] = TEGRA_CAMERA_GPIO(CAM_I2C_SDA_GPIO, "CAM_I2C_SDA_GPIO", 0),
-	[11] = TEGRA_CAMERA_GPIO(CAM_MCLK_GPIO, "CAM_MCLK_GPIO", 0),
-	/*for rawchip */
-	[12] = TEGRA_CAMERA_GPIO(RAW_1V8_EN, "RAW_1V8_EN", 0),
-	[13] = TEGRA_CAMERA_GPIO(RAW_1V2_EN, "RAW_1V2_EN", 0),
-	[14] = TEGRA_CAMERA_GPIO(RAW_RSTN, "RAW_RSTN", 0),
-	[15] = TEGRA_CAMERA_GPIO(RAW_SPI_CLK, "RAW_SPI_CLK", 0),
-	[16] = TEGRA_CAMERA_GPIO(RAW_SPI_CS, "RAW_SPI_CS", 0),
-	[17] = TEGRA_CAMERA_GPIO(RAW_SPI_DI, "RAW_SPI_DI", 0),
-	[18] = TEGRA_CAMERA_GPIO(RAW_SPI_DO, "RAW_SPI_DO", 0),
-};
-#else
-static struct endeavor_cam_gpio endeavor_cam_gpio_output_data[] = {
-	[0] = TEGRA_CAMERA_GPIO(CAM_SEL_GPIO, "cam_sel_gpio", 0),
-	[1] = TEGRA_CAMERA_GPIO(FRONT_CAM_RST_GPIO, "front_cam_rst_gpio", 0),
-	[2] = TEGRA_CAMERA_GPIO(CAM_PWDN, "cam_pwdn", 0),
-	[3] = TEGRA_CAMERA_GPIO(CAM1_VCM_PD_GPIO, "cam1_vcm_pd", 0),
-	[4] = TEGRA_CAMERA_GPIO(CAM_I2C_SCL_GPIO, "CAM_I2C_SCL_GPIO", 0),
-	[5] = TEGRA_CAMERA_GPIO(CAM_I2C_SDA_GPIO, "CAM_I2C_SDA_GPIO", 0),
-	[6] = TEGRA_CAMERA_GPIO(CAM_MCLK_GPIO, "CAM_MCLK_GPIO", 0),
-	/*for rawchip */
-	[7] = TEGRA_CAMERA_GPIO(RAW_1V8_EN, "RAW_1V8_EN", 0),
-	[8] = TEGRA_CAMERA_GPIO(RAW_1V2_EN, "RAW_1V2_EN", 0),
-	[9] = TEGRA_CAMERA_GPIO(RAW_RSTN, "RAW_RSTN", 0),
-	[10] = TEGRA_CAMERA_GPIO(RAW_SPI_CLK, "RAW_SPI_CLK", 0),
-	[11] = TEGRA_CAMERA_GPIO(RAW_SPI_CS, "RAW_SPI_CS", 0),
-	[12] = TEGRA_CAMERA_GPIO(RAW_SPI_DI, "RAW_SPI_DI", 0),
-	[13] = TEGRA_CAMERA_GPIO(RAW_SPI_DO, "RAW_SPI_DO", 0),
-};
-#endif
-static struct endeavor_cam_gpio endeavor_cam_gpio_input_data[] = {
-	[0] = TEGRA_CAMERA_GPIO(CAM1_ID_GPIO, "cam1_id_gpio", 0),
-	[1] = TEGRA_CAMERA_GPIO(FRONT_CAM_ID_GPIO, "front_cam_id_gpio", 0),
-	[2] = TEGRA_CAMERA_GPIO(RAW_INTR0, "RAW_INTR0", 0),
-	[3] = TEGRA_CAMERA_GPIO(RAW_INTR1, "RAW_INTR1", 0),
-};
-
-static struct pca954x_platform_mode enterprise_pca954x_modes[] = {
+static struct pca954x_platform_mode endeavor_pca954x_modes[] = {
 	{ .adap_id = PCA954x_I2C_BUS0, .deselect_on_exit = true, },
 	{ .adap_id = PCA954x_I2C_BUS1, .deselect_on_exit = true, },
 	{ .adap_id = PCA954x_I2C_BUS2, .deselect_on_exit = true, },
 	{ .adap_id = PCA954x_I2C_BUS3, .deselect_on_exit = true, },
 };
 
-static struct pca954x_platform_data enterprise_pca954x_data = {
-	.modes    = enterprise_pca954x_modes,
-	.num_modes      = ARRAY_SIZE(enterprise_pca954x_modes),
+static struct pca954x_platform_data endeavor_pca954x_data = {
+	.modes    = endeavor_pca954x_modes,
+	.num_modes      = ARRAY_SIZE(endeavor_pca954x_modes),
 };
 
-	
-/*
-static struct tps61050_platform_data enterprise_tps61050_data = {
-	.cfg		= 0,
-	.num		= 1,
-	.max_amp_torch	= CAM_FLASH_MAX_TORCH_AMP,
-	.max_amp_flash	= CAM_FLASH_MAX_FLASH_AMP,
-	.pinstate	= &enterprise_tps61050_pinstate,
-	.init		= NULL,
-	.exit		= NULL,
-	.pm		= &enterprise_tps61050_pm,
-	.gpio_envm	= NULL,
-	.gpio_sync	= NULL,
-};
-*/
-
-static int endeavor_cam_init(void)
-{
-    int ret;
-    int i = 0, j = 0;
-
-    for (i = 0; i < ARRAY_SIZE(endeavor_cam_gpio_output_data); i++) {
-        /* for XE, raw_1v2_en is removed */
-        if (htc_get_pcbid_info() >= PROJECT_PHASE_XE && endeavor_cam_gpio_output_data[i].gpio == RAW_1V2_EN) {
-            continue;
-        }
-        ret = gpio_request(endeavor_cam_gpio_output_data[i].gpio,
-                   endeavor_cam_gpio_output_data[i].label);
-        if (ret < 0) {
-            pr_err("[CAM] %s: gpio_request failed for gpio #%d\n",
-                __func__, i);
-            goto fail_free_gpio;
-        }
-        gpio_direction_output(endeavor_cam_gpio_output_data[i].gpio,
-                      endeavor_cam_gpio_output_data[i].value);
-        gpio_export(endeavor_cam_gpio_output_data[i].gpio, false);
-        tegra_gpio_enable(endeavor_cam_gpio_output_data[i].gpio);
-    }
-
-    for (j = 0; j < ARRAY_SIZE(endeavor_cam_gpio_input_data); j++) {
-        ret = gpio_request(endeavor_cam_gpio_input_data[j].gpio,
-                   endeavor_cam_gpio_input_data[j].label);
-        if (ret < 0) {
-            pr_err("[CAM] %s: gpio_request failed for gpio #%d\n",
-                __func__, j);
-            goto fail_free_gpio;
-        }
-        gpio_direction_input(endeavor_cam_gpio_input_data[j].gpio);
-        gpio_export(endeavor_cam_gpio_input_data[j].gpio, false);
-        tegra_gpio_enable(endeavor_cam_gpio_input_data[j].gpio);
-    }
-/* set gpio input no pull: I(NP) */
-    tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_KB_ROW6, TEGRA_PUPD_NORMAL);/* CAM1_ID_GPIO */
-    tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_KB_ROW0, TEGRA_PUPD_NORMAL);/* RAW_INTR0 */
-    tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_CLK3_REQ, TEGRA_PUPD_NORMAL);/* RAW_INTR1 */
-/* set gpio input no pull: I(PU) */
-    tegra_pinmux_set_pullupdown(TEGRA_PINGROUP_KB_ROW7, TEGRA_PUPD_PULL_UP);/* FRONT_CAM_ID_GPIO */
-
-    i2c_register_board_info(2, endeavor_i2c3_board_info,
-        ARRAY_SIZE(endeavor_i2c3_board_info));
-
-    i2c_register_board_info(2, endeavor_i2c4_board_info,
-        ARRAY_SIZE(endeavor_i2c4_board_info));
-
-    return 0;
-
-fail_free_gpio:
-    pr_err("[CAM] %s endeavor_cam_init failed!\n", __func__);
-    while (i--)
-        gpio_free(endeavor_cam_gpio_output_data[i].gpio);
-    while (j--)
-        gpio_free(endeavor_cam_gpio_input_data[j].gpio);
-    return ret;
-}
-
-struct enterprise_battery_gpio {
+struct endeavor_battery_gpio {
 	int gpio;
 	const char *label;
 };
@@ -1330,7 +724,7 @@ struct enterprise_battery_gpio {
 		.label = _label,		\
 	}
 
-struct enterprise_battery_gpio enterprise_battery_gpio_data[] ={
+struct endeavor_battery_gpio endeavor_battery_gpio_data[] ={
 	[0] = TEGRA_BATTERY_GPIO(TEGRA_GPIO_PU4, "mbat_in"),
 	[1] = TEGRA_BATTERY_GPIO(TEGRA_GPIO_PW0, "chg_stat"),
 	[2] = TEGRA_BATTERY_GPIO(TEGRA_GPIO_PX5, "chg_int"),
@@ -1377,31 +771,31 @@ static int __init check_mbat_in_tag(char *get_mbat_in)
 __setup("mbat_in_check=", check_mbat_in_tag);
 #endif
 
-static void enterprise_battery_init(void)
+static void endeavor_battery_init(void)
 {
 	int ret;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(enterprise_battery_gpio_data); i++) {
-		ret = gpio_request(enterprise_battery_gpio_data[i].gpio,
-				   enterprise_battery_gpio_data[i].label);
+	for (i = 0; i < ARRAY_SIZE(endeavor_battery_gpio_data); i++) {
+		ret = gpio_request(endeavor_battery_gpio_data[i].gpio,
+				   endeavor_battery_gpio_data[i].label);
 		if (ret < 0) {
 			pr_err("%s: gpio_request failed for gpio #%d\n",
 				__func__, i);
 			goto bat_fail_free_gpio;
 		}
 
-		ret = gpio_direction_input(enterprise_battery_gpio_data[i].gpio);
+		ret = gpio_direction_input(endeavor_battery_gpio_data[i].gpio);
 		if (ret < 0) {
 			pr_err("%s: gpio_direction_input failed for gpio #%d\n",
 				__func__, i);
 			goto bat_fail_free_gpio;
 		}
 
-		tegra_gpio_enable(enterprise_battery_gpio_data[i].gpio);
+		tegra_gpio_enable(endeavor_battery_gpio_data[i].gpio);
 	}
 
-	if(htc_get_pcbid_info() <= PROJECT_PHASE_XC)
+	if(machine_is_endeavoru() && htc_get_pcbid_info() <= PROJECT_PHASE_XC)
 		htc_battery_pdev_data.volt_adc_offset = -17;
 
 	platform_device_register(&htc_battery_pdev);
@@ -1412,14 +806,14 @@ static void enterprise_battery_init(void)
 	return;
 
 bat_fail_free_gpio:
-	pr_err("%s enterprise_battery_init failed!\n", __func__);
+	pr_err("%s endeavor_battery_init failed!\n", __func__);
 	while (i--)
-		gpio_free(enterprise_battery_gpio_data[i].gpio);
+		gpio_free(endeavor_battery_gpio_data[i].gpio);
 }
 
-#define ENTERPRISE_INA230_ENABLED 0
+#define ENDEAVOR_INA230_ENABLED 0
 
-#if ENTERPRISE_INA230_ENABLED
+#if ENDEAVOR_INA230_ENABLED
 static struct ina230_platform_data ina230_platform = {
 	.rail_name = "VDD_AC_BAT",
 	.current_threshold = TEGRA_CUR_MON_THRESHOLD,
@@ -1427,7 +821,7 @@ static struct ina230_platform_data ina230_platform = {
 	.min_cores_online = TEGRA_CUR_MON_MIN_CORES,
 };
 
-static struct i2c_board_info enterprise_i2c0_ina230_info[] = {
+static struct i2c_board_info endeavor_i2c0_ina230_info[] = {
 	{
 		I2C_BOARD_INFO("ina230", 0x42),
 		.platform_data = &ina230_platform,
@@ -1435,28 +829,27 @@ static struct i2c_board_info enterprise_i2c0_ina230_info[] = {
 	},
 };
 
-static int __init enterprise_ina230_init(void)
+static int __init endeavor_ina230_init(void)
 {
-	return i2c_register_board_info(0, enterprise_i2c0_ina230_info,
-				       ARRAY_SIZE(enterprise_i2c0_ina230_info));
+	return i2c_register_board_info(0, endeavor_i2c0_ina230_info,
+				       ARRAY_SIZE(endeavor_i2c0_ina230_info));
 }
 #endif
 
-int __init enterprise_sensors_init(void)
+int __init endeavor_sensors_init(void)
 {
 	psensor_init();
-	
-	int ret;
-	if (htc_get_pcbid_info() == PROJECT_PHASE_XA){
+
+	int ret = 0;
+        if(machine_is_erau()){
 		pr_info("[GYRO]Use Invensense solution");
-		enterprise_mpuirq_init();
 	}
-	enterprise_comp_irq_init();
-	//enterprise_srio_1v8_en();
-	enterprise_gsensor_irq_init(); 
-	if (htc_get_pcbid_info() != PROJECT_PHASE_XA ){
-		enterprise_mpuirq_init();
-		enterprise_gyro_diag_init();
+
+	endeavor_comp_irq_init();
+	endeavor_gsensor_irq_init(); 
+	endeavor_mpuirq_init();
+	if(machine_is_endeavoru()){
+		endeavor_gyro_diag_init();
 		i2c_register_board_info(0,
 			pana_gyro_GSBI12_boardinfo, ARRAY_SIZE(pana_gyro_GSBI12_boardinfo));
 		i2c_register_board_info(0,
@@ -1464,73 +857,22 @@ int __init enterprise_sensors_init(void)
 		if (htc_get_pcbid_info() < PROJECT_PHASE_XC )
 			i2c_register_board_info(0,
 				i2c_akm8975_devices_xb, ARRAY_SIZE(i2c_akm8975_devices_xb));
+
 		else
 			i2c_register_board_info(0,
 				i2c_akm8975_devices_xc, ARRAY_SIZE(i2c_akm8975_devices_xc));
 	
-		enterprise_gyro_sleep_pin();
+		endeavor_gyro_sleep_pin();
 	}
 
 #if 0	/* fixme: require owner to check these */
-	enterprise_isl_init();
+	endeavor_isl_init();
 #endif
-	enterprise_battery_init();
-	ret = endeavor_cam_init();
-	enterprise_nct1008_init();
-#if ENTERPRISE_INA230_ENABLED
-	enterprise_ina230_init();
+	endeavor_battery_init();
+	endeavor_nct1008_init();
+#if ENDEAVOR_INA230_ENABLED
+	endeavor_ina230_init();
 #endif
 	edge_nfc_init();
 	return ret;
 }
-
-int __init endeavor_cam_late_init(void)
-{
-	int ret = 0;
-	printk("%s: \n", __func__);
-/* vcm */
-      cam_vcm_2v85_en = regulator_get(NULL, "v_cam_vcm_2v85");
-		if (IS_ERR_OR_NULL(cam_vcm_2v85_en)) {
-			ret = PTR_ERR(cam_vcm_2v85_en);
-			pr_err("[CAM] couldn't get regulator v_cam_vcm_2v85\n");
-			cam_vcm_2v85_en = NULL;
-			return ret;
-		}
-/* io */
-      cam_vddio_1v8_en = regulator_get(NULL, "v_camio_1v8");
-		if (IS_ERR_OR_NULL(cam_vddio_1v8_en)) {
-			ret = PTR_ERR(cam_vddio_1v8_en);
-			pr_err("[CAM] couldn't get regulator v_camio_1v8\n");
-			cam_vddio_1v8_en = NULL;
-			return ret;
-		}
-/* analog */
-      cam_a2v85_en = regulator_get(NULL, "v_cam_a2v85");
-		if (IS_ERR_OR_NULL(cam_a2v85_en)) {
-			ret = PTR_ERR(cam_a2v85_en);
-			pr_err("[CAM] couldn't get regulator v_cam_a2v85\n");
-			cam_a2v85_en = NULL;
-			return ret;
-		}
-/* cam_d1v2 */
-      cam_d1v2_en = regulator_get(NULL, "v_cam_d1v2");
-		if (IS_ERR_OR_NULL(cam_d1v2_en)) {
-			ret = PTR_ERR(cam_d1v2_en);
-			pr_err("[CAM] couldn't get regulator v_cam_d1v2\n");
-			cam_d1v2_en = NULL;
-			return ret;
-		}
-/* cam2_d1v2 */
-      cam2_d1v2_en = regulator_get(NULL, "v_cam2_d1v2");
-		if (IS_ERR_OR_NULL(cam2_d1v2_en)) {
-			ret = PTR_ERR(cam2_d1v2_en);
-			pr_err("[CAM] couldn't get regulator v_cam2_d1v2\n");
-			cam2_d1v2_en = NULL;
-			return ret;
-		}
-	return ret;
-}
-
-#ifdef CAMERA_REGULATOR
-late_initcall(endeavor_cam_late_init);
-#endif
diff --git a/arch/arm/mach-tegra/board-endeavoru.c b/arch/arm/mach-tegra/board-endeavoru.c
index 350ef92..4657aeb 100644
--- a/arch/arm/mach-tegra/board-endeavoru.c
+++ b/arch/arm/mach-tegra/board-endeavoru.c
@@ -316,13 +316,13 @@ static struct platform_device pm8xxx_haptic = {
 static struct platform_device *haptic_vibrator[] __initdata = {
 	&pm8xxx_haptic,
 };
-static void haptic_vibrator_init(int board_id)
+static void haptic_vibrator_init(void)
 {
-	if (board_id == PROJECT_PHASE_XA) {
+	if ( (htc_get_pcbid_info() == PROJECT_PHASE_XA) && machine_is_endeavoru()) {
 		haptic_data->ena_gpio = TEGRA_GPIO_PR3;
 		haptic_data->pwm_sfio = TEGRA_GPIO_PH0;
 	}
-	else if (board_id >= PROJECT_PHASE_XB) {
+	else {
 		haptic_data->ena_gpio = TEGRA_GPIO_PF1;
 		haptic_data->pwm_sfio = TEGRA_GPIO_PH0;
 	}
@@ -339,7 +339,6 @@ static struct vibrator_platform_data vibrator_data = {
 	},
 	.pwm_gpio = TEGRA_GPIO_PH0,
 	.ena_gpio = TEGRA_GPIO_PF1,
-	.pwr_gpio = TEGRA_GPIO_PE7,
 };
 static struct platform_device tegra_vibrator = {
 	.name= VIBRATOR_NAME,
@@ -408,7 +407,7 @@ static struct platform_device tegra_usb_fsg_device = {
 #endif
 
 //flashlight
-static void config_enterprise_flashlight_gpios(void)
+static void config_endeavor_flashlight_gpios(void)
 {
 	int ret;
 	printk("%s: start...", __func__);
@@ -442,26 +441,26 @@ static void config_enterprise_flashlight_gpios(void)
 	printk("%s: end...", __func__);
 }
 
-static struct flashlight_platform_data enterprise_flashlight_data = {
-	.gpio_init  = config_enterprise_flashlight_gpios,
+static struct flashlight_platform_data endeavor_flashlight_data = {
+	.gpio_init  = config_endeavor_flashlight_gpios,
 	.torch = FL_TORCH_EN,
 	.flash = FL_FLASH_EN,
 	.flash_duration_ms = 600
 };
 
-static struct platform_device enterprise_flashlight_device = {
+static struct platform_device endeavor_flashlight_device = {
 	.name = FLASHLIGHT_NAME,
 	.dev		= {
-		.platform_data	= &enterprise_flashlight_data,
+		.platform_data	= &endeavor_flashlight_data,
 	},
 };
 
-static void enterprise_flashlight_init(void)
+static void endeavor_flashlight_init(void)
 {
-	platform_device_register(&enterprise_flashlight_device);
+	platform_device_register(&endeavor_flashlight_device);
 }
 
-/* !!!TODO: Change for enterprise (Taken from Cardhu) */
+/* !!!TODO: Change for endeavoru (Taken from Cardhu) */
 static struct tegra_utmip_config utmi_phy_config[] = {
 	[0] = {
 			.hssync_start_delay = 0,
@@ -498,7 +497,7 @@ static struct tegra_utmip_config utmi_phy_config[] = {
 	},
 };
 
-static struct resource enterprise_bcm4329_rfkill_resources[] = {
+static struct resource endeavor_bcm4329_rfkill_resources[] = {
 	{
 		.name   = "bcm4329_nshutdown_gpio",
 		.start  = TEGRA_GPIO_PE6,
@@ -507,11 +506,11 @@ static struct resource enterprise_bcm4329_rfkill_resources[] = {
 	},
 };
 
-static struct platform_device enterprise_bcm4329_rfkill_device = {
+static struct platform_device endeavor_bcm4329_rfkill_device = {
 	.name = "bcm4329_rfkill",
 	.id		= -1,
-	.num_resources  = ARRAY_SIZE(enterprise_bcm4329_rfkill_resources),
-	.resource       = enterprise_bcm4329_rfkill_resources,
+	.num_resources  = ARRAY_SIZE(endeavor_bcm4329_rfkill_resources),
+	.resource       = endeavor_bcm4329_rfkill_resources,
 };
 
 static unsigned long retry_suspend;
@@ -573,7 +572,7 @@ static struct platform_device wl128x_device = {
         .dev.platform_data = &wilink_pdata,
 };
 
-static noinline void __init enterprise_bt_wl128x(void)
+static noinline void __init endeavor_bt_wl128x(void)
 {
 	wake_lock_init(&st_wk_lock, WAKE_LOCK_SUSPEND, "st_wake_lock");
 
@@ -585,7 +584,8 @@ static noinline void __init enterprise_bt_wl128x(void)
 }
 /* TI 128x Bluetooth end */
 
-static __initdata struct tegra_clk_init_table enterprise_clk_init_table[] = {
+
+static __initdata struct tegra_clk_init_table endeavor_clk_init_table[] = {
 	/* name		parent		rate		enabled */
 	{ "pll_m",	NULL,		0,		false},
 	{ "hda",	"pll_p",	108000000,	false},
@@ -695,7 +695,7 @@ static struct platform_device rndis_device = {
 };
 #endif
 
-static struct tegra_i2c_platform_data enterprise_i2c1_platform_data = {
+static struct tegra_i2c_platform_data endeavor_i2c1_platform_data = {
 	.adapter_nr	= 0,
 	.bus_count	= 1,
 	.bus_clk_rate	= { 384000, 0 },
@@ -704,7 +704,7 @@ static struct tegra_i2c_platform_data enterprise_i2c1_platform_data = {
 	.arb_recovery = arb_lost_recovery,
 };
 
-static struct tegra_i2c_platform_data enterprise_i2c2_platform_data = {
+static struct tegra_i2c_platform_data endeavor_i2c2_platform_data = {
 	.adapter_nr	= 1,
 	.bus_count	= 1,
 	.bus_clk_rate	= { 384000, 0 },
@@ -714,7 +714,7 @@ static struct tegra_i2c_platform_data enterprise_i2c2_platform_data = {
 	.arb_recovery = arb_lost_recovery,
 };
 
-static struct tegra_i2c_platform_data enterprise_i2c3_platform_data = {
+static struct tegra_i2c_platform_data endeavor_i2c3_platform_data = {
 	.adapter_nr	= 2,
 	.bus_count	= 1,
 	.bus_clk_rate	= { 384000, 0 },
@@ -723,7 +723,7 @@ static struct tegra_i2c_platform_data enterprise_i2c3_platform_data = {
 	.arb_recovery = arb_lost_recovery,
 };
 
-static struct tegra_i2c_platform_data enterprise_i2c4_platform_data = {
+static struct tegra_i2c_platform_data endeavor_i2c4_platform_data = {
 	.adapter_nr	= 3,
 	.bus_count	= 1,
 	.bus_clk_rate	= { 100000, 0 },
@@ -732,7 +732,7 @@ static struct tegra_i2c_platform_data enterprise_i2c4_platform_data = {
 	.arb_recovery = arb_lost_recovery,
 };
 
-static struct tegra_i2c_platform_data enterprise_i2c5_platform_data = {
+static struct tegra_i2c_platform_data endeavor_i2c5_platform_data = {
 	.adapter_nr	= 4,
 	.bus_count	= 1,
 	.bus_clk_rate	= { 100000, 0 },
@@ -759,7 +759,7 @@ static struct spi_board_info spi_board_info_audio[] __initdata = {
 	},
 };
 
-static struct platform_device enterprise_audio_device = {
+static struct platform_device endeavor_audio_device = {
 	.name	= "tegra-snd-aic3008",
 	.id	= 0,
 	.dev	= {
@@ -774,7 +774,7 @@ static struct tegra_spi_device_controller_data dev_cdata_rawchip = {
        .cs_setup_clk_count = 1, /* int cs_setup_clk_count */
        .cs_hold_clk_count = 2, /* int cs_hold_clk_count */
 };
-static struct spi_board_info enterprise_spi_board_info_rawchip[] __initdata = {
+static struct spi_board_info endeavor_spi_board_info_rawchip[] __initdata = {
        {
                .modalias       = "spi_rawchip",
                .mode           = SPI_MODE_0,
@@ -784,7 +784,7 @@ static struct spi_board_info enterprise_spi_board_info_rawchip[] __initdata = {
                .controller_data = &dev_cdata_rawchip,
        },
 };
-EXPORT_SYMBOL_GPL(enterprise_spi_board_info_rawchip);
+EXPORT_SYMBOL_GPL(endeavor_spi_board_info_rawchip);
 
 static struct tegra_camera_rawchip_info tegra_rawchip_board_info = {
 	.rawchip_intr0  = TEGRA_GPIO_PR0,
@@ -968,21 +968,58 @@ static struct platform_device *headset_devices_xe[] = {
 	/* Please put the headset detection driver on the last */
 };
 
+static struct headset_1wire_config htc_headset_mgr_1wire_config[] = {
+	{
+		.type = HEADSET_MIC,
+		.value = 99,
+	},
+	{
+		.type = HEADSET_BEATS,
+		.value = 129,
+	},
+	{
+		.type = HEADSET_BEATS,
+		.value = 170,
+	},
+	{
+		.type = HEADSET_BEATS_SOLO,
+		.value = 16,
+	},
+	{
+		.type = HEADSET_NO_MIC,
+		.value = 99,
+	},
+};
 
 static struct htc_headset_mgr_platform_data htc_headset_mgr_data = {
 	.eng_cfg				= HS_EDE_U,
 	.headset_devices_num	= ARRAY_SIZE(headset_devices),
 	.headset_devices	= headset_devices,
+	.enable_1wire			= 0,
+	.tx_1wire_gpio			= TEGRA_GPIO_PY4,
+	.rx_1wire_gpio			= TEGRA_GPIO_PY5,
+	.level_1wire_gpio		= TEGRA_GPIO_PZ0,
+	.dev_1wire				= "/dev/ttyHS4",
 	.headset_config_num	= ARRAY_SIZE(htc_headset_mgr_config),
 	.headset_config		= htc_headset_mgr_config,
+	.headset_config_1wire_num	= ARRAY_SIZE(htc_headset_mgr_1wire_config),
+	.headset_config_1wire		= htc_headset_mgr_1wire_config,
 };
 
 static struct htc_headset_mgr_platform_data htc_headset_mgr_data_xe = {
 	.eng_cfg				= HS_EDE_U,
 	.headset_devices_num	= ARRAY_SIZE(headset_devices_xe),
 	.headset_devices	= headset_devices_xe,
+	.enable_1wire			= 0,
+	.tx_1wire_gpio			= TEGRA_GPIO_PY4,
+	.rx_1wire_gpio			= TEGRA_GPIO_PY5,
+	.level_1wire_gpio		= TEGRA_GPIO_PZ0,
+	.dev_1wire				= "/dev/ttyHS4",
 	.headset_config_num	= ARRAY_SIZE(htc_headset_mgr_config_xe),
 	.headset_config		= htc_headset_mgr_config_xe,
+	.headset_config_1wire_num	= ARRAY_SIZE(htc_headset_mgr_1wire_config),
+	.headset_config_1wire		= htc_headset_mgr_1wire_config,
+
 };
 
 
@@ -1003,13 +1040,13 @@ static struct platform_device htc_headset_mgr_xe = {
 };
 
 
-static void enterprise_i2c_init(void)
+static void endeavor_i2c_init(void)
 {
-	tegra_i2c_device1.dev.platform_data = &enterprise_i2c1_platform_data;
-	tegra_i2c_device2.dev.platform_data = &enterprise_i2c2_platform_data;
-	tegra_i2c_device3.dev.platform_data = &enterprise_i2c3_platform_data;
-	tegra_i2c_device4.dev.platform_data = &enterprise_i2c4_platform_data;
-	tegra_i2c_device5.dev.platform_data = &enterprise_i2c5_platform_data;
+	tegra_i2c_device1.dev.platform_data = &endeavor_i2c1_platform_data;
+	tegra_i2c_device2.dev.platform_data = &endeavor_i2c2_platform_data;
+	tegra_i2c_device3.dev.platform_data = &endeavor_i2c3_platform_data;
+	tegra_i2c_device4.dev.platform_data = &endeavor_i2c4_platform_data;
+	tegra_i2c_device5.dev.platform_data = &endeavor_i2c5_platform_data;
 
 	platform_device_register(&tegra_i2c_device5);
 	platform_device_register(&tegra_i2c_device4);
@@ -1018,7 +1055,7 @@ static void enterprise_i2c_init(void)
 	platform_device_register(&tegra_i2c_device1);
 }
 
-static struct platform_device *enterprise_uart_devices[] __initdata = {
+static struct platform_device *endeavor_uart_devices[] __initdata = {
 	&tegra_uarta_device,
 	&tegra_uartb_device,
 	&tegra_uartc_device,
@@ -1033,10 +1070,10 @@ struct uart_clk_parent uart_parent_clk[] = {
 	[2] = {.name = "clk_m"},
 #endif
 };
-static struct tegra_uart_platform_data enterprise_uart_pdata;
+static struct tegra_uart_platform_data endeavor_uart_pdata;
 
 #ifdef CONFIG_BT_CTS_WAKEUP
-static struct tegra_uart_platform_data enterprise_bt_uart_pdata;
+static struct tegra_uart_platform_data endeavor_bt_uart_pdata;
 #endif
 
 static void __init uart_debug_init(void)
@@ -1046,7 +1083,7 @@ static void __init uart_debug_init(void)
 
 	/* UARTA is the debug port. */
 	pr_info("Selecting UARTA as the debug console\n");
-	enterprise_uart_devices[0] = &debug_uarta_device;
+	endeavor_uart_devices[0] = &debug_uarta_device;
 	debug_uart_port_base = ((struct plat_serial8250_port *)(
 			debug_uarta_device.dev.platform_data))->mapbase;
 	debug_uart_clk = clk_get_sys("serial8250.0", "uarta");
@@ -1121,7 +1158,7 @@ tegra_gpio_enable(TEGRA_GPIO_PZ0);
 }
 
 
-static void __init enterprise_uart_init(void)
+static void __init endeavor_uart_init(void)
 {
 	int i;
 	struct clk *c;
@@ -1136,35 +1173,37 @@ static void __init enterprise_uart_init(void)
 		uart_parent_clk[i].parent_clk = c;
 		uart_parent_clk[i].fixed_clk_rate = clk_get_rate(c);
 	}
-	enterprise_uart_pdata.parent_clk_list = uart_parent_clk;
-	enterprise_uart_pdata.parent_clk_count = ARRAY_SIZE(uart_parent_clk);
-	tegra_uarta_device.dev.platform_data = &enterprise_uart_pdata;
-	tegra_uartb_device.dev.platform_data = &enterprise_uart_pdata;
-	tegra_uartc_device.dev.platform_data = &enterprise_uart_pdata;
-	tegra_uartd_device.dev.platform_data = &enterprise_uart_pdata;
-	tegra_uarte_device.dev.platform_data = &enterprise_uart_pdata;
+	endeavor_uart_pdata.parent_clk_list = uart_parent_clk;
+	endeavor_uart_pdata.parent_clk_count = ARRAY_SIZE(uart_parent_clk);
+	tegra_uarta_device.dev.platform_data = &endeavor_uart_pdata;
+	tegra_uartb_device.dev.platform_data = &endeavor_uart_pdata;
+	tegra_uartc_device.dev.platform_data = &endeavor_uart_pdata;
+	tegra_uartd_device.dev.platform_data = &endeavor_uart_pdata;
+	tegra_uarte_device.dev.platform_data = &endeavor_uart_pdata;
 
 #ifdef CONFIG_BT_CTS_WAKEUP
 	int board_id = htc_get_pcbid_info();
 
-	enterprise_bt_uart_pdata = enterprise_uart_pdata;
-	if (board_id >= PROJECT_PHASE_XC) {// XC
-		enterprise_bt_uart_pdata.uart_bt = (1 == 1); /* true */
+	endeavor_bt_uart_pdata = endeavor_uart_pdata;
+	if ((machine_is_endeavoru() && (board_id >= PROJECT_PHASE_XC)) || // ENRU XC
+	    (machine_is_erau() && (board_id >= PROJECT_PHASE_XA))) // ERAU XA
+	{
+		endeavor_bt_uart_pdata.uart_bt = (1 == 1); /* true */
 	}
 	else {
-		enterprise_bt_uart_pdata.uart_bt = (1 == 0); /* false */
+		endeavor_bt_uart_pdata.uart_bt = (1 == 0); /* false */
 	}
-	enterprise_bt_uart_pdata.bt_en = BT_GPIO_EN;
-	enterprise_bt_uart_pdata.bt_cts_irq = BT_GPIO_CTS_IRQ;
-	tegra_uartc_device.dev.platform_data = &enterprise_bt_uart_pdata;
+	endeavor_bt_uart_pdata.bt_en = BT_GPIO_EN;
+	endeavor_bt_uart_pdata.bt_cts_irq = BT_GPIO_CTS_IRQ;
+	tegra_uartc_device.dev.platform_data = &endeavor_bt_uart_pdata;
 #endif
 
 	/* Register low speed only if it is selected */
 	if (!is_tegra_debug_uartport_hs())
 		uart_debug_init();
 
-	platform_add_devices(enterprise_uart_devices,
-				ARRAY_SIZE(enterprise_uart_devices));
+	platform_add_devices(endeavor_uart_devices,
+				ARRAY_SIZE(endeavor_uart_devices));
 }
 
 struct spi_clk_parent spi_parent_clk[] = {
@@ -1177,14 +1216,14 @@ struct spi_clk_parent spi_parent_clk[] = {
 #endif
 };
 
-static struct tegra_spi_platform_data cardhu_spi_pdata = {
+static struct tegra_spi_platform_data endeavor_spi_pdata = {
 	.is_dma_based		= true,
 	.max_dma_buffer		= (16 * 1024),
 	.is_clkon_always	= false,
 	.max_rate		= 100000000,
 };
 
-static void __init enterprise_spi_init(void)
+static void __init endeavor_spi_init(void)
 {
 	int i;
 	struct clk *c;
@@ -1199,13 +1238,13 @@ static void __init enterprise_spi_init(void)
 		spi_parent_clk[i].parent_clk = c;
 		spi_parent_clk[i].fixed_clk_rate = clk_get_rate(c);
 	}
-	cardhu_spi_pdata.parent_clk_list = spi_parent_clk;
-	cardhu_spi_pdata.parent_clk_count = ARRAY_SIZE(spi_parent_clk);
+	endeavor_spi_pdata.parent_clk_list = spi_parent_clk;
+	endeavor_spi_pdata.parent_clk_count = ARRAY_SIZE(spi_parent_clk);
 
 	spi_register_board_info(spi_board_info_audio, ARRAY_SIZE(spi_board_info_audio));
-        spi_register_board_info(enterprise_spi_board_info_rawchip, ARRAY_SIZE(enterprise_spi_board_info_rawchip));
+        spi_register_board_info(endeavor_spi_board_info_rawchip, ARRAY_SIZE(endeavor_spi_board_info_rawchip));
 	platform_device_register(&tegra_spi_device2);
-	tegra_spi_device4.dev.platform_data = &cardhu_spi_pdata;
+	tegra_spi_device4.dev.platform_data = &endeavor_spi_pdata;
         platform_device_register(&tegra_spi_device4);
 }
 
@@ -1247,7 +1286,7 @@ static struct platform_device ram_console_device = {
 	.resource	= ram_console_resources,
 };
 
-static struct platform_device *enterprise_devices[] __initdata = {
+static struct platform_device *endeavor_devices[] __initdata = {
 	&tegra_pmu_device,
 	&tegra_rtc_device,
 	&tegra_udc_device,
@@ -1268,7 +1307,7 @@ static struct platform_device *enterprise_devices[] __initdata = {
 	&spdif_dit_device,
 	&baseband_dit_device,
 	&tegra_pcm_device,
-	&enterprise_audio_device,
+	&endeavor_audio_device,
 	&tegra_rawchip_device,
 	&tegra_hda_device,
 //	&htc_headset_mgr,
@@ -1414,8 +1453,7 @@ static struct synaptics_i2c_rmi_platform_data edge_ts_3k_data_XB[] = {
 		.source = 1, //YFO
 		.customer_register = {0xF9,0x64,0x74,0x32},
 		.config = {
-			0x35,0x44,0x30,0x38,
-			0x00,0x3F,0x03,0x1E,0x05,0xB1,
+			0x35,0x44,0x30,0x39,0x00,0x3F,0x03,0x1E,0x05,0xB1,
 			0x08,0x0B,0x19,0x19,0x00,0x00,0x4C,0x04,0x75,0x07,
 			0x02,0x14,0x1E,0x05,0x37,0xA5,0x16,0xE8,0x03,0x01,
 			0x3C,0x17,0x02,0x17,0x01,0xEC,0x4D,0x71,0x51,0xF8,
@@ -1423,15 +1461,15 @@ static struct synaptics_i2c_rmi_platform_data edge_ts_3k_data_XB[] = {
 			0x04,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x01,
 			0x00,0x0A,0x70,0x32,0xA2,0x02,0x28,0x0A,0x0A,0x64,
 			0x16,0x0C,0x00,0x02,0xEE,0x00,0x80,0x03,0x0E,0x1F,
-			0x11,0x38,0x00,0x13,0x08,0x1B,0x00,0x08,0xFF,0x00,
+			0x11,0x38,0x00,0x13,0x04,0x1B,0x00,0x08,0xFF,0x00,
 			0x06,0x0C,0x0D,0x0B,0x15,0x17,0x16,0x18,0x19,0x1A,
 			0x1B,0x11,0x14,0x12,0x0F,0x0E,0x09,0x0A,0x07,0x02,
 			0x01,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x04,0x05,0x02,
 			0x06,0x01,0x0C,0x07,0x08,0x0E,0x10,0x0F,0x12,0xFF,
 			0xFF,0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xC0,0xC8,0xC8,
 			0xC8,0x59,0x57,0x55,0x53,0x52,0x50,0x4E,0x4D,0x00,
-			0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x00,0xA0,0x0F,
-			0xFF,0x28,0x00,0xC8,0x00,0xB3,0xC8,0xCD,0xA0,0x0F,
+			0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x00,0x88,0x13,
+			0xCD,0x64,0x00,0xC8,0x00,0x80,0x0A,0x80,0xB8,0x0B,
 			0x00,0xC0,0x80,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
 			0x10,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 			0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
@@ -1439,7 +1477,7 @@ static struct synaptics_i2c_rmi_platform_data edge_ts_3k_data_XB[] = {
 			0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 			0x80,0x80,0x80,0x80,0x02,0x02,0x02,0x02,0x02,0x02,
 			0x02,0x02,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
-			0x58,0x5B,0x5D,0x5F,0x61,0x63,0x65,0x67,0x00,0x64,
+			0x58,0x5B,0x5D,0x5F,0x61,0x63,0x65,0x67,0x00,0x8C,
 			0x00,0x10,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 			0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
 			0xFF,0xFF,0xFF,0xFF,0x51,0x51,0x51,0x51,0xCD,0x0D,
@@ -1460,32 +1498,31 @@ static struct synaptics_i2c_rmi_platform_data edge_ts_3k_data_XB[] = {
 		.source = 0, //second source
 		.customer_register = {0xF9,0x64,0x74,0x32},
 		.config = {
-			0x35,0x4A,0x30,0x39,
-			0x00,0x3F,0x03,0x1E,0x05,0xB1,
+			0x35,0x4A,0x31,0x30,0x00,0x3F,0x03,0x1E,0x05,0xB1,
 			0x08,0x0B,0x19,0x19,0x00,0x00,0x4C,0x04,0x75,0x07,
 			0x02,0x14,0x1E,0x05,0x3A,0x57,0x1F,0xAF,0x02,0x01,
 			0x3C,0x17,0x02,0x17,0x01,0xEC,0x4D,0x71,0x51,0xF8,
 			0xA7,0xC8,0xAF,0x00,0x50,0x13,0x00,0x00,0x00,0x0A,
 			0x04,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x01,
-			0x00,0x0A,0x70,0x32,0xA2,0x02,0x28,0x0A,0x0A,0x64,
+			0x00,0x0A,0x90,0x32,0xA2,0x02,0x28,0x0A,0x0A,0x64,
 			0x16,0x0C,0x00,0x02,0xF0,0x00,0x80,0x03,0x0E,0x1F,
-			0x11,0x38,0x00,0x13,0x08,0x1B,0x00,0x08,0xFF,0x00,
+			0x11,0x38,0x00,0x13,0x04,0x1B,0x00,0x08,0xFF,0x00,
 			0x06,0x0C,0x0D,0x0B,0x15,0x17,0x16,0x18,0x19,0x1A,
 			0x1B,0x11,0x14,0x12,0x0F,0x0E,0x09,0x0A,0x07,0x02,
 			0x01,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x04,0x05,0x02,
 			0x06,0x01,0x0C,0x07,0x08,0x0E,0x10,0x0F,0x12,0xFF,
-			0xFF,0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xC0,0xC8,0xC8,
-			0xC8,0x62,0x60,0x5E,0x5C,0x5A,0x58,0x57,0x55,0x00,
-			0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x00,0xB8,0x0B,
-			0xCD,0x28,0x00,0xC8,0x00,0x80,0xC8,0xCD,0xB8,0x0B,
+			0xFF,0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xC8,0xC8,0xC8,
+			0xC8,0x5E,0x5C,0x5A,0x58,0x57,0x55,0x53,0x51,0x00,
+			0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x00,0x88,0x13,
+			0xCD,0x64,0x00,0xC8,0x00,0x80,0x0A,0x80,0xB8,0x0B,
 			0x00,0xC0,0x80,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
 			0x10,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 			0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 			0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 			0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 			0x80,0x80,0x80,0x80,0x02,0x02,0x02,0x02,0x02,0x02,
-			0x02,0x02,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
-			0x7E,0x57,0x59,0x5B,0x5D,0x5F,0x61,0x63,0x00,0x64,
+			0x02,0x02,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
+			0x58,0x5B,0x5D,0x5F,0x61,0x63,0x65,0x67,0x00,0x8C,
 			0x00,0x10,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 			0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
 			0xFF,0xFF,0xFF,0xFF,0x51,0x51,0x51,0x51,0xCD,0x0D,
@@ -1636,14 +1673,14 @@ int __init generic_touch_init(struct tegra_touchscreen_init *tsdata)
 	return 0;
 }
 
-static int __init enterprise_touch_init(void)
+static int __init endeavor_touch_init(void)
 {
 	int retval = 0;
 	struct board_info BoardInfo;
 
 	tegra_get_board_info(&BoardInfo);
 	
-	if (htc_get_pcbid_info() == PROJECT_PHASE_XA)
+	if (htc_get_pcbid_info() == PROJECT_PHASE_XA && machine_is_endeavoru())
 		retval = generic_touch_init(&synaptics_init_data);
 	else
 		retval = generic_touch_init(&synaptics_init_data_XB);
@@ -1790,7 +1827,7 @@ static int cardu_usb_hsic_phy_off(void)
 	return 0;
 }
 
-static void enterprise_usb_init(void)
+static void endeavor_usb_init(void)
 {
 	struct	fsl_usb2_platform_data *udc_pdata;
 
@@ -1804,7 +1841,7 @@ static void enterprise_usb_init(void)
 	android_usb_pdata.products[0].product_id =
 	android_usb_pdata.product_id;
 #if defined(CONFIG_USB_CDROM)
-	if (board_mfg_mode() == 0 /* normal mode */) {
+	if (board_mfg_mode() == BOARD_MFG_MODE_NORMAL /* normal mode */) {
 		android_usb_pdata.nluns = 2;
 		android_usb_pdata.cdrom_lun = 0x2;
 	}
@@ -1817,6 +1854,12 @@ static void enterprise_usb_init(void)
 
 //	platform_device_register(&func_switch_device);
 	platform_device_register(&android_usb_device);
+
+	udc_pdata->charger_type = 1;
+	udc_pdata->ur_gpio = TEGRA_GPIO_PH3;
+	udc_pdata->tx_gpio = TEGRA_GPIO_PO1;
+	udc_pdata->rx_gpio = TEGRA_GPIO_PO2;
+	udc_pdata->chg_gpio = TEGRA_GPIO_PC7;
 }
 
 static int32_t get_tegra_adc_cb(void)
@@ -1902,6 +1945,7 @@ static struct cable_detect_platform_data cable_detect_pdata = {
 	.cable_gpio_init	= cable_tegra_gpio_init,
 #ifdef CONFIG_TEGRA_HDMI_MHL
 	/*.mhl_1v2_power = mhl_sii9234_1v2_power,*/
+	.mhl_internal_3v3 	= 1,
 #endif
 };
 
@@ -1940,12 +1984,12 @@ static void cable_tegra_gpio_init(void)
 	}
 }
 
-static void enterprise_cable_detect_init(void)
+static void endeavor_cable_detect_init(void)
 {
 	platform_device_register(&cable_detect_device);
 }
 
-static void enterprise_gps_init(void)
+static void endeavor_gps_init(void)
 {
 	//tegra_gpio_enable(TEGRA_GPIO_PE4);
 	//tegra_gpio_enable(TEGRA_GPIO_PE5);
@@ -2014,7 +2058,7 @@ static struct platform_device tegra_baseband_power_device = {
 */
 //#endif
 
-static void enterprise_modem_init(void)
+static void endeavor_modem_init(void)
 {
 	struct board_info board_info;
 //	int w_disable_gpio;
@@ -2153,17 +2197,17 @@ static void modem_not_init(void)
 }
 
 
-static void enterprise_baseband_init(void)
+static void endeavor_baseband_init(void)
 {
 //	modem_not_init();
 //	return;
-	enterprise_modem_init();
+	endeavor_modem_init();
 #if 0
 	int modem_id = tegra_get_modem_id();
 
 	switch (modem_id) {
 	case 1: /* PH450 ULPI */
-		enterprise_modem_init();
+		endeavor_modem_init();
 		break;
 		case 2: /* 6260 HSIC */
 		break;
@@ -2226,6 +2270,15 @@ static struct attribute_group Aproj_properties_attr_group_XC = {
 	.attrs = Aproj_properties_attrs_XC,
 };
 
+bool enr_swResetCheck()
+{
+	int pcbid = htc_get_pcbid_info();
+	if ( machine_is_endeavoru() && ((pcbid < PROJECT_PHASE_A ) || ( (pcbid == PROJECT_PHASE_A) && (engineer_id == 0x01 ))))
+		return true;
+	else
+		return false;
+}
+
 static struct keyreset_platform_data enr_reset_keys_pdata = {
 	.keys_down = {
 		KEY_POWER,
@@ -2233,6 +2286,7 @@ static struct keyreset_platform_data enr_reset_keys_pdata = {
 		KEY_VOLUMEUP,
 		0
 	},
+	.swResetCheck = enr_swResetCheck,
 };
 
 static struct platform_device enr_reset_keys_device = {
@@ -2248,6 +2302,14 @@ static void enr_u_basic_gpio_setup(void)
 	int pcbid = htc_get_pcbid_info();
 	static struct gpio_callbacks callbacks = {NULL};
 
+	/*
+	 * Since era#u has only XA phase currently, and XA of era#u ==
+	 * PVT of end#u, it's safe to use enr_u_xe_no_owner_gpio_init
+	 * on era#u for now
+	 */
+	if (machine_is_erau())
+		pcbid = PROJECT_PHASE_A;
+
 	switch (pcbid) {
 		case PROJECT_PHASE_XA:
 		case PROJECT_PHASE_XB:
@@ -2268,7 +2330,7 @@ static void enr_u_basic_gpio_setup(void)
 
 }
 
-static void __init tegra_enterprise_init(void)
+static void __init tegra_endeavor_init(void)
 {
 	int board_id = 0;
 	struct kobject *properties_kobj;  	
@@ -2276,36 +2338,42 @@ static void __init tegra_enterprise_init(void)
 	tegra_thermal_init(&thermal_data);
 	BOOT_DEBUG_LOG_ENTER("<machine>.init_machine");
 	board_id = htc_get_pcbid_info();
-	tegra_clk_init_from_table(enterprise_clk_init_table);
+	tegra_clk_init_from_table(endeavor_clk_init_table);
 	endeavoru_pinmux_init();
-	enterprise_i2c_init();
-	enterprise_uart_init();
-	enterprise_spi_init();
-	enterprise_usb_init();
+	endeavor_i2c_init();
+	endeavor_uart_init();
+	endeavor_spi_init();
+	endeavor_usb_init();
 //	andusb_plat.serial_number = board_serialno();
-	enterprise_tsensor_init();
-	platform_add_devices(enterprise_devices, ARRAY_SIZE(enterprise_devices));
-	if (board_id <= PROJECT_PHASE_XD)
+	endeavor_tsensor_init();
+	platform_add_devices(endeavor_devices, ARRAY_SIZE(endeavor_devices));
+	if (machine_is_endeavoru() && board_id <= PROJECT_PHASE_XD)
 		platform_device_register(&htc_headset_mgr);
 	else
 		platform_device_register(&htc_headset_mgr_xe);
 
-	if (board_id >= PROJECT_PHASE_A && engineer_id != 1) {
+	if (machine_is_erau()) {
 		mhl_sii_device_data.ci2ca = 1;
 		mhl_sii_device_data.enMhlD3Guard = true;
+	} else if (machine_is_endeavoru()) {
+		if ((board_id > PROJECT_PHASE_A) ||
+				(board_id == PROJECT_PHASE_A && engineer_id != 1)) {
+			mhl_sii_device_data.ci2ca = 1;
+			mhl_sii_device_data.enMhlD3Guard = true;
+		}
 	}
 
-	enterprise_regulator_init();
-	enterprise_sdhci_init();
+	endeavor_regulator_init();
+	endeavor_sdhci_init();
 	headset_uart_init();
 #ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE
 		set_two_phase_freq(1000000);
 #endif
 
 #ifdef CONFIG_TEGRA_EDP_LIMITS
-	enterprise_edp_init();
+	endeavor_edp_init();
 #endif
-	//enterprise_kbc_init();
+	//endeavor_kbc_init();
 #if 1    // for A project bring up
 	A_PROJECT_keys_init();
 #endif
@@ -2313,36 +2381,38 @@ static void __init tegra_enterprise_init(void)
 	i2c_register_board_info(4, i2c_mhl_sii_info,
 			ARRAY_SIZE(i2c_mhl_sii_info));
 #endif
-	enterprise_touch_init();
-	//enterprise_gps_init();
-	enterprise_baseband_init();
-	enterprise_panel_init();
-	enterprise_bt_wl128x();
-	enterprise_emc_init();
-	enterprise_sensors_init();
+	endeavor_touch_init();
+	//endeavor_gps_init();
+	endeavor_baseband_init();
+	endeavor_panel_init();
+	endeavor_bt_wl128x();
+
+	endeavor_emc_init();
+	endeavor_sensors_init();
+	endeavor_cam_init();
 	if (platform_device_register(&enr_reset_keys_device))
 		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
         properties_kobj = kobject_create_and_add("board_properties", NULL);
 	if (properties_kobj) {
-		if (htc_get_pcbid_info() >= PROJECT_PHASE_XC) {
-			sysfs_create_group(properties_kobj, &Aproj_properties_attr_group_XC);
-		} else {
+		if (htc_get_pcbid_info() < PROJECT_PHASE_XC && machine_is_endeavoru()) {
 			sysfs_create_group(properties_kobj, &Aproj_properties_attr_group);
+		} else {
+			sysfs_create_group(properties_kobj, &Aproj_properties_attr_group_XC);
 		}
 	}
-	enterprise_suspend_init();
+	endeavor_suspend_init();
 	tegra_release_bootloader_fb();
 #ifdef CONFIG_TEGRA_HAPTIC2
-	haptic_vibrator_init(board_id);
+	haptic_vibrator_init();
 #endif
 #ifdef CONFIG_TEGRA_VIBRATOR_ENR
 	tegra_vibrator_init();
 #endif
 	leds_lp5521_init();
-	enterprise_flashlight_init();
+	endeavor_flashlight_init();
 	enr_u_basic_gpio_setup();
 #if defined(CONFIG_CABLE_DETECT_ACCESSORY)
-	enterprise_cable_detect_init();
+	endeavor_cable_detect_init();
 #endif
 	struct proc_dir_entry* proc;
 	proc = create_proc_read_entry("emmc", 0, NULL, emmc_partition_read_proc, NULL);
@@ -2359,7 +2429,7 @@ static void __init tegra_enterprise_init(void)
 	BOOT_DEBUG_LOG_LEAVE("<machine>.init_machine");
 }
 
-static void __init tegra_enterprise_ramconsole_reserve(unsigned long size)
+static void __init tegra_endeavor_ramconsole_reserve(unsigned long size)
 {
 	struct resource *res;
 	long ret;
@@ -2380,33 +2450,22 @@ static void __init tegra_enterprise_ramconsole_reserve(unsigned long size)
 	}
 }
 
-static void __init tegra_enterprise_reserve(void)
+static void __init tegra_endeavor_reserve(void)
 {
 #if defined(CONFIG_NVMAP_CONVERT_CARVEOUT_TO_IOVMM)
 	tegra_reserve(0, SZ_4M, SZ_8M);
 #else
 	tegra_reserve(SZ_128M, SZ_4M, SZ_8M);
 #endif
-	tegra_enterprise_ramconsole_reserve(SZ_1M);
+	tegra_endeavor_ramconsole_reserve(SZ_1M);
 }
 
 MACHINE_START(ENDEAVORU, "endeavoru")
 	.boot_params    = 0x80000100,
 	.map_io         = tegra_map_common_io,
-	.reserve        = tegra_enterprise_reserve,
-	.init_early	= tegra_init_early,
-	.init_irq       = tegra_init_irq,
-	.timer          = &tegra_timer,
-	.init_machine   = tegra_enterprise_init,
-MACHINE_END
-
-/* XXX for transition period only, will be removed soon */
-MACHINE_START(TEGRA_ENTERPRISE, "endeavoru")
-	.boot_params    = 0x80000100,
-	.map_io         = tegra_map_common_io,
-	.reserve        = tegra_enterprise_reserve,
+	.reserve        = tegra_endeavor_reserve,
 	.init_early	= tegra_init_early,
 	.init_irq       = tegra_init_irq,
 	.timer          = &tegra_timer,
-	.init_machine   = tegra_enterprise_init,
+	.init_machine   = tegra_endeavor_init,
 MACHINE_END
diff --git a/arch/arm/mach-tegra/board-endeavoru.h b/arch/arm/mach-tegra/board-endeavoru.h
index 8ec0c15..0ac9948 100644
--- a/arch/arm/mach-tegra/board-endeavoru.h
+++ b/arch/arm/mach-tegra/board-endeavoru.h
@@ -38,20 +38,21 @@
 /* vdd_cpu voltage follower */
 #define BOARD_SKU_VF_BIT	0x0400
 
-int enterprise_charge_init(void);
-int enterprise_sdhci_init(void);
+int endeavor_charge_init(void);
+int endeavor_sdhci_init(void);
 int endeavoru_pinmux_init(void);
-int enterprise_panel_init(void);
-int enterprise_sensors_init(void);
+int endeavor_panel_init(void);
+int endeavor_sensors_init(void);
+int endeavor_cam_init(void);
 int touch_init(void);
-int enterprise_kbc_init(void);
-int enterprise_emc_init(void);
-int enterprise_regulator_init(void);
-//int enterprise_modem_init(void);
-int enterprise_suspend_init(void);
-int enterprise_edp_init(void);
-void __init enterprise_tsensor_init(void);
-void enterprise_bpc_mgmt_init(void);
+int endeavor_kbc_init(void);
+int endeavor_emc_init(void);
+int endeavor_regulator_init(void);
+//int endeavor_modem_init(void);
+int endeavor_suspend_init(void);
+int endeavor_edp_init(void);
+void __init endeavor_tsensor_init(void);
+void endeavor_bpc_mgmt_init(void);
 
 /* Invensense MPU Definitions */
 #define MPU_GYRO_NAME		"mpu3050"
 #endif
diff --git a/arch/arm/mach-tegra/common.c b/arch/arm/mach-tegra/common.c
index 88b450b..27f5486 100644
--- a/arch/arm/mach-tegra/common.c
+++ b/arch/arm/mach-tegra/common.c
@@ -181,6 +181,14 @@ static __initdata struct tegra_clk_init_table common_clk_init_table[] = {
 	{ "hclk",	"sclk",		102000000,	true },
 	{ "pclk",	"hclk",		51000000,	true },
 	{ "cpu.sclk",	NULL,		80000000,	false },
+#ifdef CONFIG_SERIAL_SC8800G
+	{ "sbc1.sclk",	NULL,		40000000,	false},
+	{ "sbc2.sclk",	NULL,		40000000,	false},
+	{ "sbc3.sclk",	NULL,		40000000,	false},
+	{ "sbc4.sclk",	NULL,		40000000,	false},
+	{ "sbc5.sclk",	NULL,		40000000,	false},
+	{ "sbc6.sclk",	NULL,		40000000,	false},
+#endif
 #endif
 #else
 	{ "pll_p",	NULL,		216000000,	true },
@@ -615,7 +623,7 @@ static void tegra_pm_restart(char mode, const char *cmd)
 				set_reboot_battery_level(get_battery_level_cb());
 			break;
 	}
-
+	tegra_pm_flush_console();
 	arm_machine_restart(mode, cmd);
 }
 #else
diff --git a/arch/arm/mach-tegra/cpu-tegra.c b/arch/arm/mach-tegra/cpu-tegra.c
index 14aca9a..816992a 100644
--- a/arch/arm/mach-tegra/cpu-tegra.c
+++ b/arch/arm/mach-tegra/cpu-tegra.c
@@ -36,8 +36,8 @@
 #include <linux/pm_qos_params.h>
 #include <linux/earlysuspend.h>
 #include <linux/spinlock.h>
-#include <linux/cpu_debug.h>
 #include <linux/workqueue.h>
+#include <linux/cpu_debug.h>
 
 #include <asm/system.h>
 
@@ -185,6 +185,7 @@ static u32 ms_array_pm[CPU_NUMBER][MS_NUMBER];
 /*for DVFS Profile*/
 void cpu_dvfs_debug_show(void)
 {
+#ifdef CONFIG_PWR_STORY
 	int i;
 	int j;
 	char buffer[MAX_LOCAL_BUFFER];
@@ -199,6 +200,7 @@ void cpu_dvfs_debug_show(void)
 		*(bptr-1) = '\0';
 		pr_pwr_story(" CPU%u: Each freq runs (ms): %s", j, buffer);
 	}
+#endif
 }
 
 static ssize_t show_throttle(struct cpufreq_policy *policy, char *buf)
@@ -518,7 +520,7 @@ unsigned int tegra_getspeed(unsigned int cpu)
 	return rate;
 }
 
-static int tegra_update_cpu_speed(unsigned long rate)
+int tegra_update_cpu_speed(unsigned long rate)
 {
 	int ret = 0;
 	struct cpufreq_freqs freqs;
@@ -532,6 +534,7 @@ static int tegra_update_cpu_speed(unsigned long rate)
 	char *bptr = buffer;
 	unsigned long rate_save = rate;
 	int orig_nice = 0;
+	u32 suspend_ms;
 
 	freqs.old = tegra_getspeed(0);
 	freqs.new = rate;
@@ -618,6 +621,12 @@ static int tegra_update_cpu_speed(unsigned long rate)
 	rtc_after = tegra_rtc_read_ms();
 	ms = rtc_after - rtc_before;
 
+	suspend_ms = get_suspend_time();
+
+	if(suspend_ms && ms >= suspend_ms) {
+		ms -= suspend_ms;
+	}
+
 	for (i = 0; (freq_table[i].frequency != CPUFREQ_TABLE_END); i++) {
 		if (freq_table[i].frequency == freqs.old)
 			index = i;
@@ -803,6 +812,9 @@ static struct pm_qos_request_list cap_cpu_freq_req;
 #define BOOST_CPU_FREQ_MIN 1500000
 #define CAP_CPU_FREQ_MAX 475000
 #endif
+static int enter_early_suspend = 0;
+static int perf_early_suspend = 0;
+static int CAP_CPU_FREQ_TARGET = 1500000;
 
 
 static int tegra_pm_notify(struct notifier_block *nb, unsigned long event,
@@ -923,6 +935,12 @@ static struct freq_attr *tegra_cpufreq_attr[] = {
 
 static int tegra_cpufreq_suspend(struct cpufreq_policy *policy)
 {
+	if (CAP_CPU_FREQ_TARGET != CAP_CPU_FREQ_MAX){
+		CAP_CPU_FREQ_TARGET = CAP_CPU_FREQ_MAX;
+		pm_qos_update_request(&cap_cpu_freq_req, (s32)CAP_CPU_FREQ_MAX);
+		pr_info("tegra_cpufreq_suspend: cap cpu freq to %d\n", CAP_CPU_FREQ_MAX);
+	}
+
 	return 0;
 }
 static int tegra_cpufreq_resume(struct cpufreq_policy *policy)
@@ -949,8 +967,13 @@ static struct cpufreq_driver tegra_cpufreq_driver = {
 
 static void tegra_cpufreq_powersave_early_suspend(struct early_suspend *h)
 {
-	pr_info("tegra_cpufreq_powersave_early_suspend: cap cpu freq to 475MHz\n");
-	pm_qos_update_request(&cap_cpu_freq_req, (s32)CAP_CPU_FREQ_MAX);
+	if(perf_early_suspend == 0){
+		pr_info("tegra_cpufreq_powersave_early_suspend: cap cpu freq to 475MHz\n");
+		pm_qos_update_request(&cap_cpu_freq_req, (s32)CAP_CPU_FREQ_MAX);
+		CAP_CPU_FREQ_TARGET = CAP_CPU_FREQ_MAX;
+	}
+
+	enter_early_suspend = 1;
 
 #ifdef CONFIG_TEGRA_CONSERVATIVE_GOV_ON_EARLY_SUSPEND
 	cpufreq_save_governor();
@@ -982,6 +1005,7 @@ static void tegra_cpufreq_powersave_late_resume(struct early_suspend *h)
 	pr_info("tegra_cpufreq_powersave_late_resume: boost cpu freq to 1.5GHz\n");
 	pm_qos_update_request(&boost_cpu_freq_req, (s32)BOOST_CPU_FREQ_MIN);
 	tegra_update_cpu_speed(BOOST_CPU_FREQ_MIN);
+	enter_early_suspend = 0;
 }
 static void tegra_cpufreq_performance_early_suspend(struct early_suspend *h)
 {
@@ -1033,6 +1057,32 @@ static struct kernel_param_ops ril_boost_ops = {
 
 module_param_cb(ril_boost, &ril_boost_ops, &ril_boost, 0644);
 
+static int perf_early_suspend_set(const char *arg, const struct kernel_param *kp)
+{
+	int ret = param_set_int(arg, kp);
+	if (ret == 0){
+		if(enter_early_suspend && perf_early_suspend){
+			CAP_CPU_FREQ_TARGET = BOOST_CPU_FREQ_MIN;
+			pm_qos_update_request(&cap_cpu_freq_req, (s32)BOOST_CPU_FREQ_MIN);
+			pr_info("tegra_cpufreq_powersave_early_suspend: Release the cap freq");
+		}
+	}
+	else
+		pr_warn(" Unable to set perf_early_suspend");
+	return 0;
+}
+
+static int perf_early_suspend_get(char *buffer, const struct kernel_param *kp)
+{
+	return param_get_int(buffer, kp);
+}
+static struct kernel_param_ops perf_early_suspend_ops = {
+	.set = perf_early_suspend_set,
+	.get = perf_early_suspend_get,
+};
+
+module_param_cb(perf_early_suspend, &perf_early_suspend_ops, &perf_early_suspend, 0644);
+
 static int __init tegra_cpufreq_init(void)
 {
 	int ret = 0;
diff --git a/arch/arm/mach-tegra/cpu-tegra.h b/arch/arm/mach-tegra/cpu-tegra.h
index eca6106..d2ee9c8 100644
--- a/arch/arm/mach-tegra/cpu-tegra.h
+++ b/arch/arm/mach-tegra/cpu-tegra.h
@@ -22,6 +22,7 @@
 #define __MACH_TEGRA_CPU_TEGRA_H
 
 unsigned int tegra_getspeed(unsigned int cpu);
+int tegra_update_cpu_speed(unsigned long rate);
 int tegra_cpu_set_speed_cap(unsigned int *speed_cap);
 unsigned int tegra_count_slow_cpus(unsigned long speed_limit);
 unsigned int tegra_get_slowest_cpu_n(void);
diff --git a/arch/arm/mach-tegra/cpu-tegra3.c b/arch/arm/mach-tegra/cpu-tegra3.c
index d6b9e2a..d421eca 100644
--- a/arch/arm/mach-tegra/cpu-tegra3.c
+++ b/arch/arm/mach-tegra/cpu-tegra3.c
@@ -182,9 +182,17 @@ static int hp_state_set(const char *arg, const struct kernel_param *kp)
 
 	if (ret == 0) {
 		if ((hp_state == TEGRA_HP_DISABLED) &&
-		    (old_state != TEGRA_HP_DISABLED))
+		    (old_state != TEGRA_HP_DISABLED)) {
+			mutex_unlock(tegra3_cpu_lock);
+			cancel_delayed_work_sync(&hotplug_work);
+			cancel_work_sync(&cpuplug_work);
+			mutex_lock(tegra3_cpu_lock);
+			if (is_plugging) {
+				pr_info(CPU_HOTPLUG_TAG" is_plugging is true, set to false\n");
+				is_plugging = false;
+			}
 			pr_info(CPU_HOTPLUG_TAG" Tegra auto hotplug disabled\n");
-		else if (hp_state != TEGRA_HP_DISABLED) {
+		} else if (hp_state != TEGRA_HP_DISABLED) {
 			if (old_state == TEGRA_HP_DISABLED) {
 				pr_info(CPU_HOTPLUG_TAG" Tegra auto-hotplug enabled\n");
 				hp_init_stats();
@@ -212,15 +220,15 @@ static struct kernel_param_ops tegra_hp_state_ops = {
 };
 module_param_cb(auto_hotplug, &tegra_hp_state_ops, &hp_state, 0644);
 
-static unsigned int NwNs_Threshold[] = {19, 30, 19, 11, 19, 11, 0, 11};
-static unsigned int TwTs_Threshold[] = {140, 0, 140, 190, 140, 190, 0, 190};
-extern unsigned int get_rq_info(void);
+unsigned int NwNs_Threshold[] = {19, 30, 19, 11, 19, 11, 0, 11};
+unsigned int TwTs_Threshold[] = {140, 0, 140, 190, 140, 190, 0, 190};
 
 static unsigned int NwNs[8] = {19, 30, 19, 11, 19, 11, 0, 11};
 module_param_array(NwNs, uint, NULL, 0644);
 static unsigned int TwTs[8] = {140, 0, 140, 190, 140, 190, 0, 190};
 module_param_array(TwTs, uint, NULL, 0644);
 extern unsigned int set_rq_poll_ms(unsigned int poll_ms);
+extern int __cpu_plug(void);
 
 static int mp_policy = 0;
 
@@ -315,11 +323,13 @@ void printCPUTotalActiveTime()
 {
 	updateCurrentCPUTotalActiveTime();
 
+#ifdef CONFIG_PWR_STORY
 	pr_pwr_story("CPUs total active time:%llu,%llu,%llu,%llu",
 					cpu_hp_active_time_stats[0].total_active_Time,
 					cpu_hp_active_time_stats[1].total_active_Time,
 					cpu_hp_active_time_stats[2].total_active_Time,
 					cpu_hp_active_time_stats[3].total_active_Time);
+#endif
 }
 
 
@@ -423,6 +433,7 @@ static void tegra_auto_cpuplug_work_func(struct work_struct *work)
 {
 	bool up = false;
 	unsigned int cpu = nr_cpu_ids;
+	unsigned int min_cpus;
 
 	mutex_lock(tegra3_cpu_lock);
 	if (hp_state != TEGRA_HP_DISABLED) {
@@ -437,8 +448,13 @@ static void tegra_auto_cpuplug_work_func(struct work_struct *work)
 		case TEGRA_HP_DOWN:
 			cpu = tegra_get_slowest_cpu_n();
 			if (cpu < nr_cpu_ids) {
-				up = false;
-				hp_stats_update(cpu, false);
+				min_cpus = pm_qos_request(PM_QOS_MIN_ONLINE_CPUS);
+				if (min_cpus < num_online_cpus()) {
+					up = false;
+					hp_stats_update(cpu, false);
+				} else {
+					cpu = nr_cpu_ids;
+				}
 			} else if (!is_lp_cluster() && !no_lp) {
 				if (!clk_set_parent(cpu_clk, cpu_lp_clk)) {
 					CPU_DEBUG_PRINTK(CPU_DEBUG_HOTPLUG, " ENTER LPCPU");
@@ -475,56 +491,6 @@ static void tegra_auto_cpuplug_work_func(struct work_struct *work)
 	mutex_unlock(tegra3_cpu_lock);
 }
 
-static int mp_decision(void)
-{
-	static bool first_call = true;
-	int new_state = TEGRA_HP_IDLE;
-	int nr_cpu_online;
-	int index;
-	unsigned int rq_depth;
-	static cputime64_t total_time = 0;
-	static cputime64_t last_time;
-	cputime64_t current_time;
-	cputime64_t this_time = 0;
-
-	current_time = ktime_to_ms(ktime_get());
-	if (first_call) {
-		first_call = false;
-	} else {
-		this_time = current_time - last_time;
-	}
-	total_time += this_time;
-
-	rq_depth = get_rq_info();
-	CPU_DEBUG_PRINTK(CPU_DEBUG_HOTPLUG, " rq_deptch = %u", rq_depth);
-	nr_cpu_online = num_online_cpus();
-
-	if (nr_cpu_online) {
-		index = (nr_cpu_online - 1) * 2;
-		if ((nr_cpu_online < 4) && (rq_depth >= NwNs_Threshold[index])) {
-			if (total_time >= TwTs_Threshold[index]) {
-				new_state = TEGRA_HP_UP;
-			}
-		} else if (rq_depth <= NwNs_Threshold[index+1]) {
-			if (total_time >= TwTs_Threshold[index+1] ) {
-				new_state = TEGRA_HP_DOWN;
-			}
-		} else {
-			total_time = 0;
-		}
-	} else {
-		total_time = 0;
-	}
-
-	if (new_state != TEGRA_HP_IDLE) {
-		total_time = 0;
-	}
-
-	last_time = ktime_to_ms(ktime_get());
-
-	return new_state;
-}
-
 void gcpu_plug(unsigned int cpu_freq)
 {
 	unsigned long up_delay, top_freq, bottom_freq;
@@ -533,6 +499,7 @@ void gcpu_plug(unsigned int cpu_freq)
 	static cputime64_t last_time;
 	cputime64_t current_time;
 	cputime64_t this_time = 0;
+	unsigned int min_cpus;
 
 	if (is_plugging) {
 		return;
@@ -550,8 +517,20 @@ void gcpu_plug(unsigned int cpu_freq)
 	top_freq = idle_bottom_freq;
 	bottom_freq = idle_bottom_freq;
 
+	min_cpus = pm_qos_request(PM_QOS_MIN_ONLINE_CPUS);
+	if (min_cpus > num_online_cpus()) {
+		if (hp_state != TEGRA_HP_UP) {
+			hp_state = TEGRA_HP_UP;
+		}
+		is_plugging = true;
+		last_state = TEGRA_HP_UP;
+		queue_work(cpuplug_wq, &cpuplug_work);
+		total_time = 0;
+		return;
+	}
+
 	if (smp_processor_id() == 0)
-		mp_state = mp_decision();
+		mp_state = __cpu_plug();
 	else
 		mp_state = TEGRA_HP_IDLE;
 
@@ -594,7 +573,7 @@ void gcpu_plug(unsigned int cpu_freq)
 			break;
 		/* cpu speed is up, but skewed - remove one core */
 		case TEGRA_CPU_SPEED_SKEWED:
-			if ((total_time >= down_time) && (mp_state == TEGRA_HP_DOWN)) {
+			if (total_time >= down_time) {
 				is_plugging = true;
 				last_state = TEGRA_HP_DOWN;
 				queue_work(cpuplug_wq, &cpuplug_work);
@@ -609,7 +588,7 @@ void gcpu_plug(unsigned int cpu_freq)
 			break;
 		}
 	} else if (hp_state == TEGRA_HP_DOWN) {
-		if ((total_time >= down_time) && (mp_state == TEGRA_HP_DOWN))  {
+		if (total_time >= down_time) {
 			is_plugging = true;
 			last_state = TEGRA_HP_DOWN;
 			queue_work(cpuplug_wq, &cpuplug_work);
@@ -617,6 +596,13 @@ void gcpu_plug(unsigned int cpu_freq)
 		}
 	}
 
+	if (!is_plugging && (num_online_cpus() > 1) && (mp_state == TEGRA_HP_DOWN)) {
+		is_plugging = true;
+		last_state = TEGRA_HP_DOWN;
+		queue_work(cpuplug_wq, &cpuplug_work);
+		total_time = 0;
+	}
+
 	last_time = ktime_to_ms(ktime_get());
 }
 
@@ -625,6 +611,11 @@ static int min_cpus_notify(struct notifier_block *nb, unsigned long n, void *p)
 	mutex_lock(tegra3_cpu_lock);
 
 	if ((n >= 2) && is_lp_cluster()) {
+		/* make sure cpu rate is within g-mode range before switching */
+		unsigned int speed = max(
+			tegra_getspeed(0), clk_get_min_rate(cpu_g_clk) / 1000);
+		tegra_update_cpu_speed(speed);
+
 		if (!clk_set_parent(cpu_clk, cpu_g_clk)) {
 			CPU_DEBUG_PRINTK(CPU_DEBUG_HOTPLUG,
 					 " leave LPCPU (%s)", __func__);
diff --git a/arch/arm/mach-tegra/cpuidle-t3.c b/arch/arm/mach-tegra/cpuidle-t3.c
index 0e7d672..4c8e48f 100644
--- a/arch/arm/mach-tegra/cpuidle-t3.c
+++ b/arch/arm/mach-tegra/cpuidle-t3.c
@@ -76,6 +76,8 @@ module_param(lp2_n_in_idle, bool, 0644);
 static struct clk *cpu_clk_for_dvfs;
 static struct clk *twd_clk;
 
+static int lp2_exit_latencies[5];
+
 static struct {
 	unsigned int cpu_ready_count[5];
 	unsigned int tear_down_count[5];
@@ -149,6 +151,11 @@ bool tegra3_lp2_is_allowed(struct cpuidle_device *dev,
 	}
 
 	request = ktime_to_us(tick_nohz_get_sleep_length());
+	if (state->exit_latency != lp2_exit_latencies[cpu_number(dev->cpu)]) {
+		/* possible on the 1st entry after cluster switch*/
+		state->exit_latency = lp2_exit_latencies[cpu_number(dev->cpu)];
+		tegra_lp2_update_target_residency(state);
+	}
 	if (request < state->target_residency) {
 		/* Not enough time left to enter LP2 */
 		return false;
@@ -224,7 +231,8 @@ static void tegra3_idle_enter_lp2_cpu_0(struct cpuidle_device *dev,
 #endif
 
 	if (request > state->target_residency) {
-		s64 sleep_time = request - tegra_lp2_exit_latency;
+		s64 sleep_time = request -
+			lp2_exit_latencies[cpu_number(dev->cpu)];
 
 		bin = time_to_bin((u32)request / 1000);
 		idle_stats.tear_down_count[cpu_number(dev->cpu)]++;
@@ -274,9 +282,11 @@ static void tegra3_idle_enter_lp2_cpu_0(struct cpuidle_device *dev,
 		 */
 		int offset = ktime_to_us(ktime_sub(exit_time, entry_time))
 			- request;
-		int latency = tegra_lp2_exit_latency + offset / 16;
+		int latency = lp2_exit_latencies[cpu_number(dev->cpu)] +
+			offset / 16;
 		latency = clamp(latency, 0, 10000);
-		tegra_lp2_exit_latency = latency;
+		lp2_exit_latencies[cpu_number(dev->cpu)] = latency;
+		state->exit_latency = latency;		/* for idle governor */
 		smp_wmb();
 
 		idle_stats.lp2_completed_count++;
@@ -296,16 +306,26 @@ static void tegra3_idle_enter_lp2_cpu_n(struct cpuidle_device *dev,
 			   struct cpuidle_state *state, s64 request)
 {
 #ifdef CONFIG_SMP
-	ktime_t entery_time;
-	u32 twd_cnt;
-	u32 twd_ctrl = readl(twd_base + TWD_TIMER_CONTROL);
-	unsigned long twd_rate = clk_get_rate(twd_clk);
+	s64 sleep_time;
+	ktime_t entry_time;
+	struct tegra_twd_context twd_context;
 	struct tick_sched *ts = tick_get_tick_sched(dev->cpu);
+	bool sleep_completed = false;
 
-	if ((twd_ctrl & TWD_TIMER_CONTROL_ENABLE) &&
-	    (twd_ctrl & TWD_TIMER_CONTROL_IT_ENABLE)) {
-		twd_cnt = readl(twd_base + TWD_TIMER_COUNTER);
-		request = div_u64((u64)twd_cnt * 1000000, twd_rate);
+	if (!tegra_twd_get_state(&twd_context)) {
+		unsigned long twd_rate = clk_get_rate(twd_clk);
+
+		if ((twd_context.twd_ctrl & TWD_TIMER_CONTROL_ENABLE) &&
+		    (twd_context.twd_ctrl & TWD_TIMER_CONTROL_IT_ENABLE)) {
+			request = div_u64((u64)twd_context.twd_cnt * 1000000,
+					  twd_rate);
+			if (request >= state->target_residency) {
+				twd_context.twd_cnt -= state->exit_latency *
+					(twd_rate / 1000000);
+				writel(twd_context.twd_cnt,
+					twd_base + TWD_TIMER_COUNTER);
+			}
+		}
 	}
 
 	if (request < tegra_lp2_exit_latency ||
@@ -321,22 +341,38 @@ static void tegra3_idle_enter_lp2_cpu_n(struct cpuidle_device *dev,
 
 	trace_power_start(POWER_CSTATE, 2, dev->cpu);
 
-	entery_time = ktime_get();
+	entry_time = ktime_get();
 
 	/* Save time this CPU must be awakened by. */
-	tegra_cpu_wake_by_time[dev->cpu] = ktime_to_us(ktime_get()) + request;
+	tegra_cpu_wake_by_time[dev->cpu] = ktime_to_us(entry_time) + request;
 	smp_wmb();
 
 	tegra3_sleep_cpu_secondary(PLAT_PHYS_OFFSET - PAGE_OFFSET);
 
 	tegra_cpu_wake_by_time[dev->cpu] = LLONG_MAX;
+	if (!tegra_twd_get_state(&twd_context))
+		sleep_completed = (twd_context.twd_cnt == 0);
 
-	idle_stats.in_lp2_time[cpu_number(dev->cpu)] +=
-		ktime_to_us(ktime_sub(ktime_get(), entery_time));
+	sleep_time = ktime_to_us(ktime_sub(ktime_get(), entry_time));
+	idle_stats.in_lp2_time[cpu_number(dev->cpu)] += sleep_time;
+	if (sleep_completed) {
+		/*
+		 * Stayed in LP2 for the full time until timer expires,
+		 * adjust the exit latency based on measurement
+		 */
+		int offset = sleep_time - request;
+		int latency = lp2_exit_latencies[cpu_number(dev->cpu)] +
+			offset / 16;
+		latency = clamp(latency, 0, 10000);
+		lp2_exit_latencies[cpu_number(dev->cpu)] = latency;
+		state->exit_latency = latency;		/* for idle governor */
+		smp_wmb();
+	}
 
 	/* move from driver/cpuidle/cpuidle.c */
 	dev->states[1].usage++;
-	dev->states[1].time += ktime_to_us(ktime_sub(ktime_get(), entery_time));
+	dev->states[1].time += ktime_to_us(ktime_sub(ktime_get(), entry_time));
+
 #endif
 }
 
@@ -359,8 +395,14 @@ void tegra3_idle_lp2(struct cpuidle_device *dev,
 
 int tegra3_cpudile_init_soc(void)
 {
+	int i;
+
 	cpu_clk_for_dvfs = tegra_get_clock_by_name("cpu_g");
 	twd_clk = tegra_get_clock_by_name("twd");
+
+	for (i = 0; i < ARRAY_SIZE(lp2_exit_latencies); i++)
+		lp2_exit_latencies[i] = tegra_lp2_exit_latency;
+
 	return 0;
 }
 
diff --git a/arch/arm/mach-tegra/cpuidle.c b/arch/arm/mach-tegra/cpuidle.c
index a328af7..843f3f8 100644
--- a/arch/arm/mach-tegra/cpuidle.c
+++ b/arch/arm/mach-tegra/cpuidle.c
@@ -99,6 +99,14 @@ void tegra_lp2_in_idle(bool enable)
 	}
 }
 
+void tegra_lp2_update_target_residency(struct cpuidle_state *state)
+{
+	state->target_residency = state->exit_latency +
+		tegra_lp2_power_off_time;
+	if (state->target_residency < tegra_lp2_min_residency)
+		state->target_residency = tegra_lp2_min_residency;
+}
+
 static int tegra_idle_enter_lp2(struct cpuidle_device *dev,
 	struct cpuidle_state *state)
 {
@@ -127,11 +135,8 @@ static int tegra_idle_enter_lp2(struct cpuidle_device *dev,
 
 	/* Update LP2 latency provided no fall back to LP3 */
 	if (state == dev->last_state) {
-		state->exit_latency = tegra_lp2_exit_latency;
-		state->target_residency = tegra_lp2_exit_latency +
-			tegra_lp2_power_off_time;
-		if (state->target_residency < tegra_lp2_min_residency)
-			state->target_residency = tegra_lp2_min_residency;
+		tegra_lp2_set_global_latency(state);
+		tegra_lp2_update_target_residency(state);
 	}
 	tegra_cpu_idle_stats_lp2_time(dev->cpu, us);
 
diff --git a/arch/arm/mach-tegra/cpuidle.h b/arch/arm/mach-tegra/cpuidle.h
index 12a29ff..ce6eab9 100644
--- a/arch/arm/mach-tegra/cpuidle.h
+++ b/arch/arm/mach-tegra/cpuidle.h
@@ -98,6 +98,16 @@ static inline bool tegra_lp2_is_allowed(struct cpuidle_device *dev,
 #endif
 }
 
+static inline void tegra_lp2_set_global_latency(struct cpuidle_state *state)
+{
+#ifdef CONFIG_ARCH_TEGRA_2x_SOC
+	state->exit_latency = tegra_lp2_exit_latency;
+#endif
+	/* Tegra3 does not use global exit latency */
+}
+
+void tegra_lp2_update_target_residency(struct cpuidle_state *state);
+
 #ifdef CONFIG_DEBUG_FS
 static inline int tegra_lp2_debug_show(struct seq_file *s, void *data)
 {
diff --git a/arch/arm/mach-tegra/cpuplug.lib b/arch/arm/mach-tegra/cpuplug.lib
new file mode 100644
index 0000000..6b1744a
Binary files /dev/null and b/arch/arm/mach-tegra/cpuplug.lib differ
diff --git a/arch/arm/mach-tegra/gpio.c b/arch/arm/mach-tegra/gpio.c
index b6b3df8..43a38de 100644
--- a/arch/arm/mach-tegra/gpio.c
+++ b/arch/arm/mach-tegra/gpio.c
@@ -38,6 +38,7 @@
 #include "gpio-names.h"
 #include "htc-gpio.h"
 #include <mach/board_htc.h>
+#include <asm/mach-types.h>
 
 #define GPIO_BANK(x)		((x) >> 5)
 #define GPIO_PORT(x)		(((x) >> 3) & 0x3)
@@ -362,12 +363,12 @@ static void tegra_gpio_resume(void)
 			__raw_writel(bank->int_enb[p], GPIO_INT_ENB(gpio));
 		}
 	}
-#if defined(CONFIG_MACH_ENDEAVORTD)
-	int projectPhase = htc_get_pcbid_info();
-	if (projectPhase == PROJECT_PHASE_XC){
-		enr_xc_no_owner_gpio_resume();
+	if (machine_is_endeavortd()) {
+		int projectPhase = htc_get_pcbid_info();
+		if (projectPhase == PROJECT_PHASE_XC){
+			enr_xc_no_owner_gpio_resume();
+		}
 	}
-#endif
 	local_irq_restore(flags);
 }
 
@@ -413,7 +414,7 @@ void gpio_dump(void)
 
 		const char** expected_gpio = enr_td_suspend_gpio_config_xc;
 
-#if defined(CONFIG_MACH_VERTEXF)
+		if (machine_is_vertexfp()) {
 			int projectPhase = htc_get_pcbid_info();
 
 			if (projectPhase == PROJECT_PHASE_XA) /* EVT XA */
@@ -424,8 +425,8 @@ void gpio_dump(void)
 				expected_gpio = quo_suspend_gpio_config_xc;
 			else if (projectPhase >= PROJECT_PHASE_XD)
 				expected_gpio = quo_suspend_gpio_config_xd;
+		}
 
-#endif
 
 		for (p = 0; p < ARRAY_SIZE(bank->oe); p++) {
 			unsigned int gpio = (b<<5) | (p<<3);
diff --git a/arch/arm/mach-tegra/htc-gpio.c b/arch/arm/mach-tegra/htc-gpio.c
index a01669f..d334838 100644
--- a/arch/arm/mach-tegra/htc-gpio.c
+++ b/arch/arm/mach-tegra/htc-gpio.c
@@ -2451,6 +2451,72 @@ void enr_td_xc_unused_gpio_init(void)
 	GPIO_SETUP(N1, OUTPUT_LOW);
 }
 
+void enr_td_xd_unused_gpio_init(void)
+{
+	DEBUG_ENTRY();
+	/*
+	 * the "NC" in ENR#TD GPIO table
+	 */
+	GPIO_SETUP(A0, OUTPUT_LOW);
+	GPIO_SETUP(D0, OUTPUT_LOW);
+	GPIO_SETUP(D3, OUTPUT_LOW);
+	GPIO_SETUP(D4, OUTPUT_LOW);
+	GPIO_SETUP(H1, OUTPUT_LOW);
+	GPIO_SETUP(H2, OUTPUT_LOW);
+	GPIO_SETUP(H4, OUTPUT_LOW);
+	GPIO_SETUP(H5, OUTPUT_LOW);
+	GPIO_SETUP(H6, OUTPUT_LOW);
+	GPIO_SETUP(H7, OUTPUT_LOW);
+	GPIO_SETUP(I2, OUTPUT_LOW);
+	GPIO_SETUP(I3, OUTPUT_LOW);
+	GPIO_SETUP(I4, OUTPUT_LOW);
+	GPIO_SETUP(I7, OUTPUT_LOW);
+	GPIO_SETUP(J3, OUTPUT_LOW);
+	GPIO_SETUP(J4, OUTPUT_LOW);
+	GPIO_SETUP(K3, OUTPUT_LOW);
+	GPIO_SETUP(K4, OUTPUT_LOW);
+	GPIO_SETUP(K5, OUTPUT_LOW);
+	GPIO_SETUP(K6, OUTPUT_LOW);
+	GPIO_SETUP(N4, OUTPUT_LOW);
+	GPIO_SETUP(O0, OUTPUT_LOW);
+	GPIO_SETUP(O3, OUTPUT_LOW);
+	GPIO_SETUP(O6, OUTPUT_LOW);
+	GPIO_SETUP(O7, OUTPUT_LOW);
+	GPIO_SETUP(P0, OUTPUT_LOW);
+	GPIO_SETUP(P2, OUTPUT_LOW);
+	GPIO_SETUP(P3, OUTPUT_LOW);
+	GPIO_SETUP(Q0, OUTPUT_LOW);
+	GPIO_SETUP(Q1, OUTPUT_LOW);
+	GPIO_SETUP(Q2, OUTPUT_LOW);
+	GPIO_SETUP(Q3, OUTPUT_LOW);
+	GPIO_SETUP(Q4, OUTPUT_LOW);
+	GPIO_SETUP(Q5, OUTPUT_LOW);
+	GPIO_SETUP(R5, OUTPUT_LOW);
+	GPIO_SETUP(S1, OUTPUT_LOW);
+	GPIO_SETUP(V3, OUTPUT_LOW);
+	GPIO_SETUP(V7, OUTPUT_LOW);
+	GPIO_SETUP(Y7, OUTPUT_LOW);
+	GPIO_SETUP(Z1, OUTPUT_LOW);
+	GPIO_SETUP(Z3, OUTPUT_LOW);
+	GPIO_SETUP(Z4, OUTPUT_LOW);
+	GPIO_SETUP(EE0, OUTPUT_LOW);
+	GPIO_SETUP(EE3, OUTPUT_LOW);
+
+	GPIO_SETUP(G0, INPUT_NO_PULL);
+	GPIO_SETUP(G1, INPUT_NO_PULL);
+	GPIO_SETUP(G2, INPUT_NO_PULL);
+	GPIO_SETUP(G3, INPUT_NO_PULL);
+	GPIO_SETUP(G4, INPUT_NO_PULL);
+	GPIO_SETUP(G5, INPUT_NO_PULL);
+	GPIO_SETUP(G6, INPUT_NO_PULL);
+	GPIO_SETUP(G7, INPUT_NO_PULL);
+	GPIO_SETUP(I0, INPUT_NO_PULL);
+	GPIO_SETUP(I1, INPUT_NO_PULL);
+	GPIO_SETUP(K0, INPUT_NO_PULL);
+	GPIO_SETUP(K1, INPUT_NO_PULL);
+	GPIO_SETUP(Z5, OUTPUT_LOW);
+}
+
 void enr_xc_unused_gpio_init(void)
 {
 	DEBUG_ENTRY();
diff --git a/arch/arm/mach-tegra/htc-gpio.h b/arch/arm/mach-tegra/htc-gpio.h
index 98f93b5..3eb2ad6 100644
--- a/arch/arm/mach-tegra/htc-gpio.h
+++ b/arch/arm/mach-tegra/htc-gpio.h
@@ -20,6 +20,7 @@ void ble_xa_unused_gpio_init(void);
 void ble_xb_unused_gpio_init(void);
 void ble_xb_no_owner_gpio_init(void);
 void enr_td_xc_no_owner_gpio_init(void);
+void enr_td_xd_unused_gpio_init(void);
 void enr_u_xc_no_owner_gpio_init(void);
 void enr_u_xd_no_owner_gpio_init(void);
 void enr_u_xe_no_owner_gpio_init(void);
diff --git a/arch/arm/mach-tegra/htc_battery_core.c b/arch/arm/mach-tegra/htc_battery_core.c
index 15dcf41..27ae96f 100644
--- a/arch/arm/mach-tegra/htc_battery_core.c
+++ b/arch/arm/mach-tegra/htc_battery_core.c
@@ -208,6 +208,13 @@ static ssize_t htc_battery_show_batt_attr(struct device *dev,
 	return battery_core_info.func.func_show_batt_attr(attr, buf);
 }
 
+static ssize_t htc_battery_show_batt_power_meter(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return battery_core_info.func.func_show_batt_power_meter(attr, buf);
+}
+
 static ssize_t htc_battery_set_delta(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t count)
@@ -401,6 +408,7 @@ static struct device_attribute htc_battery_attrs[] = {
 	HTC_BATTERY_ATTR(batt_state),
 
 	__ATTR(batt_attr_text, S_IRUGO, htc_battery_show_batt_attr, NULL),
+	__ATTR(batt_power_meter, S_IRUGO, htc_battery_show_batt_power_meter, NULL),
 };
 
 static struct device_attribute htc_set_delta_attrs[] = {
@@ -689,6 +697,7 @@ int htc_battery_core_update(void)
 		is_send_batt_uevent = 1;
 	}
 
+#if 0	/* note: old mechanism */
 	/* To make sure that device is under over loading scenario, accumulate
 	   variable battery_over_loading only when device has been under charging
 	   and level is decreased. */
@@ -699,6 +708,7 @@ int htc_battery_core_update(void)
 		else
 			battery_over_loading = 0;
 	}
+#endif
 
 	memcpy(&battery_core_info.rep, &new_batt_info_rep, sizeof(struct battery_info_reply));
 #if 0
@@ -720,20 +730,26 @@ int htc_battery_core_update(void)
 		battery_core_info.htc_charge_full = 0;
 	else {
 		if (battery_core_info.htc_charge_full &&
-			(battery_core_info.rep.full_level == 100))
-			battery_core_info.htc_charge_full = 1;
-		else {
+			(battery_core_info.rep.full_level == 100)) {
+			if (battery_core_info.rep.level > 98) {
+				battery_core_info.htc_charge_full = 1;
+				battery_core_info.rep.level = 100;
+			} else
+				battery_core_info.htc_charge_full = 0;
+		} else {
 			if (battery_core_info.rep.level == 100)
 				battery_core_info.htc_charge_full = 1;
 			else
 				battery_core_info.htc_charge_full = 0;
 		}
 
+#if 0	/* note: old mechanism */
 		/* Clear htc_charge_full while over loading is happened. */
 		if (battery_over_loading >= 2) {
 			battery_core_info.htc_charge_full = 0;
 			battery_over_loading = 0;
 		}
+#endif
 	}
 
 	battery_core_info.update_time = jiffies;
@@ -787,6 +803,9 @@ int htc_battery_core_register(struct device *dev,
 	if (htc_battery->func_show_batt_attr)
 		battery_core_info.func.func_show_batt_attr =
 					htc_battery->func_show_batt_attr;
+	if (htc_battery->func_show_batt_power_meter)
+		battery_core_info.func.func_show_batt_power_meter =
+					htc_battery->func_show_batt_power_meter;
 	if (htc_battery->func_get_battery_info)
 		battery_core_info.func.func_get_battery_info =
 					htc_battery->func_get_battery_info;
@@ -839,7 +858,9 @@ int htc_battery_core_register(struct device *dev,
 	/* zero means battey info is not ready */
 	battery_core_info.rep.batt_state = 0;
 
+#if 0	/* note: old mechanism */
 	battery_over_loading = 0;
+#endif
 
 	return 0;
 }
diff --git a/arch/arm/mach-tegra/htc_battery_tps80032.c b/arch/arm/mach-tegra/htc_battery_tps80032.c
index f19e03c..55b6370 100644
--- a/arch/arm/mach-tegra/htc_battery_tps80032.c
+++ b/arch/arm/mach-tegra/htc_battery_tps80032.c
@@ -38,6 +38,7 @@
 #include <linux/delay.h>
 #include <mach/board_htc.h>
 #include <mach/restart.h>
+#include <linux/earlysuspend.h>
 
 /* used for debug if function called */
 #define FUNC_CALL_CHECK 0
@@ -46,6 +47,7 @@
 #define WK_IS_CABLE_IN 1
 #define TEST_ADC_TIMING 0
 #define WRITE_PWR_SAVE_DISABLE	0x1000
+#define ALL_AC_CHARGING		0x4000000
 
 #define BATT_LOG(fmt, ...) do { \
 	struct timespec ts; \
@@ -82,6 +84,7 @@
 
 #define BATT_SUSPEND_CHECK_TIME			3600
 #define BATT_SUSPEND_PHONE_CALL_CHECK_TIME	300
+#define BATT_LATE_RESUME_CHECK_TIME		300
 #define BATT_TIMER_CHECK_TIME			180
 #define FIRST_ADC_READ_DELAY			5
 
@@ -92,11 +95,14 @@
 
 #define MV_TO_ADC_BITS(batt_vol) ((batt_vol) * 4095 / 1250)
 
+#define QB_LPB_SHUTDOWN_VOLTAGE 3100
+
 enum {
 	ATTR_REBOOT_LEVEL = 0,
 	ATTR_HBOOT_VOLT,
 	ATTR_HBOOT_CURR,
 	ATTR_HBOOT_TEMP,
+	ATTR_QB_REASON,
 };
 
 #if WK_MBAT_IN
@@ -127,6 +133,7 @@ struct htc_battery_info {
 
 	struct wake_lock vbus_wake_lock;
 	char debug_log[DEBUG_LOG_LENGTH];
+	char power_meter[POWER_METER_LENGTH];
 
 	struct battery_info_reply rep;
 
@@ -144,6 +151,9 @@ struct htc_battery_info {
 	int is_cable_in;
 #endif
 	int online;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
 
 };
 static struct htc_battery_info htc_batt_info;
@@ -185,6 +195,8 @@ static struct tps65200_chg_int_notifier tps_int_notifier = {
 static ssize_t tps80032_first_batt_show_attributes(struct device *dev,
 					struct device_attribute *attr,
 					char *buf);
+static int tps80032_qb_store_attributes(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
 
 static unsigned long hboot_batt_volt = TPS80032_GPADC_FAKE_VALUE;
 int __init batt_voltage_get(char *s)
@@ -230,7 +242,7 @@ static void tps_int_notifier_func(int int_reg, int value)
 	}
 }
 
-#if 0	/* fixme: not used now*/
+#if 0  /* fixme: not require this now */
 static int batt_alarm_config(unsigned long threshold)
 {
 	int rc = 0;
@@ -318,7 +330,11 @@ static void usb_status_notifier_func(int online)
 	switch (online) {
 	case CONNECT_TYPE_USB:
 		BATT_LOG("cable USB");
-		htc_batt_info.rep.charging_source = CHARGER_USB;
+		if ( !!(get_kernel_flag() & ALL_AC_CHARGING) ) {
+			BATT_LOG("Debug flag is set to force AC charging, fake as AC");
+			htc_batt_info.rep.charging_source = CHARGER_AC;
+		} else
+			htc_batt_info.rep.charging_source = CHARGER_USB;
 #if WK_IS_CABLE_IN
 		htc_batt_info.is_cable_in = 1;
 #endif
@@ -337,15 +353,13 @@ static void usb_status_notifier_func(int online)
 		htc_batt_info.is_cable_in = 1;
 #endif
 		break;
-#if 0	// fixme: no internal burst
 	case CONNECT_TYPE_INTERNAL:
 		BATT_LOG("delivers power to VBUS from battery");
 		htc_battery_set_charging(POWER_SUPPLY_ENABLE_INTERNAL);
 		mutex_unlock(&htc_batt_info.info_lock);
 		return;
-#endif
 	case CONNECT_TYPE_NONE:
-		if ( !!(get_kernel_flag() & WRITE_PWR_SAVE_DISABLE) ) {
+		if ( !!(get_kernel_flag() & WRITE_PWR_SAVE_DISABLE && !(get_kernel_flag() & ALL_AC_CHARGING)) ) {
 #if WK_IS_CABLE_IN
 			htc_batt_info.is_cable_in = 0;
 #endif
@@ -448,6 +462,18 @@ static ssize_t htc_battery_show_batt_attr(struct device_attribute *attr,
 	return len;
 }
 
+static ssize_t htc_battery_show_batt_power_meter(struct device_attribute *attr,
+					char *buf)
+{
+	int len = 0;
+
+	CHECK_LOG();
+
+	len += scnprintf(buf + len, PAGE_SIZE - len,
+			"%s", htc_batt_info.power_meter);
+	return len;
+}
+
 static int htc_batt_open(struct inode *inode, struct file *filp)
 {
 	int ret = 0;
@@ -654,6 +680,8 @@ static void batt_check_alarm_handler(struct alarm *alarm)
 static void batt_work_func(struct work_struct *work)
 {
 	int rc = 0;
+	int notify_cable_gone = 0;
+	int has_vbus;
 	char total_time[32];
 	char battery_alarm[16];
 	char *envp[] = { total_time, battery_alarm, NULL };
@@ -665,8 +693,8 @@ static void batt_work_func(struct work_struct *work)
 		BATT_ERR("Read ADC failed!");
 
 	/*read tps80032 VBUS_DETECT state*/
-	rc = tps80032_read_vbus_detection();
-	BATT_LOG("tps80032 VBUS_DETECT:%d OPA_MODE:%d BOOST_HW_PWR:%d",rc,
+	has_vbus = tps80032_read_vbus_detection();
+	BATT_LOG("tps80032 VBUS_DETECT:%d OPA_MODE:%d BOOST_HW_PWR:%d", has_vbus,
 			tps80032_read_opa_mode(),tps80032_read_boots_hw_pwr());
 
 	scnprintf(total_time, sizeof(total_time), "TOTAL_TIME=%lu",
@@ -681,6 +709,20 @@ static void batt_work_func(struct work_struct *work)
 	htc_batt_timer.batt_alarm_status = 0;
 	batt_set_check_timer(htc_batt_timer.time_out);
 	wake_unlock(&htc_batt_timer.battery_lock);
+
+	if (!has_vbus) {
+		/* vbus gone, check if need to send no cable event to battery  */
+		mutex_lock(&htc_batt_info.info_lock);
+		if (htc_batt_info.online != CONNECT_TYPE_NONE)
+			notify_cable_gone = 1;
+		mutex_unlock(&htc_batt_info.info_lock);
+
+		if (!!notify_cable_gone) {
+			BATT_LOG("VBUS is not present, notify cable gone!!");
+			usb_status_notifier_func(CONNECT_TYPE_NONE);
+		}
+	}
+
 	if (is_alarm_not_work == 1) {
 		/* force wake lock once when charging*/
 		mutex_lock(&htc_batt_info.info_lock);
@@ -761,6 +803,8 @@ static void battery_power_story_board(void)
 }
 #endif
 
+static unsigned int quickboot_low_power_boot;
+
 static long htc_batt_ioctl(struct file *filp,
 			unsigned int cmd, unsigned long arg)
 {
@@ -844,6 +888,16 @@ static long htc_batt_ioctl(struct file *filp,
 			htc_batt_info.rep.level = 2;
 		}
 #endif
+		if (quickboot_low_power_boot && htc_batt_info.rep.level >= 4)
+			quickboot_low_power_boot = 0;
+
+		if (quickboot_low_power_boot &&
+			htc_batt_info.rep.batt_vol <= QB_LPB_SHUTDOWN_VOLTAGE) {
+			BATT_LOG("QuickBoot once, and voltage lower than %d.  "
+				"Shutdown System\n", QB_LPB_SHUTDOWN_VOLTAGE);
+			mutex_unlock(&htc_batt_info.info_lock);
+			kernel_power_off();
+		}
 
 		battery_power_story_board();
 
@@ -863,7 +917,7 @@ static long htc_batt_ioctl(struct file *filp,
 		}
 		break;
 	case HTC_BATT_IOCTL_SET_VOLTAGE_ALARM: {
-#if 0	/* fixme: not used now*/
+#if 0  /* fixme: not require this now */
 		struct battery_vol_alarm alarm_data;
 
 		if (copy_from_user(&alarm_data, (void *)arg,
@@ -896,6 +950,13 @@ static long htc_batt_ioctl(struct file *filp,
 		BATT_LOG("Set alarm timer flag:%u", flag);
 		break;
 	}
+	case HTC_BATT_IOCTL_BATT_POWER_METER:
+		if (copy_from_user(htc_batt_info.power_meter, (void *)arg,
+					POWER_METER_LENGTH)) {
+			BATT_ERR("copy power meter from user failed!");
+			ret = -EFAULT;
+		}
+		break;
 	default:
 		BATT_ERR("%s: no matched ioctl cmd", __func__);
 		break;
@@ -962,6 +1023,25 @@ static struct kobj_type htc_batt_ktype = {
 	.release = htc_batt_kobject_release,
 };
 
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+static void htc_battery_late_resume(struct early_suspend *h)
+{
+	CHECK_LOG();
+
+	htc_batt_timer.total_time_ms += (jiffies -
+			htc_batt_timer.batt_system_jiffies) * MSEC_PER_SEC / HZ;
+	htc_batt_timer.batt_system_jiffies = jiffies;
+
+	if (htc_batt_timer.total_time_ms >= BATT_LATE_RESUME_CHECK_TIME * MSEC_PER_SEC) {
+		BATT_LOG("late resume with check time up, update battery level");
+		del_timer_sync(&htc_batt_timer.batt_timer);
+		cancel_work_sync(&htc_batt_timer.batt_work);
+		wake_lock(&htc_batt_timer.battery_lock);
+		queue_work(htc_batt_timer.batt_wq, &htc_batt_timer.batt_work);
+	}
+}
+#endif
+
 static unsigned long target_interval_ms = 0;
 static int htc_battery_prepare(struct device *dev)
 {
@@ -1121,6 +1201,7 @@ static struct device_attribute tps80032_batt_attrs[] = {
 	__ATTR(hboot_volt, S_IRUGO, tps80032_first_batt_show_attributes, NULL),
 	__ATTR(hboot_curr, S_IRUGO, tps80032_first_batt_show_attributes, NULL),
 	__ATTR(hboot_temp, S_IRUGO, tps80032_first_batt_show_attributes, NULL),
+	__ATTR(quickboot_low_power_boot, S_IWUSR, NULL, tps80032_qb_store_attributes),
 	};
 
 static ssize_t tps80032_first_batt_show_attributes(struct device *dev,
@@ -1155,6 +1236,15 @@ static ssize_t tps80032_first_batt_show_attributes(struct device *dev,
 	return i;
 }
 
+static int tps80032_qb_store_attributes(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	quickboot_low_power_boot = sysfs_streq(buf, "0") ? 0 : 1;
+	pr_info("[BATT] set quickboot_low_power_boot %d", quickboot_low_power_boot);
+	return size;
+}
+
+
 static int tps80032_batt_create_attrs(struct device *dev)
 {
 	int i = 0, rc = 0;
@@ -1209,6 +1299,7 @@ static int htc_battery_probe(struct platform_device *pdev)
 		irq_set_irq_wake(pdata->gpio_mbat_in, 1);
 
 	htc_battery_core_ptr->func_show_batt_attr = htc_battery_show_batt_attr;
+	htc_battery_core_ptr->func_show_batt_power_meter = htc_battery_show_batt_power_meter;
 	htc_battery_core_ptr->func_get_battery_info = htc_batt_get_battery_info;
 	htc_battery_core_ptr->func_charger_control = htc_batt_charger_control;
 	htc_battery_core_ptr->func_set_full_level = htc_batt_set_full_level;
@@ -1284,6 +1375,12 @@ static int htc_battery_probe(struct platform_device *pdev)
 
 	tps80032_vsys_alarm_register_notifier(&battery_alarm_notifier);
 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	htc_batt_info.early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING;
+	htc_batt_info.early_suspend.resume = htc_battery_late_resume;
+	register_early_suspend(&htc_batt_info.early_suspend);
+#endif
+
 #if 0	/* fixme: use a delayed work to get better timming */
 	rc = htc_batt_get_battery_adc();
 	if (rc) {
diff --git a/arch/arm/mach-tegra/htc_headset_gpio.c b/arch/arm/mach-tegra/htc_headset_gpio.c
index f0c474c..56e7737 100644
--- a/arch/arm/mach-tegra/htc_headset_gpio.c
+++ b/arch/arm/mach-tegra/htc_headset_gpio.c
@@ -345,15 +345,13 @@ static int htc_headset_gpio_probe(struct platform_device *pdev)
 	hi->hpin_debounce = HS_JIFFIES_ZERO;
 	hi->key_irq_type = IRQF_TRIGGER_LOW;
 	hi->headset_state = 0;
+	last_key_jiffies = jiffies;
 
-	if ((hi->pdata.eng_cfg == HS_QUO_F_U))
-	{
-		/* HW power connet cable issue */
-		/* EVT XB WORKAROUND Only */
-		if (PROJECT_PHASE_XB == htc_get_pcbid_info()) {
-			HS_ERR("=====FORCED RETURN!!!!!=====");
-			return -ENOMEM;
-		}
+	/* HW power connet cable issue */
+	/* EVT XB WORKAROUND Only */
+	if (hi->pdata.eng_cfg == HS_QUO_F_U_XB) {
+		HS_ERR("=====FORCED RETURN!!!!!=====");
+		return -ENOMEM;
 	}
 
 	detect_wq = create_workqueue("HS_GPIO_DETECT");
diff --git a/arch/arm/mach-tegra/htc_headset_mgr.c b/arch/arm/mach-tegra/htc_headset_mgr.c
index ff66635..7daa8bd 100644
--- a/arch/arm/mach-tegra/htc_headset_mgr.c
+++ b/arch/arm/mach-tegra/htc_headset_mgr.c
@@ -22,6 +22,7 @@
 #include <linux/gpio_event.h>
 #include <linux/rtc.h>
 #include <linux/slab.h>
+#include "devices.h"
 
 #include <mach/htc_headset_mgr.h>
 #include <linux/delay.h>
@@ -69,6 +70,12 @@ struct button_work {
 
 static struct htc_headset_mgr_info *hi;
 static struct hs_notifier_func hs_mgr_notifier;
+
+static int	hpin_report = 0,
+		hpin_bounce = 0,
+		key_report = 0,
+		key_bounce = 0;
+
 static struct regulator *regulator;
 static struct button_work *key_event[HS_BUTTON_EVENT_QUEUE];
 static int key_event_flag;
@@ -138,6 +145,7 @@ void hs_notify_hpin_irq(void)
 {
 	hi->hpin_jiffies = jiffies;
 	HS_LOG("HPIN IRQ");
+	hpin_bounce++;
 }
 
 struct class *hs_get_attribute_class(void)
@@ -323,6 +331,7 @@ void button_pressed(int type)
 	atomic_set(&hi->btn_state, type);
 	input_report_key(hi->input, type, 1);
 	input_sync(hi->input);
+	key_report++;
 }
 
 void button_released(int type)
@@ -331,6 +340,7 @@ void button_released(int type)
 	atomic_set(&hi->btn_state, 0);
 	input_report_key(hi->input, type, 0);
 	input_sync(hi->input);
+	key_report++;
 }
 
 void headset_button_event(int is_press, int type)
@@ -600,6 +610,7 @@ static void mic_detect_work_func(struct work_struct *work)
 	if (new_state != old_state) {
 		hi->hs_35mm_type = mic;
 		switch_set_state(&hi->sdev, new_state);
+		hpin_report++;
 	} else
 		HS_LOG("MIC status has not changed");
 
@@ -616,6 +627,7 @@ static void enable_1wire_tx()
 		gpio_free(hi->pdata.level_1wire_gpio);
 	}
 	tegra_gpio_enable(hi->pdata.rx_1wire_gpio);
+//	tegra_gpio_disable(hi->pdata.rx_1wire_gpio);
 	tegra_gpio_disable(hi->pdata.tx_1wire_gpio);
 
 	return;
@@ -658,6 +670,7 @@ int button_1wire_work_func()
 	char a_buf[20];
 	int count = 0;
 	int r,bflag;
+	int key = 99;
 
 	while(1){
 		bflag=0;
@@ -667,22 +680,24 @@ int button_1wire_work_func()
 			HS_LOG("Read %d bytes, count:%d, %s",r,count,a_buf);
 			for(cnt = 0; cnt < r; cnt++){
 				HS_LOG("0x%x \n", (int) a_buf[cnt]);
-				if ((int)a_buf[cnt]==49){
-					hi->key_level_flag = 3;
+				if ((int)a_buf[cnt]==123){
+					key = 3;
 					bflag=1;
 				}
-				if ((int)a_buf[cnt]==50){
-					hi->key_level_flag = 1;
+				if ((int)a_buf[cnt]==125){
+					key = 1;
 					bflag=1;
 				}
-				if ((int)a_buf[cnt]==51){
-					hi->key_level_flag = 2;
+				if ((int)a_buf[cnt]==126){
+					key = 2;
 					bflag=1;
 				}
-				if ((int)a_buf[cnt]==52)
+				if ((int)a_buf[cnt]==127){
+					key = 0;
 					bflag=1;
 			}
 		}
+		}
 		count++;
 
 		if(bflag == 1 || count == CHECK_COUNT)
@@ -690,7 +705,7 @@ int button_1wire_work_func()
 
 		msleep(1);
 	}
-	return 1;
+	return key;
 }
 
 static void button_35mm_work_func(struct work_struct *work)
@@ -705,10 +720,6 @@ static void button_35mm_work_func(struct work_struct *work)
 	works = container_of(work, struct button_work, key_work.work);
 	hi->key_level_flag = works->key_code;
 
-/*run one-wire button work function if the project support one-wire detection*/
-	if(hi->detect_type == HEADSET_1WIRE && hi->pdata.enable_1wire)
-		button_1wire_work_func();
-
 	if (hi->hs_35mm_type == HEADSET_UNPLUG &&
 	    hi->h2w_35mm_type == HEADSET_UNPLUG) {
 //		kfree(works);
@@ -835,7 +846,7 @@ static void remove_detect_work_func(struct work_struct *work)
 	state &= ~(MASK_35MM_HEADSET | MASK_FM_ATTRIBUTE);
 	switch_set_state(&hi->sdev, state);
 #endif
-
+	hpin_report++;
 	HS_LOG_TIME("Remove 3.5mm accessory");
 
 	mutex_unlock(&hi->mutex_lock);
@@ -863,50 +874,64 @@ static void remove_detect_work_func(struct work_struct *work)
 /*insert one-wire work function. send start comment and initail comment and then recieve AID form accessory.*/
 static int insert_1wire_work_func()
 {
-	HS_LOG("insert one-wire detection start");
 	int cnt = 0;
 	char b_buf[128];
 	int r,i;
 	int count = 0;
-	int mic = HEADSET_NO_MIC;
+	int check_count = 0;
+	int mic = 0;
+
 
 	char buf2[1];
 	buf2[0]=0x00;
 
 	char buf1[1];
-	buf1[0]=0x35;
+	buf1[0]=0xF5;
 
+/*
 	if (uart_check == 0)
 		while (1){
+			check_count++;
 			if(hi->detect_type ==99){
 				uart_check = 1;
-				hi->detect_type == HEADSET_ADC;
-				msleep(1000);
+				hi->detect_type = HEADSET_ADC;
+				HS_LOG("hs_uart is ready!");
 				break;
 			}
 			else
 				msleep(1000);
+
+			if(check_count>10){
+				uart_check = 1;
+				HS_LOG("hs_uart is not ready!");
+				break;
+		}
 		}
+*/
+	if(uart_check == 1)
+		HS_LOG("hs_uart is ready!");
+	else
+		HS_LOG("hs_uart is not ready!");
+
 
+	HS_LOG("insert one-wire detection start");
 	enable_1wire_tx();
 	mdelay(80);
 	fp = openFile(hi->pdata.dev_1wire,O_CREAT|O_RDWR|O_NONBLOCK,0666);
+	//tegra_hsl_headset_setup(&tegra_uarte_device);
 	writeFile(fp,buf2,sizeof(buf2));
 	udelay(200);
 
 	writeFile(fp,buf1,sizeof(buf1));
 	udelay(200);
-
 	enable_1wire_rx();
 
 	while(1){
 		r=readFile(fp,b_buf,10);
 		if (r>0){
 			HS_LOG("Read %xh bytes, count:%d, %s\n",r,count,b_buf);
-
 			for(cnt = 0; cnt < r; cnt++){
 				HS_LOG("Read:0x%x, %d, %s\n", (int) b_buf[cnt], (int)b_buf[cnt], b_buf[cnt]);
-
 				if (hi->pdata.headset_config_1wire_num)
 					for (i = 0; i < hi->pdata.headset_config_1wire_num; i++)
 						if ((int)b_buf[cnt] == hi->pdata.headset_config_1wire[i].value)	{
@@ -918,8 +943,8 @@ static int insert_1wire_work_func()
 		count++;
 		if (count == CHECK_COUNT || hi->detect_type == HEADSET_1WIRE )
 			break;
+		mdelay(10);
 	}
-
 	if(hi->detect_type != HEADSET_1WIRE){
 		closeFile(fp);
 		disable_1wire();
@@ -953,24 +978,24 @@ static void insert_detect_work_func(struct work_struct *work)
 	if(mic == HEADSET_UNPLUG){
 		mdelay(1000);
 		mic = get_mic_status();
-		if(mic == HEADSET_UNPLUG){
-			HS_LOG("Headset unplug.");
-			hi->hs_35mm_type = mic;
-			mutex_unlock(&hi->mutex_lock);
-			if ((hi->pdata.eng_cfg == HS_EDE_U) || (hi->pdata.eng_cfg == HS_EDE_TD) || (hi->pdata.eng_cfg == HS_BLE)){
-				aic3008_set_mic_bias(0);
-			}
-			if ((hi->pdata.eng_cfg == HS_QUO_F_U)){
-				regulator = regulator_get(NULL, "v_aud_2v85");
-				if (IS_ERR_OR_NULL(regulator)) {
-					pr_err("htc_headset_gpio_probe:Couldn't get regulator v_aud_2v85\n");
-					regulator = NULL;
-					return;
-				}
-				regulator_disable(regulator);
+	if(mic == HEADSET_UNPLUG){
+		HS_LOG("Headset unplug.");
+		hi->hs_35mm_type = mic;
+		mutex_unlock(&hi->mutex_lock);
+		if ((hi->pdata.eng_cfg == HS_EDE_U) || (hi->pdata.eng_cfg == HS_EDE_TD) || (hi->pdata.eng_cfg == HS_BLE)){
+			aic3008_set_mic_bias(0);
+		}
+		if ((hi->pdata.eng_cfg == HS_QUO_F_U)){
+			regulator = regulator_get(NULL, "v_aud_2v85");
+			if (IS_ERR_OR_NULL(regulator)) {
+				pr_err("htc_headset_gpio_probe:Couldn't get regulator v_aud_2v85\n");
+				regulator = NULL;
+				return;
 			}
-			return;
+			regulator_disable(regulator);
 		}
+		return;
+	}
 	}
 
 	if (mic == HEADSET_NO_MIC)
@@ -1040,6 +1065,7 @@ static void insert_detect_work_func(struct work_struct *work)
 
 	hi->hs_35mm_type = mic;
 	switch_set_state(&hi->sdev, state);
+	hpin_report++;
 
 	mutex_unlock(&hi->mutex_lock);
 
@@ -1084,7 +1110,7 @@ int hs_notify_plug_event(int insert)
 int hs_notify_key_event(int key_code)
 {
 
-
+	int uart_key;
 	HS_DBG();
 
 	if (hi->hs_35mm_type == HEADSET_UNKNOWN_MIC ||
@@ -1097,10 +1123,17 @@ int hs_notify_key_event(int key_code)
 		HS_LOG("The HPIN is unstable, SKIP THE BUTTON EVENT.");
 		return 1;
 	} else {
+		/*run one-wire button work function if the project support one-wire detection*/
+		if(hi->detect_type == HEADSET_1WIRE && hi->pdata.enable_1wire){
+			uart_key = button_1wire_work_func();
+			if(uart_key!=99)
+				key_code = uart_key;	
+		}
+
 		if(key_event_flag == (HS_BUTTON_EVENT_QUEUE-1))
 			key_event_flag = -1;
 		key_event_flag++;
-		HS_LOG("key_event_flag = %d",key_event_flag);
+		HS_DBG("key_event_flag = %d",key_event_flag);
 		key_event[key_event_flag]->key_code = key_code;
 		INIT_DELAYED_WORK(&key_event[key_event_flag]->key_work, button_35mm_work_func);
 		queue_delayed_work(button_wq, &key_event[key_event_flag]->key_work,
@@ -1115,6 +1148,8 @@ int hs_notify_key_irq(void)
 	int adc = 0;
 	int key_code = HS_MGR_KEY_INVALID;
 
+	key_bounce++;
+	mdelay(20);
 	if (!hs_mgr_notifier.remote_adc || !hs_mgr_notifier.remote_keycode) {
 		HS_LOG("Failed to get remote key code");
 		return 1;
@@ -1278,6 +1313,8 @@ static ssize_t headset_1wire_store(struct device *dev,
 {
 	HS_DBG();
 	hi->detect_type = 99;
+	uart_check = 1;
+
 	return 0;
 }
 
@@ -1413,9 +1450,20 @@ static DEVICE_ACCESSORY_ATTR(fm, 0644, fm_flag_show, fm_flag_store);
 static ssize_t debug_flag_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
 {
+    char *s = buf;
 	int flag = hi->debug_flag;
 	int adc = -EINVAL;
 	int hpin_gpio = -EINVAL;
+	int i = 0;
+
+    int headset_mic_adc_max = 0;
+    int headset_mic_adc_min = 0;
+    int headset_beats_adc_max = 0;
+    int headset_beats_adc_min = 0;
+    int headset_beats_solo_adc_max = 0;
+    int headset_beats_solo_adc_min = 0;
+    int headset_no_mic_adc_max = 0;
+    int headset_no_mic_adc_min = 0;
 
 	HS_DBG();
 
@@ -1424,8 +1472,50 @@ static ssize_t debug_flag_show(struct device *dev,
 	if (hs_mgr_notifier.remote_adc)
 		hs_mgr_notifier.remote_adc(&adc);
 
-	return sprintf(buf, "Debug Flag %d, HP_DET %d, ADC %d\n", flag,
-		       hpin_gpio, adc);
+    for (i = 0; i < hi->pdata.headset_config_num; i++) {
+        if (hi->pdata.headset_config[i].type == HEADSET_MIC &&
+            headset_mic_adc_max == 0 && headset_mic_adc_min ==0) {
+            headset_mic_adc_max = hi->pdata.headset_config[i].adc_max;
+            headset_mic_adc_min = hi->pdata.headset_config[i].adc_min;
+        }
+        if (hi->pdata.headset_config[i].type == HEADSET_BEATS &&
+            headset_beats_adc_max == 0 && headset_beats_adc_min ==0) {
+            headset_beats_adc_max = hi->pdata.headset_config[i].adc_max;
+            headset_beats_adc_min = hi->pdata.headset_config[i].adc_min;
+        }
+        if (hi->pdata.headset_config[i].type == HEADSET_BEATS_SOLO &&
+            headset_beats_solo_adc_max == 0 && headset_beats_solo_adc_min ==0) {
+            headset_beats_solo_adc_max = hi->pdata.headset_config[i].adc_max;
+            headset_beats_solo_adc_min = hi->pdata.headset_config[i].adc_min;
+        }
+        if (hi->pdata.headset_config[i].type == HEADSET_NO_MIC &&
+            headset_no_mic_adc_max == 0 && headset_no_mic_adc_min ==0) {
+            headset_no_mic_adc_max = hi->pdata.headset_config[i].adc_max;
+            headset_no_mic_adc_min = hi->pdata.headset_config[i].adc_min;
+        }
+    }
+
+    mutex_lock(&hi->mutex_lock);
+    s += sprintf(s, "Debug Flag = %d\nHP_DET = %d\nADC = %d\n", flag, hpin_gpio, adc);
+    s += sprintf(s, "DET report count = %d\nDET bounce count = %d\n", hpin_report, hpin_bounce);
+    s += sprintf(s, "KEY report count = %d\nKEY bounce count = %d\n", key_report, key_bounce);
+
+    s += sprintf(s, "headset_mic_adc_max = %d\n", headset_mic_adc_max);
+    s += sprintf(s, "headset_mic_adc_min = %d\n", headset_mic_adc_min);
+    s += sprintf(s, "headset_beats_adc_max = %d\n", headset_beats_adc_max);
+    s += sprintf(s, "headset_beats_adc_min = %d\n", headset_beats_adc_min);
+    s += sprintf(s, "headset_beats_solo_adc_max = %d\n", headset_beats_solo_adc_max);
+    s += sprintf(s, "headset_beats_solo_adc_min = %d\n", headset_beats_solo_adc_min);
+    s += sprintf(s, "headset_no_mic_adc_max = %d\n", headset_no_mic_adc_max);
+    s += sprintf(s, "headset_no_mic_adc_min = %d\n", headset_no_mic_adc_min);
+
+    key_report = 0;
+    key_bounce = 0;
+    hpin_report = 0;
+    hpin_bounce = 0;
+    mutex_unlock(&hi->mutex_lock);
+
+    return (s - buf);
 }
 
 static ssize_t debug_flag_store(struct device *dev,
diff --git a/arch/arm/mach-tegra/htc_simhotswap.c b/arch/arm/mach-tegra/htc_simhotswap.c
index 9449dac..dbce12c 100644
--- a/arch/arm/mach-tegra/htc_simhotswap.c
+++ b/arch/arm/mach-tegra/htc_simhotswap.c
@@ -24,15 +24,9 @@
 #include <linux/workqueue.h>
 #include "board.h"
 #include <mach/board_htc.h>
-#if defined(CONFIG_MACH_QUATTRO_U)
-#include "board-quattro.h"
-#elif defined(CONFIG_MACH_BLUE)
+#if defined(CONFIG_MACH_BLUE)
 #include "board-blue.h"
-#elif defined(CONFIG_MACH_EDGE)
-#include "board-edge.h"
-#elif defined(CONFIG_MACH_EDGE_TD)
-#include "board-edgetd.h"
-#elif defined(CONFIG_MACH_ENDEAVORU)
+#elif defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ERAU)
 #include "board-endeavoru.h"
 #endif
 #include "gpio-names.h"
diff --git a/arch/arm/mach-tegra/htc_util.c b/arch/arm/mach-tegra/htc_util.c
index 05e4cd5..c420ee5 100644
--- a/arch/arm/mach-tegra/htc_util.c
+++ b/arch/arm/mach-tegra/htc_util.c
@@ -17,7 +17,6 @@
 #include "pm.h"
 #include <linux/vmalloc.h>
 #include "board.h"
-#include <htc/log.h>
 #if 0
 #include <mach/rpm.h>
 #include <mach/perflock.h>
@@ -355,7 +354,7 @@ void htc_kernel_top(void)
 	/* print most time consuming processes */
 	printk(KERN_INFO "CPU Usage\tPID\t\tName\n");
 	for (i = 0 ; i < NUM_BUSY_THREAD_CHECK ; i++) {
-		sp_pr_info("%lu%%\t\t%d\t\t%s\t\t\t%d\n",
+		printk(KERN_INFO "%lu%%\t\t%d\t\t%s\t\t\t%d\n",
 				curr_proc_delta[top_loading[i]] * 100 / delta_time,
 				top_loading[i],
 				task_ptr_array[top_loading[i]]->comm,
@@ -370,7 +369,7 @@ void htc_kernel_top(void)
 			t = task_ptr_array[top_loading[i]];
 			/* dump all the thread stack of this process */
 			do {
-				sp_pr_info("\n###pid:%d name:%s state:%lu ppid:%d stime:%lu utime:%lu\n",
+				printk(KERN_INFO "\n###pid:%d name:%s state:%lu ppid:%d stime:%lu utime:%lu\n",
 				t->pid, t->comm, t->state, t->real_parent->pid, t->stime, t->utime);
 				show_stack(t, t->stack);
diff --git a/arch/arm/mach-tegra/include/mach/cable_detect.h b/arch/arm/mach-tegra/include/mach/cable_detect.h
index 770ade0..bd1c88d 100644
--- a/arch/arm/mach-tegra/include/mach/cable_detect.h
+++ b/arch/arm/mach-tegra/include/mach/cable_detect.h
@@ -85,15 +85,20 @@ struct cable_detect_platform_data {
 /* START: add USB connected notify function */
 void tegra_usb_set_vbus_state(int online);
 enum usb_connect_type {
-	CONNECT_TYPE_NONE,
-	CONNECT_TYPE_UNKNOWN,
-	CONNECT_TYPE_AUDIO,
-	CONNECT_TYPE_CARKIT,
-	CONNECT_TYPE_MHL,
+	/* QC Synchronous */
+	CONNECT_TYPE_CLEAR = -2,
+	CONNECT_TYPE_UNKNOWN = -1,
+	CONNECT_TYPE_NONE = 0,
+	CONNECT_TYPE_USB,
+	CONNECT_TYPE_AC,
+	CONNECT_TYPE_9V_AC,
+	CONNECT_TYPE_WIRELESS,
+	CONNECT_TYPE_INTERNAL,
+	CONNECT_TYPE_UNSUPPORTED,
+
+	/* Reserved */
 	CONNECT_TYPE_UNDEFINED,
-	CONNECT_TYPE_USB, /* 0A5 */
 	CONNECT_TYPE_0A9_AC,
-	CONNECT_TYPE_AC, /* 1A */
 	CONNECT_TYPE_1A1_AC,
 	CONNECT_TYPE_1A2_AC,
 	CONNECT_TYPE_1A3_AC,
diff --git a/arch/arm/mach-tegra/include/mach/htc_battery_core.h b/arch/arm/mach-tegra/include/mach/htc_battery_core.h
index 72c091a..7eb68c1 100644
--- a/arch/arm/mach-tegra/include/mach/htc_battery_core.h
+++ b/arch/arm/mach-tegra/include/mach/htc_battery_core.h
@@ -49,6 +49,7 @@ struct battery_info_reply {
 
 struct htc_battery_core {
 	int (*func_show_batt_attr)(struct device_attribute *attr, char *buf);
+	int (*func_show_batt_power_meter)(struct device_attribute *attr, char *buf);
 	int (*func_get_battery_info)(struct battery_info_reply *buffer);
 	int (*func_charger_control)(enum charger_control_flag);
 	void (*func_set_full_level)(int full_level);
diff --git a/arch/arm/mach-tegra/include/mach/htc_battery_tps80032.h b/arch/arm/mach-tegra/include/mach/htc_battery_tps80032.h
index 7aee3e9..0332690 100644
--- a/arch/arm/mach-tegra/include/mach/htc_battery_tps80032.h
+++ b/arch/arm/mach-tegra/include/mach/htc_battery_tps80032.h
@@ -19,6 +19,7 @@
 #define HTC_BATT_IOCTL_MAGIC		0xba
 
 #define DEBUG_LOG_LENGTH		1024
+#define POWER_METER_LENGTH		16
 
 #define HTC_BATT_IOCTL_READ_SOURCE \
 	_IOR(HTC_BATT_IOCTL_MAGIC, 1, unsigned int)
@@ -38,6 +39,8 @@
 	_IOW(HTC_BATT_IOCTL_MAGIC, 8, struct battery_vol_alarm)
 #define HTC_BATT_IOCTL_SET_ALARM_TIMER_FLAG \
 	_IOW(HTC_BATT_IOCTL_MAGIC, 9, unsigned int)
+#define HTC_BATT_IOCTL_BATT_POWER_METER \
+	_IOW(HTC_BATT_IOCTL_MAGIC, 10, char[POWER_METER_LENGTH])
 
 #define REGULAR_BATTERRY_TIMER		"regular_timer"
 #define CABLE_DETECTION			"cable"
diff --git a/arch/arm/mach-tegra/include/mach/htc_headset_mgr.h b/arch/arm/mach-tegra/include/mach/htc_headset_mgr.h
index 44fad77..88c6c09 100644
--- a/arch/arm/mach-tegra/include/mach/htc_headset_mgr.h
+++ b/arch/arm/mach-tegra/include/mach/htc_headset_mgr.h
@@ -62,6 +62,7 @@
 #define DRIVER_HS_MGR_RPC_SERVER	(1 << 0)
 #define UART_DEV_NAME_LEN 32
 #define CHECK_COUNT 5
+#define DET_CHECK_COUNT 10
 
 
 #define DEBUG_FLAG_LOG		(1 << 0)
@@ -119,7 +120,7 @@
 #define HS_JIFFIES_REMOVE		msecs_to_jiffies(HS_DELAY_REMOVE)
 #define HS_JIFFIES_BUTTON		msecs_to_jiffies(HS_DELAY_BUTTON)
 
-#define HS_WAKE_LOCK_TIMEOUT		(2 * HZ)
+#define HS_WAKE_LOCK_TIMEOUT		(5 * HZ)
 #define HS_RPC_TIMEOUT			(5 * HZ)
 #define HS_MIC_DETECT_TIMEOUT		(HZ + HZ / 2)
 
@@ -153,6 +154,7 @@
 #define HS_EDE_U			5
 #define HS_EDE_TD			6
 #define HS_EDE_U_TD			7
+#define HS_QUO_F_U_XB		8
 
 enum {
 	HEADSET_UNPLUG		= 0,
diff --git a/arch/arm/mach-tegra/include/mach/usb_phy.h b/arch/arm/mach-tegra/include/mach/usb_phy.h
index c77d13e..89a9944 100644
--- a/arch/arm/mach-tegra/include/mach/usb_phy.h
+++ b/arch/arm/mach-tegra/include/mach/usb_phy.h
@@ -171,4 +171,9 @@ bool tegra_usb_phy_is_remotewake_detected(struct tegra_usb_phy *phy);
 
 int tegra_usb_set_vbus_wakeup(int irq);//htc
 
+void tegra_usb_phy_memory_prefetch_on(struct tegra_usb_phy *phy);
+
+void tegra_usb_phy_memory_prefetch_off(struct tegra_usb_phy *phy);
+
+
 #endif /* __MACH_USB_PHY_H */
diff --git a/arch/arm/mach-tegra/pinmux.c b/arch/arm/mach-tegra/pinmux.c
index c3608e1..e6af6cf 100644
--- a/arch/arm/mach-tegra/pinmux.c
+++ b/arch/arm/mach-tegra/pinmux.c
@@ -237,7 +237,8 @@ static int tegra_pinmux_set_func(const struct tegra_pingroup_config *config)
 		}
 #if defined(CONFIG_MACH_ENDEAVORU) || \
 	defined(CONFIG_MACH_ENDEAVORTD) || \
-	defined(CONFIG_MACH_VERTEXF)
+	defined(CONFIG_MACH_ERAU) || \
+	defined(CONFIG_MACH_VERTEXFP)
 		if (mux < 0)
 		{
 			/*
diff --git a/arch/arm/mach-tegra/platsmp.c b/arch/arm/mach-tegra/platsmp.c
index e41cf26..a3b5e6d 100644
--- a/arch/arm/mach-tegra/platsmp.c
+++ b/arch/arm/mach-tegra/platsmp.c
@@ -32,6 +32,7 @@
 #include "clock.h"
 #include "reset.h"
 #include "sleep.h"
+#include "cpu-tegra.h"
 
 bool tegra_all_cpus_booted;
 
@@ -209,8 +210,14 @@ int boot_secondary(unsigned int cpu, struct task_struct *idle)
 			/* Early boot, clock infrastructure is not initialized
 			   - CPU mode switch is not allowed */
 			status = -EINVAL;
-		} else
+		} else {
+			/* make sure cpu rate is within g-mode range before
+			   switching */
+			unsigned int speed = max(tegra_getspeed(0),
+				clk_get_min_rate(cpu_g_clk) / 1000);
+			tegra_update_cpu_speed(speed);
 			status = clk_set_parent(cpu_clk, cpu_g_clk);
+		}
 
 		if (status)
 			goto done;
diff --git a/arch/arm/mach-tegra/pm-irq.c b/arch/arm/mach-tegra/pm-irq.c
index 91a3453..cbcf6b6 100644
--- a/arch/arm/mach-tegra/pm-irq.c
+++ b/arch/arm/mach-tegra/pm-irq.c
@@ -179,7 +179,7 @@ int tegra_pm_irq_set_wake_type(int irq, int flow_type)
 
 	if (wake < 0)
 		return 0;
-#ifdef CONFIG_MACH_ENDEAVORU
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ERAU)
 /*Workaround for Power key wakeup*/
 if(wake == 7)
 {
@@ -223,19 +223,19 @@ static void tegra_pm_irq_syscore_resume_helper(
 	for_each_set_bit(wake, &wake_status, sizeof(wake_status) * 8) {
 		irq = tegra_wake_to_irq(wake + 32 * index);
 		if (!irq) {
-			pr_info("Resume caused by WAKE%d\n",
+			pr_info("[R] Resume caused by WAKE%d\n",
 				(wake + 32 * index));
 			continue;
 		}
 
 		desc = irq_to_desc(irq);
 		if (!desc || !desc->action || !desc->action->name) {
-			pr_info("Resume caused by WAKE%d, irq %d\n",
+			pr_info("[R] Resume caused by WAKE%d, irq %d\n",
 				(wake + 32 * index), irq);
 			continue;
 		}
 
-		pr_info("Resume caused by WAKE%d, %s\n", (wake + 32 * index),
+		pr_info("[R] Resume caused by WAKE%d, %s\n", (wake + 32 * index),
 			desc->action->name);
 		global_wakeup_state = (wake + 32 * index);
 		pr_info("global_wakeup_state is %d, wake_status is %d\n",
diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index beb4705..57e2eb7 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -1142,7 +1142,7 @@ out:
 
 	/* Always enable CPU power request; just normal polarity is supported */
 //#ifndef CONFIG_MACH_ENDEAVORU || CONFIG_MACH_ENDEAVORUTD
-#if !defined(CONFIG_MACH_ENDEAVORU) && !defined(CONFIG_MACH_ENDEAVORTD)
+#if !defined(CONFIG_MACH_ENDEAVORU) && !defined(CONFIG_MACH_ENDEAVORTD) && !defined(CONFIG_MACH_ERAU)
 	reg = readl(pmc + PMC_CTRL);
 	BUG_ON(reg & TEGRA_POWER_CPU_PWRREQ_POLARITY);
 	reg |= TEGRA_POWER_CPU_PWRREQ_OE;
diff --git a/arch/arm/mach-tegra/pm.h b/arch/arm/mach-tegra/pm.h
index de8f744..defb2cb 100644
--- a/arch/arm/mach-tegra/pm.h
+++ b/arch/arm/mach-tegra/pm.h
@@ -61,7 +61,7 @@ struct tegra_suspend_platform_data {
 	/* lp_state = 0 for LP0 state, 1 for LP1 state, 2 for LP2 state */
 	void (*board_resume)(int lp_state, enum resume_stage stg);
 	unsigned int cpu_resume_boost;	/* CPU frequency resume boost in kHz */
-	unsigned int boost_resume_reason;
+	unsigned long long boost_resume_reason;
 };
 
 /* Tegra io dpd entry - for each supported driver */
diff --git a/arch/arm/mach-tegra/powerdetect.c b/arch/arm/mach-tegra/powerdetect.c
index de30079..97cd8d7 100644
--- a/arch/arm/mach-tegra/powerdetect.c
+++ b/arch/arm/mach-tegra/powerdetect.c
@@ -29,7 +29,6 @@
 
 #include "board.h"
 #include "fuse.h"
-#include <htc/log.h>
 
 #define PMC_PWR_IO_DISABLE	0x44
 #define PMC_PWR_DET_ENABLE	0x48
@@ -77,7 +76,7 @@ static inline u32 pmc_readl(unsigned long addr)
 /* Some IO pads does not have power detect cells, but still can/should be
  * turned off when no power - set pwrdet_mask=0 for such pads */
 static struct pwr_detect_cell pwr_detect_cells[] = {
-#if 	defined(CONFIG_MACH_VERTEXF) || defined(CONFIG_MACH_VERTEXFP)
+#if 	defined(CONFIG_MACH_VERTEXFP)
 	POWER_CELL("pwrdet_nand",	(0x1 <<  1), (0x1 <<  1), 0xFFFFFFFF),
 #endif
 	POWER_CELL("pwrdet_uart",	(0x1 <<  2), (0x1 <<  2), 0xFFFFFFFF),
@@ -93,16 +92,16 @@ static struct pwr_detect_cell pwr_detect_cells[] = {
 #ifdef	CONFIG_ARCH_TEGRA_2x_SOC
 	POWER_CELL("pwrdet_sd",			  0, (0x1 <<  8), 0xFFFFFFFF),
 #endif
-#if	defined(CONFIG_MACH_VERTEXF) || defined(CONFIG_MACH_VERTEXFP)
+#if	defined(CONFIG_MACH_VERTEXFP)
 	POWER_CELL("pwrdet_mipi",		  0, (0x1 <<  9), 0xFFFFFFFF),
 #endif
 #ifndef CONFIG_ARCH_TEGRA_2x_SOC
 	POWER_CELL("pwrdet_cam",	(0x1 << 10), (0x1 << 10), 0xFFFFFFFF),
-#if	defined(CONFIG_MACH_VERTEXF) || defined(CONFIG_MACH_VERTEXFP)
+#if	defined(CONFIG_MACH_VERTEXFP)
 	POWER_CELL("pwrdet_pex_ctl",	(0x1 << 11), (0x1 << 11), 0xFFFFFFFF),
 #endif
 	POWER_CELL("pwrdet_sdmmc1",	(0x1 << 12), (0x1 << 12), 0xFFFFFFFF),
-#if	defined(CONFIG_MACH_VERTEXF) || defined(CONFIG_MACH_VERTEXFP)
+#if	defined(CONFIG_MACH_VERTEXFP)
 	POWER_CELL("pwrdet_sdmmc3",	(0x1 << 13), (0x1 << 13), 0xFFFFFFFF),
 #endif
 	POWER_CELL("pwrdet_sdmmc4",		  0, (0x1 << 14), 0xFFFFFFFF),
@@ -270,7 +269,7 @@ static int pwrdet_notify_cb(
 			pwr_io_disable(cell->pwrio_mask);
 	}
 
-	sp_pr_info("tegra: %s: event %lu, pwrdet 0x%x, pwrio 0x%x\n",
+	pr_debug("tegra: %s: event %lu, pwrdet 0x%x, pwrio 0x%x\n",
 		cell->reg_id, event,
 		pmc_readl(PMC_PWR_DET_VAL), pmc_readl(PMC_PWR_IO_DISABLE));
 	spin_unlock_irqrestore(&pwr_lock, flags);
diff --git a/arch/arm/mach-tegra/tegra3_clocks.c b/arch/arm/mach-tegra/tegra3_clocks.c
index c41ec8f..0f0854d 100644
--- a/arch/arm/mach-tegra/tegra3_clocks.c
+++ b/arch/arm/mach-tegra/tegra3_clocks.c
@@ -29,9 +29,10 @@
 #include <linux/clk.h>
 #include <linux/cpufreq.h>
 #include <linux/syscore_ops.h>
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
 
 #include <asm/clkdev.h>
-
 #include <mach/iomap.h>
 #include <mach/edp.h>
 
@@ -305,7 +306,6 @@
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #define EARLY_SUSPEND_MIN_CPU_FREQ_IDX	0
 #define ACTIVE_MIN_CPU_FREQ_IDX		1
-
 /*
  * SCLK_ADJUST_DELAY is timeout to delay lowering SCLK
  * after display off/suspend. SCLK is kept at 40Mhz for the specified
@@ -1032,15 +1032,21 @@ static int tegra3_cpu_cmplx_clk_set_parent(struct clk *c, struct clk *p)
 	spin_unlock(&parameters_lock);
 
 	if (flags) {
-		/* over-clocking after the switch - allow, but lower rate */
-		if (rate > p->max_rate) {
-			rate = p->max_rate;
+		/* over/under-clocking after switch - allow, but update rate */
+		if ((rate > p->max_rate) || (rate < p->min_rate)) {
+			unsigned long fl;
+
+			rate = rate > p->max_rate ? p->max_rate : p->min_rate;
 			ret = clk_set_rate(c->parent, rate);
 			if (ret) {
 				pr_err("%s: Failed to set rate %lu for %s\n",
 				        __func__, rate, p->name);
 				return ret;
 			}
+			clk_lock_save(c->parent, &fl);
+			clk_set_rate(&tegra3_clk_twd,
+					clk_get_rate_locked(c->parent));
+			clk_unlock_restore(c->parent, &fl);
 		}
 	} else
 #endif
@@ -4153,12 +4159,21 @@ struct clk tegra_list_clks[] = {
 	PERIPH_CLK("hda",	"tegra30-hda",		"hda",   125,	0x428,	108000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
 	PERIPH_CLK("hda2codec_2x",	"tegra30-hda",	"hda2codec",   111,	0x3e4,	48000000,  mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
 	PERIPH_CLK("hda2hdmi",	"tegra30-hda",		"hda2hdmi",	128,	0,	48000000,  mux_clk_m,			PERIPH_ON_APB),
-	PERIPH_CLK("sbc1",	"spi_tegra.0",		NULL,	41,	0x134,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
-	PERIPH_CLK("sbc2",	"spi_tegra.1",		NULL,	44,	0x118,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
-	PERIPH_CLK("sbc3",	"spi_tegra.2",		NULL,	46,	0x11c,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
-	PERIPH_CLK("sbc4",	"spi_tegra.3",		NULL,	68,	0x1b4,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
-	PERIPH_CLK("sbc5",	"spi_tegra.4",		NULL,	104,	0x3c8,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
-	PERIPH_CLK("sbc6",	"spi_tegra.5",		NULL,	105,	0x3cc,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
+#ifdef CONFIG_SERIAL_SC8800G
+	PERIPH_CLK("sbc1",	"spi_tegra.0",		"spi",	41,	0x134,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc2",	"spi_tegra.1",		"spi",	44,	0x118,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc3",	"spi_tegra.2",		"spi",	46,	0x11c,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc4",	"spi_tegra.3",		"spi",	68,	0x1b4,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc5",	"spi_tegra.4",		"spi",	104,	0x3c8,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc6",	"spi_tegra.5",		"spi",	105,	0x3cc,	160000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71 | PERIPH_ON_APB),
+#else
+	PERIPH_CLK("sbc1",      "spi_tegra.0",          NULL,   41,     0x134,  160000000, mux_pllp_pllc_pllm_clkm,     MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc2",      "spi_tegra.1",          NULL,   44,     0x118,  160000000, mux_pllp_pllc_pllm_clkm,     MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc3",      "spi_tegra.2",          NULL,   46,     0x11c,  160000000, mux_pllp_pllc_pllm_clkm,     MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc4",      "spi_tegra.3",          NULL,   68,     0x1b4,  160000000, mux_pllp_pllc_pllm_clkm,     MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc5",      "spi_tegra.4",          NULL,   104,    0x3c8,  160000000, mux_pllp_pllc_pllm_clkm,     MUX | DIV_U71 | PERIPH_ON_APB),
+	PERIPH_CLK("sbc6",      "spi_tegra.5",          NULL,   105,    0x3cc,  160000000, mux_pllp_pllc_pllm_clkm,     MUX | DIV_U71 | PERIPH_ON_APB),
+#endif
 	PERIPH_CLK("sata_oob",	"tegra_sata_oob",	NULL,	123,	0x420,	216000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71),
 	PERIPH_CLK("sata",	"tegra_sata",		NULL,	124,	0x424,	216000000, mux_pllp_pllc_pllm_clkm,	MUX | DIV_U71),
 	PERIPH_CLK("sata_cold",	"tegra_sata_cold",	NULL,	129,	0,	48000000,  mux_clk_m,			0),
@@ -4243,6 +4258,14 @@ struct clk tegra_list_clks[] = {
 	SHARED_CLK("mon.avp",	"tegra_actmon",		"avp",	&tegra_clk_sbus_cmplx, NULL, 0, 0),
 	SHARED_CLK("cap.sclk",	"cap_sclk",		NULL,	&tegra_clk_sbus_cmplx, NULL, 0, SHARED_CEILING),
 	SHARED_CLK("floor.sclk", "floor_sclk",		NULL,	&tegra_clk_sbus_cmplx, NULL, 0, 0),
+#ifdef CONFIG_SERIAL_SC8800G
+	SHARED_CLK("sbc1.sclk", "spi_tegra.0",		"sclk", &tegra_clk_sbus_cmplx, NULL, 0, 0),
+	SHARED_CLK("sbc2.sclk", "spi_tegra.1",		"sclk", &tegra_clk_sbus_cmplx, NULL, 0, 0),
+	SHARED_CLK("sbc3.sclk", "spi_tegra.2",		"sclk", &tegra_clk_sbus_cmplx, NULL, 0, 0),
+	SHARED_CLK("sbc4.sclk", "spi_tegra.3",		"sclk", &tegra_clk_sbus_cmplx, NULL, 0, 0),
+	SHARED_CLK("sbc5.sclk", "spi_tegra.4",		"sclk", &tegra_clk_sbus_cmplx, NULL, 0, 0),
+	SHARED_CLK("sbc6.sclk", "spi_tegra.5",		"sclk", &tegra_clk_sbus_cmplx, NULL, 0, 0),
+#endif
 	SHARED_CLK("camera.sclk",	"tegra_camera",	"sclk",	&tegra_clk_sbus_cmplx, NULL, 0, 0),
 	SHARED_CLK("wake.sclk", "delay.audio.0",	"sclk",	&tegra_clk_sbus_cmplx, NULL, 0, 0),
 	SHARED_CLK("disp2.sclk", "tegradc.1",		"sclk",	&tegra_clk_sbus_cmplx, NULL, 0, 0),
diff --git a/arch/arm/mach-tegra/tegra3_emc.c b/arch/arm/mach-tegra/tegra3_emc.c
index de68404..1c92c55 100644
--- a/arch/arm/mach-tegra/tegra3_emc.c
+++ b/arch/arm/mach-tegra/tegra3_emc.c
@@ -1134,7 +1134,7 @@ static int __init tegra_emc_debug_init(void)
 		goto err_out;
 
 	if (!debugfs_create_file(
-		"eack_state", S_IWUSR | S_IRUGO, emc_debugfs_root, NULL, &eack_state_fops))
+		"eack_state", S_IWUSR | S_IRUGO | S_IWGRP, emc_debugfs_root, NULL, &eack_state_fops))
 		goto err_out;
 
 	return 0;
diff --git a/arch/arm/mach-tegra/tegra3_speedo.c b/arch/arm/mach-tegra/tegra3_speedo.c
index f99d875..5166c18 100644
--- a/arch/arm/mach-tegra/tegra3_speedo.c
+++ b/arch/arm/mach-tegra/tegra3_speedo.c
@@ -22,7 +22,7 @@
 #include <linux/io.h>
 #include <linux/err.h>
 #include <mach/iomap.h>
-#if (defined(CONFIG_MACH_ENDEAVORU) | defined(CONFIG_MACH_ENDEAVORTD))
+#if (defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU))
 #include <linux/init.h>
 #include <mach/board_htc.h>
 #endif
@@ -153,7 +153,7 @@ static void rev_sku_to_speedo_ids(int rev, int sku)
 				cpu_speedo_id = 4;
 				soc_speedo_id = 1;
 				threshold_index = 7;
-#if (defined(CONFIG_MACH_ENDEAVORU) | defined(CONFIG_MACH_ENDEAVORTD))
+#if (defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU))
 				if (htc_get_pcbid_info() <= PROJECT_PHASE_XC) {
 					cpu_speedo_id = 1;
 					soc_speedo_id = 1;
diff --git a/arch/arm/mach-tegra/tegra_flashlight.c b/arch/arm/mach-tegra/tegra_flashlight.c
index 9f0d581..97863e3 100644
--- a/arch/arm/mach-tegra/tegra_flashlight.c
+++ b/arch/arm/mach-tegra/tegra_flashlight.c
@@ -553,7 +553,7 @@ static int flashlight_setup_gpio(struct flashlight_platform_data *flashlight,
 	int ret = 0;
 	if (flashlight->gpio_init)
 		flashlight->gpio_init();
-	// have been config gpio in board-enterprise.c
+	// have been config gpio in board-endeavor*.c
 	if (flashlight->torch) {
 		/*
 		ret = gpio_request(flashlight->torch, "fl_torch");
diff --git a/arch/arm/mach-tegra/timer.c b/arch/arm/mach-tegra/timer.c
index f26505e..e212696 100644
--- a/arch/arm/mach-tegra/timer.c
+++ b/arch/arm/mach-tegra/timer.c
@@ -219,6 +219,15 @@ static struct syscore_ops tegra_timer_syscore_ops = {
 };
 
 #ifdef CONFIG_HAVE_ARM_TWD
+int tegra_twd_get_state(struct tegra_twd_context *context)
+{
+	context->twd_ctrl = readl(twd_base + TWD_TIMER_CONTROL);
+	context->twd_load = readl(twd_base + TWD_TIMER_LOAD);
+	context->twd_cnt = readl(twd_base + TWD_TIMER_COUNTER);
+
+	return 0;
+}
+
 void tegra_twd_suspend(struct tegra_twd_context *context)
 {
 	context->twd_ctrl = readl(twd_base + TWD_TIMER_CONTROL);
diff --git a/arch/arm/mach-tegra/timer.h b/arch/arm/mach-tegra/timer.h
index 04d858f..4a91792 100644
--- a/arch/arm/mach-tegra/timer.h
+++ b/arch/arm/mach-tegra/timer.h
@@ -38,12 +38,16 @@ void __init tegra3_init_timer(u32 *offset, int *irq);
 struct tegra_twd_context {
 	u32 twd_ctrl;
 	u32 twd_load;
+	u32 twd_cnt;
 };
 
 #ifdef CONFIG_HAVE_ARM_TWD
+int tegra_twd_get_state(struct tegra_twd_context *context);
 void tegra_twd_suspend(struct tegra_twd_context *context);
 void tegra_twd_resume(struct tegra_twd_context *context);
 #else
+static inline int tegra_twd_get_state(struct tegra_twd_context *context)
+{ return -ENODEV; }
 static inline void tegra_twd_suspend(struct tegra_twd_context *context) {}
 static inline void tegra_twd_resume(struct tegra_twd_context *context) {}
 #endif
diff --git a/arch/arm/mach-tegra/usb_phy.c b/arch/arm/mach-tegra/usb_phy.c
index aa4216f..81e41ec 100644
--- a/arch/arm/mach-tegra/usb_phy.c
+++ b/arch/arm/mach-tegra/usb_phy.c
@@ -38,6 +38,7 @@
 #include "pm-irq.h"
 
 #define MODULE_NAME "[USBPHY] "
+#define DOCK_VBUS_DEBOUNCE 0.5*HZ
 
 
 
@@ -607,6 +608,12 @@ static u32 utmip_rctrl_val, utmip_tctrl_val;
 #define TDPSRC_CON_MS	 40
 #define CONNECT_DETECT_TIMEOUT		       25000
 
+#define AHB_MEM_PREFETCH_CFG3		0xe0
+#define AHB_MEM_PREFETCH_CFG4		0xe4
+#define AHB_MEM_PREFETCH_CFG1		0xec
+#define AHB_MEM_PREFETCH_CFG2		0xf0
+#define PREFETCH_ENB			(1 << 31)
+
 static DEFINE_SPINLOCK(utmip_pad_lock);
 static int utmip_pad_count;
 
@@ -2511,7 +2518,7 @@ static irqreturn_t usb_phy_vbus_irq_thr(int irq, void *pdata)
 	//usb_check_vbus_detection();
 #endif
 #ifdef CONFIG_CABLE_DETECT_ACCESSORY
-	cable_detection_queue_vbus_work(0);
+	cable_detection_queue_vbus_work(DOCK_VBUS_DEBOUNCE);
 #endif
 	adb_count_set(0);
 	pr_info(MODULE_NAME "%s: done\n", __func__); /* HTC */
@@ -3310,6 +3317,36 @@ int __init tegra_usb_phy_init(struct usb_phy_plat_data *pdata, int size)
 	return 0;
 }
 
+void tegra_usb_phy_memory_prefetch_on(struct tegra_usb_phy *phy)
+{
+	void __iomem *ahb_gizmo = IO_ADDRESS(TEGRA_AHB_GIZMO_BASE);
+	unsigned long val;
+
+	if (phy->instance == 0 && phy->mode == TEGRA_USB_PHY_MODE_DEVICE) {
+		val = readl(ahb_gizmo + AHB_MEM_PREFETCH_CFG1);
+		val |= PREFETCH_ENB;
+		writel(val, ahb_gizmo + AHB_MEM_PREFETCH_CFG1);
+		val = readl(ahb_gizmo + AHB_MEM_PREFETCH_CFG2);
+		val |= PREFETCH_ENB;
+		writel(val, ahb_gizmo + AHB_MEM_PREFETCH_CFG2);
+	}
+}
+
+void tegra_usb_phy_memory_prefetch_off(struct tegra_usb_phy *phy)
+{
+	void __iomem *ahb_gizmo = IO_ADDRESS(TEGRA_AHB_GIZMO_BASE);
+	unsigned long val;
+
+	if (phy->instance == 0 && phy->mode == TEGRA_USB_PHY_MODE_DEVICE) {
+		val = readl(ahb_gizmo + AHB_MEM_PREFETCH_CFG1);
+		val &= ~(PREFETCH_ENB);
+		writel(val, ahb_gizmo + AHB_MEM_PREFETCH_CFG1);
+		val = readl(ahb_gizmo + AHB_MEM_PREFETCH_CFG2);
+		val &= ~(PREFETCH_ENB);
+		writel(val, ahb_gizmo + AHB_MEM_PREFETCH_CFG2);
+	}
+}
+
 /* disable walk and wake events after resume from LP0 */
 bool tegra_usb_phy_is_remotewake_detected(struct tegra_usb_phy *phy)
 {
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index d1182b6..e979fb8 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -201,6 +201,10 @@ ENTRY(v7_coherent_user_range)
 	dcache_line_size r2, r3
 	sub	r3, r2, #1
 	bic	r12, r0, r3
+#ifdef CONFIG_ARM_ERRATA_764369
+	ALT_SMP(W(dsb))
+	ALT_UP(W(nop))
+#endif
 1:
  USER(	mcr	p15, 0, r12, c7, c11, 1	)	@ clean D line to the point of unification
 	add	r12, r12, r2
@@ -250,6 +254,10 @@ ENTRY(v7_flush_kern_dcache_area)
 	add	r1, r0, r1
 	sub	r3, r2, #1
 	bic	r0, r0, r3
+#ifdef CONFIG_ARM_ERRATA_764369
+	ALT_SMP(W(dsb))
+	ALT_UP(W(nop))
+#endif
 1:
 	mcr	p15, 0, r0, c7, c14, 1		@ clean & invalidate D line / unified line
 	add	r0, r0, r2
@@ -274,6 +282,10 @@ v7_dma_inv_range:
 	sub	r3, r2, #1
 	tst	r0, r3
 	bic	r0, r0, r3
+#ifdef CONFIG_ARM_ERRATA_764369
+	ALT_SMP(W(dsb))
+	ALT_UP(W(nop))
+#endif
 	mcrne	p15, 0, r0, c7, c14, 1		@ clean & invalidate D / U line
 
 	tst	r1, r3
@@ -297,6 +309,10 @@ v7_dma_clean_range:
 	dcache_line_size r2, r3
 	sub	r3, r2, #1
 	bic	r0, r0, r3
+#ifdef CONFIG_ARM_ERRATA_764369
+	ALT_SMP(W(dsb))
+	ALT_UP(W(nop))
+#endif
 1:
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D / U line
 	add	r0, r0, r2
@@ -315,6 +331,10 @@ ENTRY(v7_dma_flush_range)
 	dcache_line_size r2, r3
 	sub	r3, r2, #1
 	bic	r0, r0, r3
+#ifdef CONFIG_ARM_ERRATA_764369
+	ALT_SMP(W(dsb))
+	ALT_UP(W(nop))
+#endif
 1:
 	mcr	p15, 0, r0, c7, c14, 1		@ clean & invalidate D / U line
 	add	r0, r0, r2
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index e1944a9..2f58451 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1103,7 +1103,8 @@ aruba			MACH_ARUBA		ARUBA			3437
 cardhu			MACH_CARDHU		CARDHU			3436
 tegra_enterprise	MACH_TEGRA_ENTERPRISE	TEGRA_ENTERPRISE	3512
 p852			MACH_P852		P852			3667
-vertexf			MACH_VERTEXF		VERTEXF		3703
-vertexfp		MACH_VERTEXFP		VERTEXFP	3704
-endeavortd		MACH_ENDEAVORTD		ENDEAVORTD		3784
+vertexf			MACH_VERTEXF		VERTEXF			3703
+vertexfp		MACH_VERTEXFP		VERTEXFP		3704
 endeavoru		MACH_ENDEAVORU		ENDEAVORU		3783
+endeavortd		MACH_ENDEAVORTD		ENDEAVORTD		3784
+erau			MACH_ERAU		ERAU			4048
diff --git a/drivers/base/cpu.c b/drivers/base/cpu.c
index 51f9f03..dd2d21b 100644
--- a/drivers/base/cpu.c
+++ b/drivers/base/cpu.c
@@ -334,7 +334,7 @@ int __init cpu_dev_init(void)
 		err = sched_create_sysfs_power_savings_entries(&cpu_sysdev_class);
 #endif
 
-    INIT_WORK(&cpuplug_work, tegra_cpuplug_work_func);
+	INIT_WORK(&cpuplug_work, tegra_cpuplug_work_func);
 
 	return err;
 }
diff --git a/drivers/cpufreq/cpufreq_ondemand.c b/drivers/cpufreq/cpufreq_ondemand.c
index f299043..e1ab330 100644
--- a/drivers/cpufreq/cpufreq_ondemand.c
+++ b/drivers/cpufreq/cpufreq_ondemand.c
@@ -45,6 +45,8 @@
 #define MAX_FREQUENCY_UP_THRESHOLD		(100)
 #define DEF_SAMPLING_RATE			(50000)
 #define DEF_IO_IS_BUSY				(1)
+#define DEF_UI_DYNAMIC_SAMPLING_RATE		(30000)
+#define DEF_UI_COUNTER				(5)
 
 /*
  * The polling frequency of this governor depends on the capability of
@@ -107,6 +109,7 @@ struct cpu_dbs_info_s {
 static DEFINE_PER_CPU(struct cpu_dbs_info_s, od_cpu_dbs_info);
 
 static unsigned int dbs_enable;	/* number of CPUs using this policy */
+static unsigned int g_ui_counter = 0;
 
 /*
  * dbs_mutex protects dbs_enable in governor start/stop.
@@ -125,6 +128,9 @@ static struct dbs_tuners {
 	unsigned int two_phase_freq;
 #endif
 	unsigned int touch_poke;
+	unsigned int origin_sampling_rate;
+	unsigned int ui_sampling_rate;
+	unsigned int ui_counter;
 } dbs_tuners_ins = {
 	.up_threshold = DEF_FREQUENCY_UP_THRESHOLD,
 	.sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR,
@@ -135,6 +141,8 @@ static struct dbs_tuners {
 	.two_phase_freq = 0,
 #endif
 	.touch_poke = 1,
+	.ui_sampling_rate = DEF_UI_DYNAMIC_SAMPLING_RATE,
+	.ui_counter = DEF_UI_COUNTER,
 };
 
 static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu,
@@ -271,12 +279,15 @@ show_one(sampling_rate, sampling_rate);
 show_one(io_is_busy, io_is_busy);
 show_one(up_threshold, up_threshold);
 show_one(sampling_down_factor, sampling_down_factor);
+show_one(down_differential, down_differential);
 show_one(ignore_nice_load, ignore_nice);
 show_one(powersave_bias, powersave_bias);
 #ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE
 show_one(two_phase_freq, two_phase_freq);
 #endif
 show_one(touch_poke, touch_poke);
+show_one(ui_sampling_rate, ui_sampling_rate);
+show_one(ui_counter, ui_counter);
 static ssize_t store_sampling_rate(struct kobject *a, struct attribute *b,
 				   const char *buf, size_t count)
 {
@@ -286,6 +297,7 @@ static ssize_t store_sampling_rate(struct kobject *a, struct attribute *b,
 	if (ret != 1)
 		return -EINVAL;
 	dbs_tuners_ins.sampling_rate = max(input, min_sampling_rate);
+	dbs_tuners_ins.origin_sampling_rate = dbs_tuners_ins.sampling_rate;
 	return count;
 }
 #ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE
@@ -304,16 +316,39 @@ static ssize_t store_two_phase_freq(struct kobject *a, struct attribute *b,
 }
 #endif
 
+static unsigned int Touch_poke_attr[4] = {1500000, 880000, 0, 0};
+static unsigned int Touch_poke_boost_duration_ms = 0;
+static unsigned long Touch_poke_boost_till_jiffies = 0;
+
 static ssize_t store_touch_poke(struct kobject *a, struct attribute *b,
 				   const char *buf, size_t count)
 {
+	int ret;
+	ret = sscanf(buf, "%u,%u,%u,%u,%u", &Touch_poke_attr[0], &Touch_poke_attr[1],
+		&Touch_poke_attr[2], &Touch_poke_attr[3], &Touch_poke_boost_duration_ms);
+	if (ret < 4)
+		return -EINVAL;
+
+	if (ret != 5)
+		Touch_poke_boost_duration_ms = 0;
+
+	if(Touch_poke_attr[0] == 0)
+		dbs_tuners_ins.touch_poke = 0;
+	else
+		dbs_tuners_ins.touch_poke = 1;
+
+	return count;
+}
+static ssize_t store_ui_sampling_rate(struct kobject *a, struct attribute *b,
+					const char *buf, size_t count)
+{
 	unsigned int input;
 	int ret;
 	ret = sscanf(buf, "%u", &input);
 	if (ret != 1)
 		return -EINVAL;
 
-	dbs_tuners_ins.touch_poke = input;
+	dbs_tuners_ins.ui_sampling_rate = max(input, min_sampling_rate);
 
 	return count;
 }
@@ -346,6 +381,21 @@ static ssize_t store_up_threshold(struct kobject *a, struct attribute *b,
 	return count;
 }
 
+static ssize_t store_down_differential(struct kobject *a, struct attribute *b,
+					const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if(ret != 1 || input > DEF_FREQUENCY_DOWN_DIFFERENTIAL ||
+			input < MICRO_FREQUENCY_DOWN_DIFFERENTIAL) {
+		return -EINVAL;
+	}
+	dbs_tuners_ins.down_differential = input;
+	return count;
+}
+
 static ssize_t store_sampling_down_factor(struct kobject *a,
 			struct attribute *b, const char *buf, size_t count)
 {
@@ -417,9 +467,24 @@ static ssize_t store_powersave_bias(struct kobject *a, struct attribute *b,
 	return count;
 }
 
+static ssize_t store_ui_counter(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+	if(ret != 1)
+		return -EINVAL;
+
+	dbs_tuners_ins.ui_counter = input;
+	return count;
+}
+
 define_one_global_rw(sampling_rate);
 define_one_global_rw(io_is_busy);
 define_one_global_rw(up_threshold);
+define_one_global_rw(down_differential);
 define_one_global_rw(sampling_down_factor);
 define_one_global_rw(ignore_nice_load);
 define_one_global_rw(powersave_bias);
@@ -427,11 +492,14 @@ define_one_global_rw(powersave_bias);
 define_one_global_rw(two_phase_freq);
 #endif
 define_one_global_rw(touch_poke);
+define_one_global_rw(ui_sampling_rate);
+define_one_global_rw(ui_counter);
 
 static struct attribute *dbs_attributes[] = {
 	&sampling_rate_min.attr,
 	&sampling_rate.attr,
 	&up_threshold.attr,
+	&down_differential.attr,
 	&sampling_down_factor.attr,
 	&ignore_nice_load.attr,
 	&powersave_bias.attr,
@@ -440,6 +508,8 @@ static struct attribute *dbs_attributes[] = {
 	&two_phase_freq.attr,
 #endif
 	&touch_poke.attr,
+	&ui_sampling_rate.attr,
+	&ui_counter.attr,
 	NULL
 };
 
@@ -486,6 +556,12 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 	policy = this_dbs_info->cur_policy;
 
 	/*
+	 * keep freq for touch boost
+	 */
+	if (Touch_poke_boost_till_jiffies > jiffies)
+		return;
+
+	/*
 	 * Every sampling_rate, we check, if current idle time is less
 	 * than 20% (default), then we try to increase frequency
 	 * Every sampling_rate, we look for a the lowest
@@ -568,6 +644,12 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 		}
 	}
 
+	if (g_ui_counter > 0){
+		g_ui_counter--;
+		if(g_ui_counter == 0)
+			dbs_tuners_ins.sampling_rate = dbs_tuners_ins.origin_sampling_rate;
+	}
+
 	/* Check for frequency increase */
 	if (max_load_freq > dbs_tuners_ins.up_threshold * policy->cur) {
 		/* If switching to max speed, apply sampling_down_factor */
@@ -575,7 +657,16 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 		if (policy->cur < policy->max)
 			this_dbs_info->rate_mult =
 				dbs_tuners_ins.sampling_down_factor;
+		debug_freq = policy->max;
 		dbs_freq_increase(policy, policy->max);
+
+		CPU_DEBUG_PRINTK(CPU_DEBUG_GOVERNOR, " cpu%d,"
+                                " load=%3u, iowait=%3u,"
+                                " freq=%7u(%7u)",
+                                policy->cpu,
+                                debug_load, debug_iowait,
+                                debug_freq, policy->cur);
+
 #else
 		if (counter < 5) {
 			counter++;
@@ -596,7 +687,6 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 			debug_freq = policy->max;
 			dbs_freq_increase(policy, policy->max);
 		}
-#endif
 
 		CPU_DEBUG_PRINTK(CPU_DEBUG_GOVERNOR, " cpu%d,"
                                 " load=%3u, iowait=%3u,"
@@ -604,6 +694,8 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
                                 policy->cpu,
                                 debug_load, debug_iowait,
                                 debug_freq, policy->cur, counter, phase);
+
+#endif
 		return;
 	}
 #ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE
@@ -651,12 +743,22 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 				CPUFREQ_RELATION_L);
 		}
 
+#ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE
 		CPU_DEBUG_PRINTK(CPU_DEBUG_GOVERNOR, " cpu%d,"
                                 " load=%3u, iowait=%3u,"
                                 " freq=%7u(%7u), counter=%d, phase=%d",
                                 policy->cpu,
                                 debug_load, debug_iowait,
                                 debug_freq, policy->cur, counter, phase);
+#else
+		CPU_DEBUG_PRINTK(CPU_DEBUG_GOVERNOR, " cpu%d,"
+                                " load=%3u, iowait=%3u,"
+                                " freq=%7u(%7u)",
+                                policy->cpu,
+                                debug_load, debug_iowait,
+                                debug_freq, policy->cur);
+
+#endif
 	}
 }
 
@@ -773,9 +875,21 @@ static void dbs_chown(void)
 	if (ret)
 		pr_err("sys_chown up_threshold error: %d", ret);
 
+	ret = sys_chown("/sys/devices/system/cpu/cpufreq/ondemand/down_differential", low2highuid(AID_SYSTEM), low2highgid(0));
+	if (ret)
+		pr_err("sys_chown down_differential error: %d", ret);
+
 	ret = sys_chown("/sys/devices/system/cpu/cpufreq/ondemand/touch_poke", low2highuid(AID_SYSTEM), low2highgid(0));
 	if (ret)
 		pr_err("sys_chown touch_poke error: %d", ret);
+
+	ret = sys_chown("/sys/devices/system/cpu/cpufreq/ondemand/ui_sampling_rate", low2highuid(AID_SYSTEM), low2highgid(0));
+	if (ret)
+		pr_err("sys_chown ui_sampling_rate error: %d", ret);
+
+	ret = sys_chown("/sys/devices/system/cpu/cpufreq/ondemand/ui_counter", low2highuid(AID_SYSTEM), low2highgid(0));
+	if (ret)
+		pr_err("sys_chown ui_counter error: %d", ret);
 }
 
 static void dbs_refresh_callback(struct work_struct *unused)
@@ -783,42 +897,38 @@ static void dbs_refresh_callback(struct work_struct *unused)
 	struct cpufreq_policy *policy;
 	struct cpu_dbs_info_s *this_dbs_info;
 	unsigned int nr_cpus;
+	unsigned int touch_poke_freq;
+	unsigned int cpu = smp_processor_id();
 
-	if (lock_policy_rwsem_write(0) < 0)
+	if (lock_policy_rwsem_write(cpu) < 0)
 		return;
 
-	this_dbs_info = &per_cpu(od_cpu_dbs_info, 0);
+	this_dbs_info = &per_cpu(od_cpu_dbs_info, cpu);
 	policy = this_dbs_info->cur_policy;
 
-	/* We don't want to raise cpu frequency if
-	 * the online cpu numbers is larger than 2
-	 */
+	g_ui_counter = dbs_tuners_ins.ui_counter;
+	if(dbs_tuners_ins.ui_counter > 0)
+		dbs_tuners_ins.sampling_rate = dbs_tuners_ins.ui_sampling_rate;
+	if (Touch_poke_boost_duration_ms)
+		Touch_poke_boost_till_jiffies =
+			jiffies + msecs_to_jiffies(Touch_poke_boost_duration_ms);
+
+	/* We poke the frequency base on the online cpu number */
 	nr_cpus = num_online_cpus();
 
-	switch (nr_cpus) {
-	case 1:
-		if (policy->cur < policy->max) {
-			__cpufreq_driver_target(policy, policy->max,
-				CPUFREQ_RELATION_L);
-			this_dbs_info->prev_cpu_idle = get_cpu_idle_time(0,
-				&this_dbs_info->prev_cpu_wall);
-		}
-		break;
-	case 2:
-		if (policy->cur < policy->max && policy->cur < 880000) {
-			__cpufreq_driver_target(policy, 880000,
-				CPUFREQ_RELATION_L);
-			this_dbs_info->prev_cpu_idle = get_cpu_idle_time(0,
-				&this_dbs_info->prev_cpu_wall);
-		}
-		break;
-	case 3:
-	case 4:
-	default:
-		break;
+	touch_poke_freq = Touch_poke_attr[nr_cpus-1];
+
+	if(touch_poke_freq == 0 || policy->cur >= touch_poke_freq){
+		unlock_policy_rwsem_write(cpu);
+		return;
 	}
 
-	unlock_policy_rwsem_write(0);
+	__cpufreq_driver_target(policy, touch_poke_freq,
+		CPUFREQ_RELATION_L);
+	this_dbs_info->prev_cpu_idle = get_cpu_idle_time(cpu,
+		&this_dbs_info->prev_cpu_wall);
+
+	unlock_policy_rwsem_write(cpu);
 }
 
 static DECLARE_WORK(dbs_refresh_work, dbs_refresh_callback);
@@ -959,6 +1069,7 @@ static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 				    latency * LATENCY_MULTIPLIER);
 			if (def_sampling_rate)
 				dbs_tuners_ins.sampling_rate = def_sampling_rate;
+			dbs_tuners_ins.origin_sampling_rate = dbs_tuners_ins.sampling_rate;
 			dbs_tuners_ins.io_is_busy = should_io_be_busy();
 		}
 		if (!cpu)
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 4abbc09..9303b67 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -61,7 +61,11 @@ void cpu_idle_debug_show(void)
 		lp3_cpu[i] = dev->states[0].time;
 
 	}
-	pr_pwr_story("%llu us, %llu us, %llu us, %llu us, %llu us, %llu us, %llu us, %llu us", lp2_cpu[0], lp3_cpu[0], lp2_cpu[1], lp3_cpu[1], lp2_cpu[2], lp3_cpu[2], lp2_cpu[3], lp3_cpu[3]);
+	/*
+	 * pr_pwr_story("%llu us, %llu us, %llu us, %llu us, %llu us,
+		 %llu us, %llu us, %llu us", lp2_cpu[0], lp3_cpu[0],
+		 lp2_cpu[1], lp3_cpu[1], lp2_cpu[2], lp3_cpu[2], lp2_cpu[3], lp3_cpu[3]);
+	 */
 }
 
 /**
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 1c19ee1..36a2974 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -11,7 +11,7 @@
 #include <linux/of_gpio.h>
 #include <linux/idr.h>
 #include <linux/slab.h>
-#include <htc/log.h>
+
 
 /* Optional implementation infrastructure for GPIO interfaces.
  *
@@ -179,7 +179,7 @@ int __init gpiochip_reserve(int start, int ngpio)
 		set_bit(FLAG_RESERVED, &desc->flags);
 	}
 
-	sp_pr_debug("%s: reserved gpios from %d to %d\n",
+	pr_debug("%s: reserved gpios from %d to %d\n",
 		 __func__, start, start + ngpio - 1);
 err:
 	spin_unlock_irqrestore(&gpio_lock, flags);
@@ -1217,7 +1217,7 @@ int gpio_request(unsigned gpio, const char *label)
 
 done:
 	if (status)
-		sp_pr_debug("gpio_request: gpio-%d (%s) status %d\n",
+		pr_debug("gpio_request: gpio-%d (%s) status %d\n",
 			gpio, label ? : "?", status);
 	spin_unlock_irqrestore(&gpio_lock, flags);
 	return status;
diff --git a/drivers/i2c/busses/i2c-tegra.c b/drivers/i2c/busses/i2c-tegra.c
index 33425f7..55de884 100644
--- a/drivers/i2c/busses/i2c-tegra.c
+++ b/drivers/i2c/busses/i2c-tegra.c
@@ -111,6 +111,8 @@
 #define SL_ADDR1(addr) (addr & 0xff)
 #define SL_ADDR2(addr) ((addr >> 8) & 0xff)
 
+#define VALID_PTR (void *)0x1000
+
 
 
 struct tegra_i2c_dev;
@@ -272,9 +274,21 @@ static int tegra_i2c_empty_rx_fifo(struct tegra_i2c_dev *i2c_dev)
 {
 	u32 val;
 	int rx_fifo_avail;
-	u8 *buf = i2c_dev->msg_buf;
-	size_t buf_remaining = i2c_dev->msg_buf_remaining;
+	u8 *buf;
+	size_t buf_remaining;
 	int words_to_transfer;
+	unsigned long flags;
+
+	spin_lock_irqsave(&i2c_dev->fifo_lock, flags);
+	buf = i2c_dev->msg_buf;
+	buf_remaining = i2c_dev->msg_buf_remaining;
+
+	if (!i2c_dev->msg_buf_remaining || !i2c_dev->msg_buf) {
+		dev_err(i2c_dev->dev,
+			"%s() Illegal message remianing and length\n", __func__);
+		spin_unlock_irqrestore(&i2c_dev->fifo_lock, flags);
+		return -EINVAL;
+	}
 
 	val = i2c_readl(i2c_dev, I2C_FIFO_STATUS);
 	rx_fifo_avail = (val & I2C_FIFO_STATUS_RX_MASK) >>
@@ -306,12 +320,15 @@ static int tegra_i2c_empty_rx_fifo(struct tegra_i2c_dev *i2c_dev)
 	BUG_ON(rx_fifo_avail > 0 && buf_remaining > 0);
 	i2c_dev->msg_buf_remaining = buf_remaining;
 	i2c_dev->msg_buf = buf;
+	spin_unlock_irqrestore(&i2c_dev->fifo_lock, flags);
 	return 0;
 }
 
 static int tegra_i2c_fill_tx_fifo(struct tegra_i2c_dev *i2c_dev)
 {
 	u32 val;
+	u8 *valp = (u8 *)&val;
+	u8 i;
 	int tx_fifo_avail;
 	u8 *buf;
 	size_t buf_remaining;
@@ -319,13 +336,22 @@ static int tegra_i2c_fill_tx_fifo(struct tegra_i2c_dev *i2c_dev)
 	unsigned long flags;
 
 	spin_lock_irqsave(&i2c_dev->fifo_lock, flags);
-	if (!i2c_dev->msg_buf_remaining) {
+	if (!i2c_dev->msg_buf_remaining || !i2c_dev->msg_buf) {
 		spin_unlock_irqrestore(&i2c_dev->fifo_lock, flags);
-		return 0;
+		return -EINVAL;
 	}
 
 	buf = i2c_dev->msg_buf;
 	buf_remaining = i2c_dev->msg_buf_remaining;
+	if (!buf) {
+		dev_err(i2c_dev->dev,
+			"I2C error 1,  buf = %p, buf_remaining = %d\n",
+			buf, buf_remaining);
+
+		spin_unlock_irqrestore(&i2c_dev->fifo_lock, flags);
+		BUG();
+		return 0;
+	}
 
 	val = i2c_readl(i2c_dev, I2C_FIFO_STATUS);
 	tx_fifo_avail = (val & I2C_FIFO_STATUS_TX_MASK) >>
@@ -357,6 +383,15 @@ static int tegra_i2c_fill_tx_fifo(struct tegra_i2c_dev *i2c_dev)
 
 		buf += words_to_transfer * BYTES_PER_FIFO_WORD;
 	}
+	if (!buf) {
+		dev_err(i2c_dev->dev,
+			"I2C error 2,  buf = %p, buf_remaining = %d\n",
+			buf, buf_remaining);
+
+		spin_unlock_irqrestore(&i2c_dev->fifo_lock, flags);
+		BUG();
+		return 0;
+	}
 
 	/*
 	 * If there is a partial word at the end of buf, handle it manually to
@@ -370,7 +405,11 @@ static int tegra_i2c_fill_tx_fifo(struct tegra_i2c_dev *i2c_dev)
 				buf_remaining);
 			BUG();
 		}
-		memcpy(&val, buf, buf_remaining);
+		BUG_ON(!i2c_dev->msg_buf);
+		BUG_ON(!buf);
+		val = 0;
+		for (i = 0; i < buf_remaining; i++)
+			valp[i] = buf[i];
 
 		/* Again update before writing to FIFO to make sure isr sees. */
 		i2c_dev->msg_buf_remaining = 0;
@@ -476,11 +515,6 @@ static irqreturn_t tegra_i2c_isr(int irq, void *dev_id)
 						i2c_dev->msg_add);
 		i2c_dev->msg_err |= I2C_ERR_UNKNOWN_INTERRUPT;
 
-		if (!i2c_dev->irq_disabled) {
-			disable_irq_nosync(i2c_dev->irq);
-			i2c_dev->irq_disabled = 1;
-		}
-
 		goto err;
 	}
 
@@ -542,9 +576,12 @@ static irqreturn_t tegra_i2c_isr(int irq, void *dev_id)
 	}
 
 	i2c_writel(i2c_dev, status, I2C_INT_STATUS);
+	i2c_readl(i2c_dev, I2C_INT_STATUS);
 
-	if (i2c_dev->is_dvc)
+	if (i2c_dev->is_dvc) {
 		dvc_writel(i2c_dev, DVC_STATUS_I2C_DONE_INTR, DVC_STATUS);
+		dvc_readl(i2c_dev, DVC_STATUS);
+	}
 
 	if ((status & I2C_INT_PACKET_XFER_COMPLETE) &&
 			!i2c_dev->msg_buf_remaining)
@@ -579,13 +616,16 @@ err:
 		I2C_INT_RX_FIFO_DATA_REQ | I2C_INT_TX_FIFO_OVERFLOW);
 
 	i2c_writel(i2c_dev, status, I2C_INT_STATUS);
+	i2c_readl(i2c_dev, I2C_INT_STATUS);
 
 	/* An error occured, mask dvc interrupt */
 	if (i2c_dev->is_dvc)
 		dvc_i2c_mask_irq(i2c_dev, DVC_CTRL_REG3_I2C_DONE_INTR_EN);
 
-	if (i2c_dev->is_dvc)
+	if (i2c_dev->is_dvc) {
 		dvc_writel(i2c_dev, DVC_STATUS_I2C_DONE_INTR, DVC_STATUS);
+		dvc_readl(i2c_dev, DVC_STATUS);
+	}
 
 	complete(&i2c_dev->msg_complete);
 	return IRQ_HANDLED;
@@ -700,10 +740,10 @@ static int tegra_i2c_xfer_msg(struct tegra_i2c_bus *i2c_bus,
 
 bool tegra_i2c_is_ready(struct i2c_adapter *adap)
 {
-	struct tegra_i2c_bus *i2c_bus = i2c_get_adapdata(adap);
-	struct tegra_i2c_dev *i2c_dev = i2c_bus->dev;
+        struct tegra_i2c_bus *i2c_bus = i2c_get_adapdata(adap);
+        struct tegra_i2c_dev *i2c_dev = i2c_bus->dev;
 
-	return !(i2c_dev->is_suspended);
+        return !(i2c_dev->is_suspended);
 }
 EXPORT_SYMBOL(tegra_i2c_is_ready);
 
@@ -715,6 +755,8 @@ static int tegra_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
 	int i;
 	int ret = 0;
 
+	WARN(!num, "The number of message is zero\n");
+
 	if (i2c_dev->is_suspended)
 		return -EBUSY;
 
@@ -742,6 +784,16 @@ static int tegra_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
 
 	for (i = 0; i < num; i++) {
 		int stop = (i == (num - 1)) ? 1  : 0;
+
+		if (msgs[i].buf < VALID_PTR || !msgs[i].len) {
+			dev_err(i2c_dev->dev,
+				"Illegal messages buffer and length\n");
+			WARN_ON(1);
+			rt_mutex_unlock(&i2c_dev->dev_lock);
+			i2c_dev->msgs = NULL;
+			i2c_dev->msgs_num = 0;
+			return -EINVAL;
+		}
 		ret = tegra_i2c_xfer_msg(i2c_bus, &msgs[i], stop);
 		if (ret)
 			break;
@@ -866,7 +918,7 @@ static int tegra_i2c_probe(struct platform_device *pdev)
 		goto err_free;
 	}
 
-	ret = request_irq(i2c_dev->irq, tegra_i2c_isr, 0, pdev->name, i2c_dev);
+	ret = request_irq(i2c_dev->irq, tegra_i2c_isr, IRQF_NO_SUSPEND, pdev->name, i2c_dev);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to request irq %i\n", i2c_dev->irq);
 		goto err_free;
@@ -909,6 +961,7 @@ static int tegra_i2c_probe(struct platform_device *pdev)
 		i2c_dev->bus_count++;
 	}
 
+	printk(KERN_INFO "[I2C] %s, tegra-i2c.%d done \n", __func__, pdev->id);
 	return 0;
 
 err_del_bus:
@@ -923,6 +976,7 @@ err_release_region:
 	release_mem_region(iomem->start, resource_size(iomem));
 err_iounmap:
 	iounmap(base);
+	printk(KERN_INFO "[I2C] %s, tegra-i2c.%d error \n", __func__, pdev->id);
 	return ret;
 }
 
@@ -950,6 +1004,9 @@ static int tegra_i2c_suspend_noirq(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct tegra_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
 
+	if (pdev->id == 0)
+		printk(KERN_INFO "[I2C] %s, bus_id=%d +\n", __func__, pdev->id);
+
 	rt_mutex_lock(&i2c_dev->dev_lock);
 
 	i2c_dev->is_suspended = true;
@@ -958,6 +1015,9 @@ static int tegra_i2c_suspend_noirq(struct device *dev)
 
 	rt_mutex_unlock(&i2c_dev->dev_lock);
 
+	if (pdev->id == 0)
+		printk(KERN_INFO "[I2C] %s, bus_id=%d -\n", __func__, pdev->id);
+
 	return 0;
 }
 
@@ -967,6 +1027,9 @@ static int tegra_i2c_resume_noirq(struct device *dev)
 	struct tegra_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
 	int ret;
 
+	if (pdev->id == 0)
+		printk(KERN_INFO "[I2C] %s, bus_id=%d +\n", __func__, pdev->id);
+
 	rt_mutex_lock(&i2c_dev->dev_lock);
 
 	if (i2c_dev->is_clkon_always)
@@ -983,6 +1046,9 @@ static int tegra_i2c_resume_noirq(struct device *dev)
 
 	rt_mutex_unlock(&i2c_dev->dev_lock);
 
+	if (pdev->id == 0)
+		printk(KERN_INFO "[I2C] %s, bus_id=%d -\n", __func__, pdev->id);
+
 	return 0;
 }
 
diff --git a/drivers/i2c/chips/akm8975_pana_gyro.c b/drivers/i2c/chips/akm8975_pana_gyro.c
index 852fbd2..a2e3f32 100644
--- a/drivers/i2c/chips/akm8975_pana_gyro.c
+++ b/drivers/i2c/chips/akm8975_pana_gyro.c
@@ -579,7 +579,7 @@ akmd_ioctl(struct file *file, unsigned int cmd,
 
 	char msg[RBUFF_SIZE_8975 + 1] = "", rwbuf[RBUFF_SIZE_8975 + 1] = "";
 	int ret = -1, status;
-	short mode, value[12], delay;
+	short mode = 0, value[12] = {0}, delay = 0;
 	short layouts[4][3][3];
 	int i, j, k;
 
diff --git a/drivers/i2c/chips/cm3628.c b/drivers/i2c/chips/cm3628.c
index 92ea243..93831d7 100644
--- a/drivers/i2c/chips/cm3628.c
+++ b/drivers/i2c/chips/cm3628.c
@@ -40,13 +40,8 @@
 #include <linux/suspend.h>
 #include "../../../arch/arm/mach-tegra/board.h"
 
-
-
 #define debug_flag 0
 #define D(x...) pr_info(x)
-#define DIF(x...) { \
-	if (debug_flag) \
-		printk(KERN_DEBUG "" x); }
 
 #define I2C_RETRY_COUNT 10
 
@@ -71,13 +66,6 @@ static DECLARE_DELAYED_WORK(polling_work, polling_do_work);
 static void report_near_do_work(struct work_struct *w);
 static DECLARE_DELAYED_WORK(report_near_work, report_near_do_work);
 
-//static void report_debounce_do_work(struct work_struct *w);
-//static DECLARE_DELAYED_WORK(report_debounce_work, report_debounce_do_work);
-struct ps_debounce_struct {
-    int status_val;
-    struct delayed_work report_debounce_work;
-};
-
 struct cm3628_info {
 	struct class *cm3628_class;
 	struct device *ls_dev;
@@ -89,7 +77,6 @@ struct cm3628_info {
 	struct early_suspend early_suspend;
 	struct i2c_client *i2c_client;
 	struct workqueue_struct *lp_wq;
-	struct ps_debounce_struct ps_debounce_work;
 
 	int intr_pin;
 
@@ -157,7 +144,6 @@ static int lightsensor_disable(struct cm3628_info *lpi);
 static int initial_cm3628(struct cm3628_info *lpi);
 static void psensor_initial_cmd(struct cm3628_info *lpi);
 
-
 static int I2C_RxData(uint16_t slaveAddr, uint8_t *rxData, int length)
 {
 	uint8_t loop_i;
@@ -284,7 +270,7 @@ static int _cm3628_I2C_Write_Byte(uint16_t SlaveAddress,
 
 	return ret;
 }
-static int get_ls_adc_value(uint16_t *als_step, bool resume)
+static int get_ls_adc_value(uint32_t *als_step, bool resume)
 {
 
 	struct cm3628_info *lpi = lp_info;
@@ -335,7 +321,7 @@ static int get_ls_adc_value(uint16_t *als_step, bool resume)
 	*als_step <<= 8;
 	*als_step |= (uint16_t)lsb;
 
-	DIF("[LS][CM3628] %s: raw adc = 0x%X, ls_calibrate = %d\n",
+	D("[LS][CM3628] %s: raw adc = 0x%X, ls_calibrate = %d\n",
 		__func__, *als_step, lpi->ls_calibrate);
 
 
@@ -407,33 +393,6 @@ static void report_near_do_work(struct work_struct *w)
 	wake_lock_timeout(&(lpi->ps_wake_lock), 2*HZ);
 }
 
-static int laststatus = 1;
-static unsigned long last_jiffies;
-static unsigned long period_jiffies = 0.35 * HZ;
-static void report_p_input(int nowstatus)
-{
-	mutex_lock(&ps_report_input_mutex);
-	struct cm3628_info *lpi = lp_info;
-	
-	if(laststatus != nowstatus) {
-		D("[PS][cm3628]  %s: report proximity status : %s\n", __func__, nowstatus ? "FAR" : "NEAR");
-		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, nowstatus);
-		input_sync(lpi->ps_input_dev);
-		blocking_notifier_call_chain(&psensor_notifier_list, nowstatus+2, NULL);
-	}
-
-	laststatus = nowstatus;
-	mutex_unlock(&ps_report_input_mutex);
-}
-
-static void report_debounce_do_work(struct work_struct *w)
-{
-	struct ps_debounce_struct *ps_debounce = container_of(w,
-				struct ps_debounce_struct, report_debounce_work);
-	int nowstatus = ps_debounce->status_val;
-	report_p_input(nowstatus);
-}
-
 static void report_psensor_input_event(struct cm3628_info *lpi, int interrupt_flag)
 {
 	uint8_t ps_data;
@@ -443,6 +402,13 @@ static void report_psensor_input_event(struct cm3628_info *lpi, int interrupt_fl
 	/*P-sensor disable but interrupt occur. It might init fail when power on.workaround: reinit*/
 		D("[PS][CM3628] proximity err, ps_enable %d, but intrrupt occur, record_init_fail %d, interrupt_flag %d\n",
 			lpi->ps_enable, record_init_fail, interrupt_flag);
+/*
+		 _cm3628_I2C_Write_Byte(lpi->PS_slave_address,
+		PS_cmd_cmd, 0x00);
+		psensor_initial_cmd(lpi);
+		_cm3628_I2C_Write_Byte(lpi->PS_slave_address,
+			PS_cmd_cmd,
+			lpi->ps_conf1_val |CM3628_PS_SD);*/
 		return;
 	}
 	if (lpi->ps_debounce == 1 &&
@@ -473,9 +439,7 @@ static void report_psensor_input_event(struct cm3628_info *lpi, int interrupt_fl
 			input_sync(lpi->ps_input_dev);
 		}
 	}
-
-	D("[PS][CM3628] proximity ps_data=%d\n", ps_data);
-
+	D("[PS][CM3628] proximity %s, ps_data=%d\n", val ? "FAR" : "NEAR", ps_data);
 	if ((lpi->enable_polling_ignore == 1) && (val == 0) &&
 		(lpi->mfg_mode != NO_IGNORE_BOOT_MODE) &&
 		(time_before(lpi->j_end, (lpi->j_start + NEAR_DELAY_TIME)))) {
@@ -483,18 +447,11 @@ static void report_psensor_input_event(struct cm3628_info *lpi, int interrupt_fl
 		lpi->ps_pocket_mode = 1;
 	} else {
 		/* 0 is close, 1 is far */
-		if(laststatus == 0) {
-			if(time_before_eq(jiffies, last_jiffies+period_jiffies)) {
-				cancel_delayed_work(&(lpi->ps_debounce_work.report_debounce_work));
-				D("[PS][cm3628] remove debounce.\n");
-			}
-			lpi->ps_debounce_work.status_val = val;
-			queue_delayed_work(lpi->lp_wq, &(lpi->ps_debounce_work.report_debounce_work), period_jiffies);
-			last_jiffies = jiffies;
-		}else {
-			report_p_input(val);
-		}
+		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, val);
+		input_sync(lpi->ps_input_dev);
+		blocking_notifier_call_chain(&psensor_notifier_list, val+2, NULL);
 	}
+
 }
 
 static void enable_als_int(void)/*enable als interrupt*/
@@ -516,7 +473,7 @@ static void enable_als_int(void)/*enable als interrupt*/
 
 static void report_lsensor_input_event(struct cm3628_info *lpi, bool resume)
 {/*when resume need report a data, so the paramerter need to quick reponse*/
-	uint16_t adc_value = 0;
+	uint32_t adc_value = 0;
 	int level = 0, i, ret = 0;
 
 	mutex_lock(&als_get_adc_mutex);
@@ -825,9 +782,6 @@ static int psensor_enable(struct cm3628_info *lpi)
 
 	psensor_initial_cmd(lpi);
 
-	/*p-sensor first jiffies setting*/
-	last_jiffies = jiffies;
-	laststatus = 1;
 
 	if (lpi->enable_polling_ignore == 1 &&
 		lpi->mfg_mode != NO_IGNORE_BOOT_MODE) {
@@ -1625,9 +1579,6 @@ static ssize_t ls_kadc_store(struct device *dev,
 		printk(KERN_ERR "[LS][CM3628 error] %s: update ls table fail\n", __func__);
 	mutex_unlock(&als_get_adc_mutex);
 
-	//lightsensor_disable(lpi);
-	//lightsensor_enable(lpi);
-
 	return count;
 }
 
@@ -2045,7 +1996,6 @@ static int cm3628_probe(struct i2c_client *client,
 		ret = -ENOMEM;
 		goto err_create_singlethread_workqueue;
 	}
-	INIT_DELAYED_WORK(&(lpi->ps_debounce_work.report_debounce_work), report_debounce_do_work);
 
 	wake_lock_init(&(lpi->ps_wake_lock), WAKE_LOCK_SUSPEND, "proximity");
 
diff --git a/drivers/i2c/chips/cm3629.c b/drivers/i2c/chips/cm3629.c
index ad2ee59..a1bfd81 100644
--- a/drivers/i2c/chips/cm3629.c
+++ b/drivers/i2c/chips/cm3629.c
@@ -40,9 +40,6 @@
 
 #define debug_flag 0
 #define D(x...) pr_info(x)
-#define DIF(x...) { \
-	if (debug_flag) \
-		printk(KERN_DEBUG "" x); }
 
 #define I2C_RETRY_COUNT 10
 
@@ -68,14 +65,6 @@ static uint8_t sensor_chipId[3] = {0};
 static void report_near_do_work(struct work_struct *w);
 static DECLARE_DELAYED_WORK(report_near_work, report_near_do_work);
 
-//static void report_debounce_do_work(struct work_struct *w);
-//static DECLARE_DELAYED_WORK(report_debounce_work, report_debounce_do_work, status_val);
-struct ps_debounce_struct {
-    int status_val;
-    struct delayed_work report_debounce_work;
-};
-
-
 struct cm3629_info {
 	struct class *cm3629_class;
 	struct device *ls_dev;
@@ -87,7 +76,6 @@ struct cm3629_info {
 	struct early_suspend early_suspend;
 	struct i2c_client *i2c_client;
 	struct workqueue_struct *lp_wq;
-	struct ps_debounce_struct ps_debounce_work;
 
 	int model;
 
@@ -337,7 +325,7 @@ static int _cm3629_I2C_Write2(uint16_t SlaveAddress,
 			__func__, length);
 		return ret;
 	}
-	
+
 	buffer[0] = cmd;
 	buffer[1] = *data;
 	buffer[2] = *(data+1);
@@ -396,7 +384,7 @@ static int _cm3629_I2C_Write_Byte(uint16_t SlaveAddress,
 	return ret;
 }
 #endif
-static int get_ls_adc_value(uint16_t *als_step, bool resume)
+static int get_ls_adc_value(uint32_t *als_step, bool resume)
 {
 
 	struct cm3629_info *lpi = lp_info;
@@ -442,11 +430,11 @@ static int get_ls_adc_value(uint16_t *als_step, bool resume)
 	lsb = cmd[0];
 	msb = cmd[1];
 
-	*als_step = (uint16_t)msb;
+	*als_step = (uint32_t)msb;
 	*als_step <<= 8;
-	*als_step |= (uint16_t)lsb;
+	*als_step |= (uint32_t)lsb;
 
-	DIF("[LS][cm3629] %s: raw adc = 0x%X, ls_calibrate = %d\n",
+	D("[LS][cm3629] %s: raw adc = 0x%X, ls_calibrate = %d\n",
 		__func__, *als_step, lpi->ls_calibrate);
 
 
@@ -495,7 +483,7 @@ static int set_lsensor_range(uint16_t low_thd, uint16_t high_thd)
 	uint8_t	high_lsb;
 	uint8_t	low_msb;
 	uint8_t	low_lsb;
-	DIF("[cm3629] %s: low_thd = 0x%X, high_thd = 0x%x \n",
+	D("[cm3629] %s: low_thd = 0x%X, high_thd = 0x%x \n",
 		__func__, low_thd, high_thd);
 	high_msb = (uint8_t) (high_thd >> 8);
 	high_lsb = (uint8_t) (high_thd & 0x00ff);
@@ -525,37 +513,6 @@ static void report_near_do_work(struct work_struct *w)
 	blocking_notifier_call_chain(&psensor_notifier_list, 2, NULL);
 }
 
-static int laststatus = 1;
-static unsigned long last_jiffies;
-static unsigned long period_jiffies = 0.35 * HZ;
-/* 1. nowstatus need to be local variable in report_psensor_input_event()
-	 and pass to report_p_input()
-    2. Add mutex to arround report_p_input()
-    3. enable_irq and unlock need to be set in report_p_input when prestatus == curstatus*/
-static void report_p_input(int nowstatus)
-{
-	mutex_lock(&ps_report_input_mutex);
-	struct cm3629_info *lpi = lp_info;
-	
-	if(laststatus != nowstatus) {
-		D("[PS][cm3629]  %s: report proximity status : %s\n", __func__, nowstatus ? "FAR" : "NEAR");
-		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, nowstatus);
-		input_sync(lpi->ps_input_dev);
-		blocking_notifier_call_chain(&psensor_notifier_list, nowstatus+2, NULL);
-	}
-
-	laststatus = nowstatus;
-	mutex_unlock(&ps_report_input_mutex);
-}
-
-static void report_debounce_do_work(struct work_struct *w)
-{
-	struct ps_debounce_struct *ps_debounce = container_of(w,
-				struct ps_debounce_struct, report_debounce_work);
-	int nowstatus = ps_debounce->status_val;
-	report_p_input(nowstatus);
-}
-
 static void report_psensor_input_event(struct cm3629_info *lpi, int interrupt_flag)
 {
 	uint8_t ps_thd_set = 0;
@@ -564,7 +521,7 @@ static void report_psensor_input_event(struct cm3629_info *lpi, int interrupt_fl
 	uint8_t ps2_adc = 0;
 	int val, ret = 0;
 
-	if (interrupt_flag == 1 && lpi->ps_enable == 0) {
+	if (interrupt_flag > 1 && lpi->ps_enable == 0) {
 		D("[PS][cm3629] P-sensor disable but intrrupt occur, "
 		  "record_init_fail %d.\n", record_init_fail);
 		return;
@@ -585,21 +542,24 @@ static void report_psensor_input_event(struct cm3629_info *lpi, int interrupt_fl
 		ps_thd_set = lpi->ps1_thd_set;
 		ps_adc = ps1_adc;
 	}
-
-	if (ret == 0) {
-		val = (ps_adc >= ps_thd_set) ? 0 : 1;
-	} else {/*i2c err, report far to workaround*/
-		val = 1;
-		ps_adc = 0;
-		D("[PS][cm3629] proximity i2c err, report %s, "
-		  "ps_adc=%d, record_init_fail %d\n",
-		  val ? "FAR" : "NEAR", ps_adc, record_init_fail);
+	if (interrupt_flag == 0) {/*interrupt_fla = 0 meam polling mode*/
+		if (ret == 0) {
+			val = (ps_adc >= ps_thd_set) ? 0 : 1;
+		} else {/*i2c err, report far to workaround*/
+			val = 1;
+			ps_adc = 0;
+			D("[PS][cm3629] proximity i2c err, report %s, "
+			  "ps_adc=%d, record_init_fail %d\n",
+			  val ? "FAR" : "NEAR", ps_adc, record_init_fail);
+		}
+	} else {/*interrupt_fla = 2 meam close isr,  interrupt_fla = 1 mean far isr*/
+		val = (interrupt_flag == 2) ? 0 : 1;
 	}
 
 	if (lpi->ps_debounce == 1 && lpi->mfg_mode != NO_IGNORE_BOOT_MODE) {
 		if (val == 0) {
-			D("[PS][cm3629] delay proximity %s, ps_adc=%d\n",
-			  val ? "FAR" : "NEAR", ps_adc);
+			D("[PS][cm3629] delay proximity %s, ps_adc=%d, High thd= %d, interrupt_flag %d\n",
+			  val ? "FAR" : "NEAR", ps_adc, ps_thd_set, interrupt_flag);
 			queue_delayed_work(lpi->lp_wq, &report_near_work,
 					msecs_to_jiffies(lpi->ps_delay_time));
 			return;
@@ -609,9 +569,8 @@ static void report_psensor_input_event(struct cm3629_info *lpi, int interrupt_fl
 			input_sync(lpi->ps_input_dev);
 		}
 	}
-
-	D("[PS][cm3629] proximity ps_adc=%d\n", ps_adc);
-
+	D("[PS][cm3629] proximity %s, ps_adc=%d, , High thd= %d, interrupt_flag %d\n",
+	  val ? "FAR" : "NEAR", ps_adc, ps_thd_set, interrupt_flag);
 	if ((lpi->enable_polling_ignore == 1) && (val == 0) &&
 		(lpi->mfg_mode != NO_IGNORE_BOOT_MODE) &&
 		(time_before(lpi->j_end, (lpi->j_start + NEAR_DELAY_TIME)))) {
@@ -619,17 +578,9 @@ static void report_psensor_input_event(struct cm3629_info *lpi, int interrupt_fl
 		lpi->ps_pocket_mode = 1;
 	} else {
 		/* 0 is close, 1 is far */
-		if(laststatus == 0) {
-			if(time_before_eq(jiffies, last_jiffies+period_jiffies)) {
-				cancel_delayed_work(&(lpi->ps_debounce_work.report_debounce_work));
-				D("[PS][cm3629] remove debounce.\n");
-			}
-			lpi->ps_debounce_work.status_val = val;
-			queue_delayed_work(lpi->lp_wq, &(lpi->ps_debounce_work.report_debounce_work), period_jiffies);
-			last_jiffies = jiffies;
-		}else {
-			report_p_input(val);
-		}
+		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, val);
+		input_sync(lpi->ps_input_dev);
+		blocking_notifier_call_chain(&psensor_notifier_list, val+2, NULL);
 	}
 }
 
@@ -652,7 +603,7 @@ static void enable_als_interrupt(void)/*enable als interrupt*/
 
 static void report_lsensor_input_event(struct cm3629_info *lpi, bool resume)
 {/*when resume need report a data, so the paramerter need to quick reponse*/
-	uint16_t adc_value = 0;
+	uint32_t adc_value = 0;
 	int level = 0, i, ret = 0;
 
 	mutex_lock(&als_get_adc_mutex);
@@ -670,7 +621,7 @@ static void report_lsensor_input_event(struct cm3629_info *lpi, bool resume)
 			if (*(lpi->adc_table + i))
 				break;
 		}
-		if ( i == 9) {/*avoid  i = 10, because 'cali_table' of size is 10 */
+		if (i == 9) {/*avoid  i = 10, because 'cali_table' of size is 10 */
 			level = i;
 			break;
 		}
@@ -772,9 +723,11 @@ static void sensor_irq_do_work(struct work_struct *work)
 	/* D("[cm3629] %s:, INTERRUPT = 0x%x \n", __func__, add); */
 	if ((add & CM3629_PS1_IF_AWAY) || (add & CM3629_PS1_IF_CLOSE) ||
 	    (add & CM3629_PS2_IF_AWAY) || (add & CM3629_PS2_IF_CLOSE)) {
-		report_psensor_input_event(lpi, 1);
-	}
-	else if (((add & CM3629_ALS_IF_L) == CM3629_ALS_IF_L) ||
+		if ((add & CM3629_PS1_IF_AWAY) || (add & CM3629_PS2_IF_AWAY))
+			report_psensor_input_event(lpi, 1);/*1 meam far*/
+		else
+			report_psensor_input_event(lpi, 2);/*2 meam close*/
+	} else if (((add & CM3629_ALS_IF_L) == CM3629_ALS_IF_L) ||
 		     ((add & CM3629_ALS_IF_H) == CM3629_ALS_IF_H)) {
 		report_lsensor_input_event(lpi, 0);
 	} else {
@@ -935,7 +888,7 @@ static void ls_initial_cmd(struct cm3629_info *lpi)
 }
 
 static void psensor_intelligent_cancel_cmd(struct cm3629_info *lpi)
-{	
+{
 	char cmd[2] = {0};
 
 	cmd[0] = lpi->inte_ps1_canc;
@@ -995,10 +948,6 @@ static int psensor_enable(struct cm3629_info *lpi)
 
 	psensor_initial_cmd(lpi);
 
-	/*p-sensor first jiffies setting*/
-	last_jiffies = jiffies;
-	laststatus = 1;
-
 	if (lpi->enable_polling_ignore == 1 &&
 		lpi->mfg_mode != NO_IGNORE_BOOT_MODE) {
 		/* default report FAR */
@@ -2035,14 +1984,14 @@ static int cm3629_read_chip_id(struct cm3629_info *lpi)
 	msleep(5);
 	als_power(1);
 	msleep(5);
-	
+
 	ret =_cm3629_I2C_Read2(lpi->cm3629_slave_address, CH_ID, chip_id, 2);
 	if (ret >= 0) {
 		if ((chip_id[0] != 0x29) && (chip_id[0] != 0x92) && (chip_id[0] != 0x82)) {
 			ret = -1;
 			D("[PS][cm3629] %s, chip_id  Err value = 0x%x, 0x%x, ret %d\n",
 				__func__, chip_id[0], chip_id[1], ret);
-		} else 
+		} else
 			D("[PS][cm3629] %s, chip_id value = 0x%x, 0x%x, ret %d\n",
 				__func__, chip_id[0], chip_id[1], ret);
 	} else
@@ -2248,7 +2197,6 @@ static int cm3629_probe(struct i2c_client *client,
 		ret = -ENOMEM;
 		goto err_create_singlethread_workqueue;
 	}
-	INIT_DELAYED_WORK(&(lpi->ps_debounce_work.report_debounce_work), report_debounce_do_work);
 
 	wake_lock_init(&(lpi->ps_wake_lock), WAKE_LOCK_SUSPEND, "proximity");
 
diff --git a/drivers/i2c/chips/ewtzmu2.c b/drivers/i2c/chips/ewtzmu2.c
index 62d1040..f2a0a72 100644
--- a/drivers/i2c/chips/ewtzmu2.c
+++ b/drivers/i2c/chips/ewtzmu2.c
@@ -462,7 +462,7 @@ static int EWTZMU2_ReadSensorDataFIFO(unsigned char *buf, int bufsize)
 {
 	char cmd;
 	int mode = 0;
-	unsigned char databuf[200];
+	unsigned char databuf[200] = {0};
 	int res = EW_DRV_SUCCESS, databyte = 6;
 
 	if ((!buf) || (bufsize < 121))
@@ -2419,8 +2419,7 @@ static int ewtzmu2_input_init(struct ewtzmu_i2c_data *data)
     data->input_dev_gyroscope = input_allocate_device();
     if (!data->input_dev_gyroscope) {
 	err = -ENOMEM;
-	E("ewtzmu2_input_init: Failed to allocate input device: %s\n",
-	data->input_dev_gyroscope->name);
+	E("ewtzmu2_input_init: Failed to allocate input device\n");
 	goto exit_input_register_compass_device_failed;
     }
     set_bit(EV_REL, data->input_dev_gyroscope->evbit);
diff --git a/drivers/input/keyboard/gpio_keys.c b/drivers/input/keyboard/gpio_keys.c
index 4efb760..745f724 100644
--- a/drivers/input/keyboard/gpio_keys.c
+++ b/drivers/input/keyboard/gpio_keys.c
@@ -28,7 +28,6 @@
 #include <linux/workqueue.h>
 #include <linux/gpio.h>
 #include <linux/wakelock.h>
-#include <linux/spinlock.h>
 
 struct gpio_button_data {
 	struct gpio_keys_button *button;
@@ -51,8 +50,6 @@ struct gpio_keys_drvdata {
 struct wake_lock power_key_wake_lock;
 extern int resume_from_deep_suspend;
 bool doCheck;
-bool resumeSentPwr;
-DEFINE_SPINLOCK(lock);
 
 static DEFINE_MUTEX(wakeup_mutex);
 static unsigned char wakeup_bitmask;
@@ -377,36 +374,20 @@ static void gpio_keys_report_event(struct gpio_button_data *bdata)
 	unsigned int type = button->type ?: EV_KEY;
 	int state = (gpio_get_value_cansleep(button->gpio) ? 1 : 0) ^ button->active_low;
 
-	spin_lock(&lock);
 	if(!doCheck) {
-		doCheck = true;
-	spin_unlock(&lock);
 		if (resume_from_deep_suspend && (KEY_POWER == button->code) && state == 0) {
 			input_event(input, type, button->code, 1);
 			pr_info("[KEY] send power key code 1.\n");
 			//workaround for isr lost. Send down key code to input subsystem; but it has make down,down,up patten case for normal isr.
 		}
-	} else
-		spin_unlock(&lock);
-
+		doCheck = true;
+	}
 	if ((KEY_POWER == button->code) && (0 == state)) {
 		printk(KERN_INFO "[KEY] Power key released\n");
 	}
 
-	if ((KEY_POWER != button->code)) {
-		input_event(input, type, button->code, !!state);
-		input_sync(input);
-	} else {
-		spin_lock(&lock);
-		if( resumeSentPwr ){
-			resumeSentPwr = false;
-			spin_unlock(&lock);
-		} else {
-			spin_unlock(&lock);
-			input_event(input, type, button->code, !!state);
-			input_sync(input);
-		}
-	}
+	input_event(input, type, button->code, !!state);
+	input_sync(input);
 	printk(KERN_INFO "[KEY] GPIO key status, key code = %d, state = %d\n", button->code, state);
 }
 
@@ -684,7 +665,6 @@ static int gpio_keys_suspend(struct device *dev)
 		}
 	}
 	doCheck = false;
-	resumeSentPwr = false;
 	return 0;
 }
 
@@ -705,19 +685,10 @@ static int gpio_keys_resume(struct device *dev)
 		if (button->wakeup && device_may_wakeup(&pdev->dev)) {
 			int irq = gpio_to_irq(button->gpio);
 			disable_irq_wake(irq);
-			spin_lock(&lock);
-			if (wakeup_key == button->code && !doCheck) {
-				unsigned int type = button->type ?: EV_KEY;
-				doCheck = true;
-				resumeSentPwr = true;
-				spin_unlock(&lock);
-				input_event(ddata->input, type, button->code, 1);
-				input_event(ddata->input, type, button->code, 0);
-				input_sync(ddata->input);
-				pr_info("[KEY] Wakup source is power key, send key code.\n");
+
+			if (wakeup_key == button->code) {
 				wake_lock_timeout(&power_key_wake_lock, 5 * HZ);
-			} else
-				spin_unlock(&lock);
+			}
 		}
 		if (KEY_POWER != button->code)
 			gpio_keys_report_event(&ddata->data[i]);
diff --git a/drivers/input/keyreset.c b/drivers/input/keyreset.c
index e1c2f9f..2e5180b 100644
--- a/drivers/input/keyreset.c
+++ b/drivers/input/keyreset.c
@@ -24,12 +24,11 @@
 #include <linux/syscalls.h>
 #include <linux/hrtimer.h>
 #include <linux/nct1008.h>
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 	#include <linux/leds-lp5521_htc.h>
 #endif
 #include <mach/board_htc.h>
 #include <mach/restart.h>
-#include <htc/log.h>
 
 extern unsigned engineer_id;
 extern struct htc_reboot_params *reboot_params;
@@ -49,6 +48,7 @@ struct keyreset_state {
 	int key_up;
 	int restart_disabled;
 	int (*reset_fn)(void);
+	bool (*swResetCheck)(void);
 };
 
 static int restart_requested;
@@ -116,7 +116,6 @@ static void keyreset_event(struct input_handle *handle, unsigned int type,
 {
 	unsigned long flags;
 	struct keyreset_state *state = handle->private;
-	int pcbid = htc_get_pcbid_info();
 
 	if (type != EV_KEY)
 		return;
@@ -134,58 +133,58 @@ static void keyreset_event(struct input_handle *handle, unsigned int type,
 
 	if (code == KEY_POWER) {
 		if (value) {
-			sp_pr_info("[PWR] start count for power off led\n");
+			pr_info("[PWR] start count for power off led\n");
 			hrtimer_start(&led_timer, ktime_set(5,0), HRTIMER_MODE_REL);
 			power_off_led_requested = 1;
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
-			if ( ( pcbid < PROJECT_PHASE_A ) || ( (pcbid == PROJECT_PHASE_A) && (engineer_id == 0x01 ))) {
-				sp_pr_info("[PWR] start count for power reset\n");
-				hrtimer_start(&reset_timer, ktime_set(5,500000000), HRTIMER_MODE_REL);
-				power_reset_requested = 1;
+			if (state->swResetCheck != NULL) {
+				if (state->swResetCheck) {
+					pr_info("[PWR] start count for power reset\n");
+					hrtimer_start(&reset_timer, ktime_set(5,500000000), HRTIMER_MODE_REL);
+					power_reset_requested = 1;
+				}
 			}
-#endif
-			sp_pr_info("[PWR] start count for read temp\n");
+			pr_info("[PWR] start count for read temp\n");
 			hrtimer_start(&temp_timer, ktime_set(5,0), HRTIMER_MODE_REL);
 			read_temp_requested = 1;
 		}
 		else {
 			if (power_off_led_requested) {
 				if (hrtimer_cancel(&led_timer)) {
-					sp_pr_info("[PWR] cancel power off led timer (%x)\n", power_off_led_requested);
+					pr_info("[PWR] cancel power off led timer (%x)\n", power_off_led_requested);
 				} else
-					sp_pr_info("[PWR] cancel power off led timer, timer has done (%x)\n", power_off_led_requested);
+					pr_info("[PWR] cancel power off led timer, timer has done (%x)\n", power_off_led_requested);
 
 				if (power_off_led_requested == 2) {
-					sp_pr_info("[PWR] power off led turn off\n");
+					pr_info("[PWR] power off led turn off\n");
 #if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
 					lp5521_led_current_set_for_key(0);
 #endif
 				}
 				power_off_led_requested = 0;
 			}
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
-			if ( ( pcbid < PROJECT_PHASE_A ) || ( (pcbid == PROJECT_PHASE_A) && (engineer_id == 0x01 ))) {
-				if ( power_reset_requested ) {
-					if (hrtimer_cancel(&reset_timer)) {
-						sp_pr_info("[PWR] cancel power reset timer (%x).\n", power_reset_requested);
-					} else
-						sp_pr_info("[PWR] cancel power reset timer, timer has done (%x).\n", power_reset_requested);
-					if ( power_reset_requested == 2 ) {
-						sp_pr_info("[PWR] reset device\n");
-						schedule_work(&restart_work);
+			if (state->swResetCheck != NULL) {
+				if (state->swResetCheck) {
+					if ( power_reset_requested ) {
+						if (hrtimer_cancel(&reset_timer)) {
+							pr_info("[PWR] cancel power reset timer (%x).\n", power_reset_requested);
+						} else
+							pr_info("[PWR] cancel power reset timer, timer has done (%x).\n", power_reset_requested);
+						if ( power_reset_requested == 2 ) {
+							pr_info("[PWR] reset device\n");
+							schedule_work(&restart_work);
+						}
+						power_reset_requested = 0;
 					}
-					power_reset_requested = 0;
 				}
 			}
-#endif
 			if (read_temp_requested) {
 				if (hrtimer_cancel(&temp_timer)) {
-					sp_pr_info("[PWR] cancel read temp timer (%x)\n", read_temp_requested);
+					pr_info("[PWR] cancel read temp timer (%x)\n", read_temp_requested);
 				} else
-					sp_pr_info("[PWR] cancel read temp timer, timer has done (%x)\n", read_temp_requested);
+					pr_info("[PWR] cancel read temp timer, timer has done (%x)\n", read_temp_requested);
 
 				if (read_temp_requested == 2) {
-					sp_pr_info("[PWR] read temp turn off\n");
+					pr_info("[PWR] read temp turn off\n");
 					nct1008_read_temp_for_key(0);
 				}
 				read_temp_requested = 0;
@@ -301,6 +300,9 @@ static int keyreset_probe(struct platform_device *pdev)
 	if (pdata->reset_fn)
 		state->reset_fn = pdata->reset_fn;
 
+	if (pdata->swResetCheck)
+		state->swResetCheck = pdata->swResetCheck;
+
 	state->input_handler.event = keyreset_event;
 	state->input_handler.connect = keyreset_connect;
 	state->input_handler.disconnect = keyreset_disconnect;
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 9b604dd..a6677e6 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -12,7 +12,6 @@ obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879_I2C)	+= ad7879-i2c.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879_SPI)	+= ad7879-spi.o
 obj-$(CONFIG_TOUCHSCREEN_ADS7846)	+= ads7846.o
-#obj-$(CONFIG_TOUCHSCREEN_NTRIG)    += ntrig.o
 #obj-$(CONFIG_TOUCHSCREEN_NTRIG)    += ntrig_G4.o
 obj-$(CONFIG_TOUCHSCREEN_NTRIG)		+= ntrig-common.o ntrig-dispatcher.o ntrig-quirk-driver.o ntrig-dispatcher-sysfs.o ntrig-ncp-driver.o ntrig-dispatcher-sys-depend-android.o ntrig-direct-event-driver.o
 obj-$(CONFIG_TOUCHSCREEN_NTRIG)    += ntrig_spi.o ntrig_low_msg.o
diff --git a/drivers/input/touchscreen/synaptics_3200.c b/drivers/input/touchscreen/synaptics_3200.c
index dd915c3..436b815 100644
--- a/drivers/input/touchscreen/synaptics_3200.c
+++ b/drivers/input/touchscreen/synaptics_3200.c
@@ -2437,6 +2437,7 @@ static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 		i2c_syn_error_handler(ts, 1, "force update", __func__);
 	printk("[TP] touch suspend, fast relasxation: %x", ts->relaxation);
 #endif
+/*
 	ret = i2c_syn_read(ts->client,
 			get_address_base(ts, 0x11, CONTROL_BASE) + 41, &data, 1);
 	if (ret < 0)
@@ -2449,6 +2450,7 @@ static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 	if (ret < 0)
 		i2c_syn_error_handler(ts, 0, "w:0", __func__);
         printk("[TP] disable palm supression\n");
+*/
 #ifdef SYN_SUSPEND_RESUME_POWEROFF
 	if (ts->power)
 		ts->power(0);
diff --git a/drivers/leds/leds-lp5521_htc.c b/drivers/leds/leds-lp5521_htc.c
index b9d9761..4de61eb 100644
--- a/drivers/leds/leds-lp5521_htc.c
+++ b/drivers/leds/leds-lp5521_htc.c
@@ -26,7 +26,6 @@
 #include <linux/earlysuspend.h>
 #include <linux/leds.h>
 #include <linux/leds-lp5521_htc.h>
-#include "../../arch/arm/mach-tegra/gpio-names.h"
 #include <linux/regulator/consumer.h>
 
 #define LP5521_MAX_LEDS			3	/* Maximum number of LEDs */
@@ -41,6 +40,7 @@
 
 static int led_rw_delay;
 static int current_state, current_blink, current_time;
+static int current_currents, current_lut_coefficient, current_pwm_coefficient;
 static int current_mode, backlight_mode, suspend_mode, offtimer_mode;
 static int amber_mode;
 static struct regulator *regulator;
@@ -1003,7 +1003,7 @@ static ssize_t lp5521_led_off_timer_store(struct device *dev,
 	min = -1;
 	sec = -1;
 	sscanf(buf, "%d %d", &min, &sec);
-	I(" %s +++, min = %d, sec = %d\n" , __func__, min, sec);
+	I(" %s , min = %d, sec = %d\n" , __func__, min, sec);
 	if (min < 0 || min > 255)
 		return -EINVAL;
 	if (sec < 0 || sec > 255)
@@ -1059,7 +1059,7 @@ static ssize_t lp5521_led_blink_store(struct device *dev,
 
 	val = -1;
 	sscanf(buf, "%d", &val);
-	I(" %s +++, val = %d\n" , __func__, val);
+	I(" %s , val = %d\n" , __func__, val);
 	if (val < 0 )
 		val = 0;
 	else if (val > 255)
@@ -1082,7 +1082,7 @@ static ssize_t lp5521_led_blink_store(struct device *dev,
 		} else if (!strcmp(ldata->cdev.name, "button-backlight")) {
 			if ( backlight_mode != 2 )
 				lp5521_led_current_set_for_key(1);
-		} 
+		}
 	} else {
 		if(!strcmp(ldata->cdev.name, "amber"))	 {
 			if( amber_mode == 2 )
@@ -1105,6 +1105,148 @@ static ssize_t lp5521_led_blink_store(struct device *dev,
 static DEVICE_ATTR(blink, 0644, lp5521_led_blink_show,
 					lp5521_led_blink_store);
 
+static ssize_t lp5521_led_currents_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", current_currents);
+}
+
+static ssize_t lp5521_led_currents_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct i2c_client *client = private_lp5521_client;
+	struct led_classdev *led_cdev;
+	struct lp5521_led *ldata;
+	uint8_t data = 0x00;
+	int val, ret;
+
+	sscanf(buf, "%d", &val);
+	I(" %s , val = %d\n" , __func__, val);
+	if (val < 0 || val > 255)
+		return -EINVAL;
+	current_currents = val;
+	led_cdev = (struct led_classdev *)dev_get_drvdata(dev);
+	ldata = container_of(led_cdev, struct lp5521_led, cdev);
+
+	mutex_lock(&led_mutex);
+	// === run program with all direct program ===
+	data = 0x3f;
+	ret = i2c_write_block(client, 0x01, &data, 1);
+	udelay(200);
+	data = 0x40;
+	ret = i2c_write_block(client, 0x00, &data, 1);
+	udelay(500);
+	// === set pwm to all ===
+	data = (u8)val;
+	if(!strcmp(ldata->cdev.name, "green"))	 {
+		ret = i2c_write_block(client, 0x06, &data, 1);
+	} else if (!strcmp(ldata->cdev.name, "amber")) {
+		ret = i2c_write_block(client, 0x05, &data, 1);
+	} else if (!strcmp(ldata->cdev.name, "button-backlight")) {
+		ret = i2c_write_block(client, 0x07, &data, 1);
+	}
+	mutex_unlock(&led_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(currents, 0644, lp5521_led_currents_show,
+					lp5521_led_currents_store);
+
+static ssize_t lp5521_led_pwm_coefficient_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", current_pwm_coefficient);
+}
+
+static ssize_t lp5521_led_pwm_coefficient_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct i2c_client *client = private_lp5521_client;
+	struct led_classdev *led_cdev;
+	struct lp5521_led *ldata;
+	uint8_t data = 0x00;
+	int val, ret;
+
+	sscanf(buf, "%d", &val);
+	I(" %s , val = %d\n" , __func__, val);
+	if (val < 0 || val > 100)
+		return -EINVAL;
+	current_pwm_coefficient = val;
+	led_cdev = (struct led_classdev *)dev_get_drvdata(dev);
+	ldata = container_of(led_cdev, struct lp5521_led, cdev);
+
+	mutex_lock(&led_mutex);
+	// === run program with all direct program ===
+	data = 0x3f;
+	ret = i2c_write_block(client, 0x01, &data, 1);
+	udelay(200);
+	data = 0x40;
+	ret = i2c_write_block(client, 0x00, &data, 1);
+	udelay(500);
+	// === set current to amber & green ===
+	data = (u8)val*255/100;
+	if(!strcmp(ldata->cdev.name, "green"))	 {
+		ret = i2c_write_block(client, 0x03, &data, 1);
+	} else if (!strcmp(ldata->cdev.name, "amber")) {
+		ret = i2c_write_block(client, 0x02, &data, 1);
+	}
+	mutex_unlock(&led_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(pwm_coefficient, 0644, lp5521_led_pwm_coefficient_show,
+					lp5521_led_pwm_coefficient_store);
+
+
+static ssize_t lp5521_led_lut_coefficient_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", current_lut_coefficient);
+}
+
+static ssize_t lp5521_led_lut_coefficient_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct i2c_client *client = private_lp5521_client;
+	struct led_classdev *led_cdev;
+	struct lp5521_led *ldata;
+	uint8_t data = 0x00;
+	int val, ret;
+
+	sscanf(buf, "%d", &val);
+	I(" %s , val = %d\n" , __func__, val);
+	if (val < 0 || val > 100)
+		return -EINVAL;
+	current_lut_coefficient = val;
+	led_cdev = (struct led_classdev *)dev_get_drvdata(dev);
+	ldata = container_of(led_cdev, struct lp5521_led, cdev);
+
+	mutex_lock(&led_mutex);
+	// === run program with all direct program ===
+	data = 0x3f;
+	ret = i2c_write_block(client, 0x01, &data, 1);
+	udelay(200);
+	data = 0x40;
+	ret = i2c_write_block(client, 0x00, &data, 1);
+	udelay(500);
+	// === set current to blue(button) ===
+	data = (u8)val*255/100;
+	if(!strcmp(ldata->cdev.name, "button-backlight")) {
+		ret = i2c_write_block(client, 0x04, &data, 1);
+	}
+	mutex_unlock(&led_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(lut_coefficient, 0644, lp5521_led_lut_coefficient_show,
+					lp5521_led_lut_coefficient_store);
+
 static void lp5521_led_early_suspend(struct early_suspend *handler)
 {
 	struct i2c_client *client = private_lp5521_client;
@@ -1205,9 +1347,24 @@ static int lp5521_led_probe(struct i2c_client *client
 		}
 		ret = device_create_file(cdata->leds[i].cdev.dev, &dev_attr_off_timer);
 		if (ret < 0) {
-			pr_err("%s: failed on create attr blink [%d]\n", __func__, i);
+			pr_err("%s: failed on create attr off_timer [%d]\n", __func__, i);
 			goto err_register_attr_off_timer;
 		}
+		ret = device_create_file(cdata->leds[i].cdev.dev, &dev_attr_currents);
+		if (ret < 0) {
+			pr_err("%s: failed on create attr currents [%d]\n", __func__, i);
+			goto err_register_attr_currents;
+		}
+		ret = device_create_file(cdata->leds[i].cdev.dev, &dev_attr_pwm_coefficient);
+		if (ret < 0) {
+			pr_err("%s: failed on create attr pwm_coefficient [%d]\n", __func__, i);
+			goto err_register_attr_pwm_coefficient;
+		}
+		ret = device_create_file(cdata->leds[i].cdev.dev, &dev_attr_lut_coefficient);
+		if (ret < 0) {
+			pr_err("%s: failed on create attr lut_coefficient [%d]\n", __func__, i);
+			goto err_register_attr_lut_coefficient;
+		}
 		INIT_WORK(&cdata->leds[i].led_work, led_work_func);
 		alarm_init(&cdata->leds[i].led_alarm,
 				   ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
@@ -1252,14 +1409,26 @@ static int lp5521_led_probe(struct i2c_client *client
 err_fun_init:
 	device_remove_file(&client->dev, &dev_attr_behavior);
 	kfree(cdata);
-err_register_attr_blink:
+err_register_attr_lut_coefficient:
 	for (i = 0; i < pdata->num_leds; i++) {
-		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_blink);
+		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_lut_coefficient);
+	}
+err_register_attr_pwm_coefficient:
+	for (i = 0; i < pdata->num_leds; i++) {
+		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_pwm_coefficient);
+	}
+err_register_attr_currents:
+	for (i = 0; i < pdata->num_leds; i++) {
+		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_currents);
 	}
 err_register_attr_off_timer:
 	for (i = 0; i < pdata->num_leds; i++) {
 		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_off_timer);
 	}
+err_register_attr_blink:
+	for (i = 0; i < pdata->num_leds; i++) {
+		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_blink);
+	}
 err_create_work_queue:
 	kfree(pdata);
 err_exit:
@@ -1288,6 +1457,9 @@ static int __devexit lp5521_led_remove(struct i2c_client *client)
 	for (i = 0; i < pdata->num_leds; i++) {
 		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_blink);
 		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_off_timer);
+		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_currents);
+		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_pwm_coefficient);
+		device_remove_file(cdata->leds[i].cdev.dev,&dev_attr_lut_coefficient);
 		led_classdev_unregister(&cdata->leds[i].cdev);
 	}
 	destroy_workqueue(g_led_work_queue);
diff --git a/drivers/media/video/tegra/ad5823.c b/drivers/media/video/tegra/ad5823.c
index b3247c7..08a9080 100644
--- a/drivers/media/video/tegra/ad5823.c
+++ b/drivers/media/video/tegra/ad5823.c
@@ -29,12 +29,12 @@
 #define POS_HIGH (496)
 #define SETTLETIME_MS 55
 
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_BLUE) || defined(CONFIG_MACH_TEGRA_ENTERPRISE)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU) || defined(CONFIG_MACH_BLUE) || defined(CONFIG_MACH_TEGRA_ENTERPRISE)
 #define FOCAL_LENGTH (3.03f)
 #define FNUMBER (2.0f)
 #endif
 
-#if defined(CONFIG_MACH_VERTEXF) || defined(CONFIG_MACH_QUATTRO_U)
+#if defined(CONFIG_MACH_VERTEXFP)
 #define FOCAL_LENGTH (2.95f)
 #define FNUMBER (2.4f)
 #endif
diff --git a/drivers/media/video/tegra/avp/trpc_sema.c b/drivers/media/video/tegra/avp/trpc_sema.c
index 65c569e..cd717a1 100644
--- a/drivers/media/video/tegra/avp/trpc_sema.c
+++ b/drivers/media/video/tegra/avp/trpc_sema.c
@@ -91,10 +91,7 @@ int tegra_sema_wait(struct tegra_sema_info *info, long *timeout)
 	unsigned long flags;
 	int ret = 0;
 	unsigned long endtime;
-	long timeleft = 0;
-
-	if (timeout != NULL)
-		timeleft = *timeout;
+	long timeleft = *timeout;
 
 	*timeout = 0;
 	if (timeleft < 0)
diff --git a/drivers/media/video/tegra/rawchip/Yushan_API.c b/drivers/media/video/tegra/rawchip/Yushan_API.c
index fb8ecf7..59ed70b 100644
--- a/drivers/media/video/tegra/rawchip/Yushan_API.c
+++ b/drivers/media/video/tegra/rawchip/Yushan_API.c
@@ -1978,8 +1978,11 @@ bool_t WaitForInterruptEvent2 (uint8_t bInterruptId ,uint32_t udwTimeOut)
 
 /*extern void sensor_streaming_on(void);*/
 /*extern void sensor_streaming_off(void);*/
-void Reset_Yushan(void)
+void Reset_Yushan(Yushan_New_Context_Config_t *sYushanNewContextConfig)
 {
+	pr_info("[CAM] %s\n",__func__);
+	uint8_t bStatus;
+	uint8_t bPdpMode = 0, bDppMode = 0, bDopMode = 0;
 	uint8_t	bSpiData;
 	Yushan_Init_Dxo_Struct_t	sDxoStruct;
 	sDxoStruct.pDxoPdpRamImage[0] = (uint8_t *)yushan_regs.pdpcode;
@@ -2002,8 +2005,75 @@ void Reset_Yushan(void)
 	sDxoStruct.uwBaseAddrPdpMicroCode[1] = yushan_regs.pdpclib->addr;
 	sDxoStruct.uwBaseAddrDppMicroCode[1] = yushan_regs.dppclib->addr;
 	sDxoStruct.uwBaseAddrDopMicroCode[1] = yushan_regs.dopclib->addr;
-	pr_err("[CAM] %s\n",__func__);
-	/*sensor_streaming_off();*/
+
+	Yushan_GainsExpTime_t sGainsExpTime;
+
+	sGainsExpTime.uwAnalogGainCodeGR = 0x20; /* 0x0 10x=>140; 1x=>20 */
+	sGainsExpTime.uwAnalogGainCodeR = 0x20;
+	sGainsExpTime.uwAnalogGainCodeB = 0x20;
+	sGainsExpTime.uwPreDigGainGR = 0x100;
+	sGainsExpTime.uwPreDigGainR = 0x100;
+	sGainsExpTime.uwPreDigGainB = 0x100;
+	sGainsExpTime.uwExposureTime = 0x20;
+	sGainsExpTime.bRedGreenRatio = 0x40;
+	sGainsExpTime.bBlueGreenRatio = 0x40;
+
+	Yushan_ImageChar_t sImageChar_context;
+
+	sImageChar_context.bImageOrientation = sYushanNewContextConfig->orientation;
+	if( (sYushanNewContextConfig->uwActiveFrameLength == 1736) && (sYushanNewContextConfig->uwActivePixels == 3084) )
+	{
+		//3084x1736
+		sImageChar_context.uwXAddrStart = 0x60;
+		sImageChar_context.uwYAddrStart = 0x16C;
+		sImageChar_context.uwXAddrEnd= 0xC6B;
+		sImageChar_context.uwYAddrEnd= 0x833;
+		sImageChar_context.uwXEvenInc = 1;
+		sImageChar_context.uwXOddInc = 1;
+		sImageChar_context.uwYEvenInc = 1;
+		sImageChar_context.uwYOddInc = 1;
+		sImageChar_context.bBinning = 0x11;
+	}
+	else if( (sYushanNewContextConfig->uwActiveFrameLength == 432) && (sYushanNewContextConfig->uwActivePixels == 768) )
+	{
+		//768x432
+		sImageChar_context.uwXAddrStart = 0x68;
+		sImageChar_context.uwYAddrStart = 0x1C8;
+		sImageChar_context.uwXAddrEnd= 0xC67;
+		sImageChar_context.uwYAddrEnd= 0x887;
+		sImageChar_context.uwXEvenInc = 1;
+		sImageChar_context.uwXOddInc = 7;
+		sImageChar_context.uwYEvenInc = 1;
+		sImageChar_context.uwYOddInc = 7;
+		sImageChar_context.bBinning = 0x22;
+	}
+	else if( (sYushanNewContextConfig->uwActiveFrameLength == 510) && (sYushanNewContextConfig->uwActivePixels == 1640) )
+	{
+		//1640x510
+		sImageChar_context.uwXAddrStart = 0x0;
+		sImageChar_context.uwYAddrStart = 0xD4;
+		sImageChar_context.uwXAddrEnd= 0xCCF;
+		sImageChar_context.uwYAddrEnd= 0x8CB;
+		sImageChar_context.uwXEvenInc = 1;
+		sImageChar_context.uwXOddInc = 3;
+		sImageChar_context.uwYEvenInc = 1;
+		sImageChar_context.uwYOddInc = 7;
+		sImageChar_context.bBinning = 0x22;
+	}
+	else
+	{
+		//3280x2464 Full size
+		sImageChar_context.uwXAddrStart = 0x0;
+		sImageChar_context.uwYAddrStart = 0x0;
+		sImageChar_context.uwXAddrEnd = sYushanNewContextConfig->uwActivePixels - 1;
+		sImageChar_context.uwYAddrEnd = sYushanNewContextConfig->uwActiveFrameLength -1;
+		sImageChar_context.uwXEvenInc = 1;
+		sImageChar_context.uwXOddInc = 1;
+		sImageChar_context.uwYEvenInc = 1;
+		sImageChar_context.uwYOddInc = 1;
+		sImageChar_context.bBinning = 0x11;
+	}
+
 	Yushan_Assert_Reset(0x001F0F10, RESET_MODULE);
 	bSpiData =1;
 	Yushan_DXO_Sync_Reset_Dereset(bSpiData);
@@ -2012,6 +2082,20 @@ void Reset_Yushan(void)
 	Yushan_DXO_Sync_Reset_Dereset(bSpiData);	
 	Yushan_Init_Dxo(&sDxoStruct, 1);
 	msleep(10);
+
+	Yushan_Update_ImageChar(&sImageChar_context);
+	Yushan_Update_SensorParameters(&sGainsExpTime);
+	Yushan_Update_DxoDpp_TuningParameters(&sDxoDppTuning);
+	Yushan_Update_DxoDop_TuningParameters(&sDxoDopTuning);
+	Yushan_Update_DxoPdp_TuningParameters(&sDxoPdpTuning);
+	bPdpMode = 1; bDppMode = 3; bDopMode = 1;
+	bStatus = Yushan_Update_Commit(bPdpMode, bDppMode, bDopMode);
+	if (bStatus == 1)
+		pr_info("[CAM] DXO Commit Done\n");
+	else {
+		pr_err("[CAM] DXO Commit FAILED\n");
+	}
+
 	/*Yushan_sensor_open_init();*/
 	/*Yushan_ContextUpdate_Wrapper(&sYushanFullContextConfig);*/
 	/*sensor_streaming_on();*/
@@ -3038,7 +3122,7 @@ bool_t	Yushan_Context_Config_Update(Yushan_New_Context_Config_t	*sYushanNewConte
 	/* bDataType */
 	/* bDataType = (bRawFormat==0x08)?0x2a:0x2b; */
 
-	if ((sYushanNewContextConfig->uwPixelFormat&0x0F)==0x0A){
+	if (likely((sYushanNewContextConfig->uwPixelFormat&0x0F)==0x0A)){
 		bRawFormat = RAW10;
 		bDataType  = 0x2b;
 	}
@@ -3050,6 +3134,11 @@ bool_t	Yushan_Context_Config_Update(Yushan_New_Context_Config_t	*sYushanNewConte
 		else /* 10 to 8 case */
 			bDataType = 0x30; /* bRawFormat at Yushan should be RAW8, not RAW10_8 */
 	}
+	else
+	{
+		pr_err("[CAM] bRawFormat is neither RAW10 nor RAW8");
+		return FAILURE;
+	}
 
 	/* Read the Index information of the VF or STILL resolution. */
 	SPI_Read(YUSHAN_IDP_GEN_CONTROL, 1, (uint8_t *)(&bVfStillIndex));
@@ -3627,7 +3716,12 @@ bool_t Yushan_Read_AF_Statistics(uint32_t  *sYushanAFStats)
 
 
 	/* Read active number of ROI */
+	/* Avoid memory copy buffer overflow , so fix ROI number to 1 */
+#if 0
 	bStatus &= SPI_Read(DXO_DOP_BASE_ADDR+DxODOP_ROI_active_number_7_0, 1, (uint8_t*)(&bNumOfActiveRoi));
+#else
+	bNumOfActiveRoi = 1;
+#endif
 	/* pr_err("[CAM]%s, bNumOfActiveRoi:%d\n", __func__, bNumOfActiveRoi); */
 
 	if (!bNumOfActiveRoi) /* NO ROI ACTIVATED */
@@ -4115,8 +4209,8 @@ int Yushan_sensor_open_init(struct rawchip_sensor_init_data data)
 	sDxoDopTuning.bEstimationMode = 1;
 	sDxoDopTuning.bSharpness = 0x01; /*0x60;*/
 	sDxoDopTuning.bDenoisingLowGain = 0x1; /* 0xFF for de-noise verify, original:0x1 */
-	sDxoDopTuning.bDenoisingMedGain = 0x80;
-	sDxoDopTuning.bDenoisingHiGain = 0x60; /*0x80;*/
+	sDxoDopTuning.bDenoisingMedGain = 0x70;
+	sDxoDopTuning.bDenoisingHiGain = 0x45; /*0x80;*/
 	sDxoDopTuning.bNoiseVsDetailsLowGain = 0xA0;
 	sDxoDopTuning.bNoiseVsDetailsMedGain = 0x80;
 	sDxoDopTuning.bNoiseVsDetailsHiGain = 0x80;
diff --git a/drivers/media/video/tegra/rawchip/rawchip_spi.c b/drivers/media/video/tegra/rawchip/rawchip_spi.c
index ce71c80..fc94b31 100644
--- a/drivers/media/video/tegra/rawchip/rawchip_spi.c
+++ b/drivers/media/video/tegra/rawchip/rawchip_spi.c
@@ -200,6 +200,9 @@ static int yushan_spi_transaction(struct spi_message *msg)
 #endif
 	}
 
+	//HTC_START fix Klocwork
+	msg->context = NULL;
+	//HTC_END
 	return status;
 }
 
diff --git a/drivers/media/video/tegra/s5k3h2y.c b/drivers/media/video/tegra/s5k3h2y.c
index ab71ea7..d8f1dcc 100644
--- a/drivers/media/video/tegra/s5k3h2y.c
+++ b/drivers/media/video/tegra/s5k3h2y.c
@@ -1237,6 +1237,66 @@ static long s5k3h2y_ioctl(struct file *file,
 		return err;
 	}
 #endif
+
+	case S5K3H2Y_IOCTL_RESET_RAWCHIP:
+	{
+		pr_info("%s: S5K3H2Y_IOCTL_RESET_RAWCHIP\n", __func__);
+
+		struct s5k3h2y_mode mode;
+		Yushan_New_Context_Config_t *newContextConfig;
+		if (copy_from_user(&mode,
+				   (const void __user *)arg,
+				   sizeof(struct s5k3h2y_mode))) {
+			pr_info("%s %d\n", __func__, __LINE__);
+			return -EFAULT;
+		}
+
+		mutex_lock(&info->camera_lock);
+		tegra_rawchip_block_iotcl(TRUE);
+
+		if (mode.xres == 3280 && mode.yres == 2464)
+		{
+			pr_info("[CAM] Reset rawchip mode to -> 3280x2464\n");
+			newContextConfig=&(mode_rawchip[0]);
+		}
+		else if (mode.xres == 3084 && mode.yres == 1736)
+		{
+			newContextConfig=&(mode_rawchip[3]);
+			pr_info("[CAM] Reset rawchip mode to -> 3084x1736\n");
+		}
+		else if (mode.xres == 768 && mode.yres == 432) {
+			pr_info("[CAM] Reset rawchip mode to -> 768x432\n");
+			newContextConfig=&(mode_rawchip[2]);
+		}
+		else if (mode.xres == 1640 && mode.yres == 510) {
+			pr_info("[CAM] Reset rawchip mode to -> 1640x510\n");
+			newContextConfig=&(mode_rawchip[4]);
+		}
+		else {
+			pr_err("%s: invalid resolution supplied to set mode %d %d\n",__func__, mode.xres, mode.yres);
+			tegra_rawchip_block_iotcl(FALSE);
+			mutex_unlock(&info->camera_lock);
+			return -EINVAL;
+		}
+
+		/*sensor stream off*/
+		ret = s5k3h2y_write_table(info->i2c_client, reset_seq, NULL, 0);
+		if (ret)
+			pr_err("[CAM]set sensor stream off failed!!!");
+
+		Reset_Yushan(newContextConfig);
+		msleep(10);
+
+		/*stream on*/
+		ret = s5k3h2y_write_table(info->i2c_client, mode_end, NULL, 0);
+		if (ret)
+			pr_err("[CAM]set sensor stream on failed!!!");
+
+		tegra_rawchip_block_iotcl(FALSE);
+		mutex_unlock(&info->camera_lock);
+		return ret;
+	}
+
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/media/video/tegra/s5k6a1gx03.c b/drivers/media/video/tegra/s5k6a1gx03.c
index 889a567..2859e24 100644
--- a/drivers/media/video/tegra/s5k6a1gx03.c
+++ b/drivers/media/video/tegra/s5k6a1gx03.c
@@ -428,7 +428,7 @@ void greenLED_on_off(bool on)
 static int s5k6a1gx03_set_mode(struct s5k6a1gx03_info *info, struct s5k6a1gx03_mode *mode)
 {
 	int sensor_mode;
-	int err;
+	int err = -1;
 	struct s5k6a1gx03_reg reg_list[6];
 
 /* HTC_START */
diff --git a/drivers/media/video/tegra/tegra_camera.c b/drivers/media/video/tegra/tegra_camera.c
index 7d59d3d..b281607 100644
--- a/drivers/media/video/tegra/tegra_camera.c
+++ b/drivers/media/video/tegra/tegra_camera.c
@@ -172,8 +172,8 @@ static int tegra_camera_clk_set_rate(struct tegra_camera_dev *dev)
 
 	if (!info) {
 		dev_err(dev->dev,
-				"%s: no clock info %d\n",
-				__func__, info->id);
+				"%s: no clock info\n",
+				__func__);
 		return -EINVAL;
 	}
 
diff --git a/drivers/misc/cable_detect.c b/drivers/misc/cable_detect.c
index a724d71..46d4a3e 100644
--- a/drivers/misc/cable_detect.c
+++ b/drivers/misc/cable_detect.c
@@ -28,9 +28,10 @@
 #include "../video/tegra/sii9234/TPI.h"
 #endif
 
-/*#define MHL_INTERNAL_POWER  1*/
+#define MHL_INTERNAL_POWER  1
 static bool g_vbus = 0;
 static bool g_desk_no_power = 0;
+static bool g_deskConnect = 0;
 
 static struct switch_dev dock_switch = {
 	.name = "dock",
@@ -98,6 +99,7 @@ static void dock_detect_init(struct cable_detect_info *pInfo);
 int usb_get_vbus_value(void)
 {
 	extern int tps80031_vbus_on;
+	CABLE_INFO("%s: tps80031_vbus_on = %d\n", __func__, tps80031_vbus_on);
 	return tps80031_vbus_on;
 }
 
@@ -174,7 +176,7 @@ static void check_vbus_in(struct work_struct *w)
 {
 #if 1
 	struct cable_detect_info *pInfo = container_of(w, struct cable_detect_info, vbus_detect_work.work);
-	int g_vbus = usb_get_vbus_value();
+	g_vbus = usb_get_vbus_value();
 
 	CABLE_INFO("%s: %d\n", __func__, g_vbus);
 	if (g_vbus) {
@@ -182,35 +184,38 @@ static void check_vbus_in(struct work_struct *w)
 			case DOCK_STATE_DESK:
 				if (g_desk_no_power) {
 					if (gpio_get_value(pInfo->usb_id_pin_gpio)) {
+						if (!g_deskConnect)
+							break;
 						CABLE_INFO("%s: Cradle removed [ID]\n", __func__);
 						g_desk_no_power = 0;
-						if (pInfo->config_desk_aud_gpios)
-							pInfo->config_desk_aud_gpios(0, 0);
 						switch_set_state(&dock_switch, DOCK_STATE_UNDOCKED);
+						g_deskConnect = false;
 						pInfo->accessory_type = DOCK_STATE_UNDOCKED;
 						irq_set_irq_type(pInfo->idpin_irq, IRQF_TRIGGER_LOW);
 						enable_irq(pInfo->idpin_irq);
 					}
 					else {
+						if (g_deskConnect)
+							break;
 						CABLE_INFO("%s: Cradle inserted\n", __func__);
-						if (pInfo->config_desk_aud_gpios)
-							pInfo->config_desk_aud_gpios(1, 1);
 						switch_set_state(&dock_switch, DOCK_STATE_DESK);
 						g_desk_no_power = 0;
+						g_deskConnect = true;
 					}
 				}
 				break;
 			default:
 				break;
-		}
+	}
 	}
 	else {
 		switch (pInfo->accessory_type) {
 			case DOCK_STATE_DESK:
+				if (!g_deskConnect)
+					break;
 				CABLE_INFO("%s: Cradle removed\n", __func__);
-				if (pInfo->config_desk_aud_gpios)
-					pInfo->config_desk_aud_gpios(0, 0);
 				switch_set_state(&dock_switch, DOCK_STATE_UNDOCKED);
+				g_deskConnect = false;
 				pInfo->accessory_type = DOCK_STATE_UNDOCKED;
 				irq_set_irq_type(pInfo->idpin_irq, IRQF_TRIGGER_LOW);
 				enable_irq(pInfo->idpin_irq);
@@ -360,9 +365,8 @@ static void cable_detect_handler(struct work_struct *w)
 	case DOCK_STATE_DESK:
 		CABLE_INFO("Cradle inserted\n");
 		if (usb_get_vbus_value()) {
-			if (pInfo->config_desk_aud_gpios)
-				pInfo->config_desk_aud_gpios(1, 1);
 			switch_set_state(&dock_switch, DOCK_STATE_DESK);
+			g_deskConnect = true;
 			pInfo->accessory_type = DOCK_STATE_DESK;
 		}
 		else {
@@ -393,9 +397,23 @@ static void cable_detect_handler(struct work_struct *w)
 		switch_set_state(&dock_switch, DOCK_STATE_MHL);
 		pInfo->accessory_type = DOCK_STATE_MHL;
 		pInfo->usb_dpdn_switch(PATH_MHL);
+		g_vbus = usb_get_vbus_value();
 #ifdef MHL_INTERNAL_POWER
-		if (!pInfo->mhl_internal_3v3 && !g_vbus)
-			send_cable_connect_notify(CONNECT_TYPE_INTERNAL);
+		if (pInfo->mhl_internal_3v3) {
+			if (g_vbus)
+				send_cable_connect_notify(CONNECT_TYPE_AC);
+			else {
+				CABLE_INFO("MHL internal power\n");
+				send_cable_connect_notify(CONNECT_TYPE_INTERNAL);
+			}
+		}
+		else {
+			if (g_vbus)
+				send_cable_connect_notify(CONNECT_TYPE_AC);
+		}
+#else
+		if (g_vbus)
+			send_cable_connect_notify(CONNECT_TYPE_AC);
 #endif
 		sii9234_mhl_device_wakeup();
 		break;
@@ -421,8 +439,6 @@ static void cable_detect_handler(struct work_struct *w)
 #if 0  /* In check_vbus_in() */
 		case DOCK_STATE_DESK:
 			CABLE_INFO("Cradle removed\n");
-			if (pInfo->config_desk_aud_gpios)
-				pInfo->config_desk_aud_gpios(0, 0);
 			switch_set_state(&dock_switch, DOCK_STATE_UNDOCKED);
 			g_desk_no_power = 0;
 			pInfo->accessory_type = DOCK_STATE_UNDOCKED;
@@ -474,19 +490,20 @@ static void cable_detect_handler(struct work_struct *w)
 	value = gpio_get_value(pInfo->usb_id_pin_gpio);
 	CABLE_INFO("%s ID pin %d, type %d\n", __func__, value, pInfo->accessory_type);
 
-	if (usb_get_vbus_value() && pInfo->accessory_type != DOCK_STATE_UNDOCKED) {
+#ifdef CONFIG_TEGRA_HDMI_MHL
+	if (pInfo->accessory_type == DOCK_STATE_MHL)
+		return;
+#endif
+	if (g_vbus && pInfo->accessory_type != DOCK_STATE_UNDOCKED) {
 		if (cable_detection_ac_only())
 			send_cable_connect_notify(CONNECT_TYPE_AC);
 		else
-			send_cable_connect_notify(CONNECT_TYPE_UNKNOWN);
+			send_cable_connect_notify(CONNECT_TYPE_USB);
 	}
 
 	if (pInfo->accessory_type == DOCK_STATE_DESK)
 		return;
-#ifdef CONFIG_TEGRA_HDMI_MHL
-	if (pInfo->accessory_type == DOCK_STATE_MHL)
-		return;
-#endif
+
 	if (pInfo->accessory_type == DOCK_STATE_UNDOCKED)
 		irq_set_irq_type(pInfo->idpin_irq, value ? IRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH);
 	else
@@ -599,7 +616,9 @@ static void usb_id_detect_init(struct cable_detect_info *pInfo)
 
 	if (pInfo->usb_id_pin_gpio == 0)
 		return;
-
+	/* When plug MHL dongle with AC/USB booting,
+	 * g_vbus value need update */
+	g_vbus = usb_get_vbus_value();
 	pInfo->idpin_irq = gpio_to_irq(pInfo->usb_id_pin_gpio);
 	if (pInfo->idpin_irq < 0) {
 		CABLE_ERR("%s: gpio_to_irq failed", __func__);
@@ -619,6 +638,19 @@ static void usb_id_detect_init(struct cable_detect_info *pInfo)
 		goto err;
 	}
 #endif
+#ifdef CONFIG_TEGRA_HDMI_MHL /* Workaround for booting with an accessory */
+	if (gpio_get_value(pInfo->usb_id_pin_gpio)) {
+		CABLE_INFO("%s: ID(H) workaround\n", __func__);
+		gpio_set_value(pInfo->mhl_reset_gpio, 0);
+		mdelay(1);
+
+		if (gpio_get_value(pInfo->usb_id_pin_gpio)) {
+			CABLE_INFO("%s: ID(H) no accessory\n", __func__);
+			gpio_set_value(pInfo->mhl_reset_gpio, 1);
+			SwitchToD3_Force();
+		}
+	}
+#endif
 	CABLE_INFO("%s: ID=%d, IRQ=0x%x", __func__, pInfo->usb_id_pin_gpio, pInfo->idpin_irq);
 	return;
 #if 0 /* IRQ Wake */
@@ -672,7 +704,7 @@ static void mhl_status_notifier_func(bool isMHL, int charging_type)
 	else {
 		mhl_connected = 1;
 		irq_set_irq_type(pInfo->idpin_irq, id_pin ? IRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH);
-#if 0
+#if 1
 		if (g_vbus && (charging_type > CONNECT_TYPE_NONE))
 			send_cable_connect_notify(charging_type);
 #endif
@@ -680,8 +712,6 @@ static void mhl_status_notifier_func(bool isMHL, int charging_type)
 #ifdef MHL_INTERNAL_POWER
 		else if (g_vbus)
 			send_cable_connect_notify(CONNECT_TYPE_USB);
-		if (pInfo->config_desk_aud_gpios)
-			pInfo->config_desk_aud_gpios(1, 1);
 #endif
 #endif
 	}
@@ -769,7 +799,6 @@ static void dock_detect_init(struct cable_detect_info *pInfo)
 		enable_irq(pInfo->dockpin_irq);
 }
 #endif // CONFIG_CABLE_DETECT_GPIO_DOCK
-
 static ssize_t vbus_status_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	int vbus_in = 0;
@@ -1021,10 +1050,19 @@ EXPORT_SYMBOL(cable_detection_queue_recovery_host_work);
 
 void cable_detection_queue_vbus_work(int time)
 {
+	int ret;
 	struct cable_detect_info *pInfo = &the_cable_info;
+	CABLE_INFO("%s\n", __func__);
 
 	if (pInfo->cable_detect_wq)
-		queue_delayed_work(pInfo->cable_detect_wq, &pInfo->vbus_detect_work, time);
+	{
+		ret = queue_delayed_work(pInfo->cable_detect_wq, &pInfo->vbus_detect_work, time);
+		if (ret == 0) {
+			CABLE_INFO("%s: vbus detect debounce\n", __func__);
+			cancel_delayed_work(&pInfo->vbus_detect_work);
+		        queue_delayed_work(pInfo->cable_detect_wq, &pInfo->vbus_detect_work, time);
+		}
+	}
 }
 EXPORT_SYMBOL(cable_detection_queue_vbus_work);
 
@@ -1037,7 +1075,7 @@ struct platform_driver cable_detect_driver = {
 	},
 };
 
-static void usb_status_notifier_func(int cable_type)
+static void usb_status_notifier_func(int cable_type) /* TBD: Not Used on AP33 */
 {
 	struct cable_detect_info*pInfo = &the_cable_info;
 
@@ -1052,7 +1090,7 @@ static void usb_status_notifier_func(int cable_type)
 #endif
 #ifdef CONFIG_TEGRA_HDMI_MHL
 #ifdef MHL_INTERNAL_POWER
-	if (!pInfo->mhl_internal_3v3 && pInfo->accessory_type == DOCK_STATE_MHL) {
+	if (pInfo->mhl_internal_3v3 && pInfo->accessory_type == DOCK_STATE_MHL) {
 		CABLE_INFO("%s: MHL detected. Do nothing\n", __func__);
 		return;
 	}
diff --git a/drivers/misc/mpu3050_htc/mpuirq.c b/drivers/misc/mpu3050_htc/mpuirq.c
index 5152346..c9cb792 100644
--- a/drivers/misc/mpu3050_htc/mpuirq.c
+++ b/drivers/misc/mpu3050_htc/mpuirq.c
@@ -163,11 +163,6 @@ static long mpuirq_ioctl(struct file *file,
 		if (copy_to_user((int *) arg, &mpu_debug_flag, sizeof(int)))
 			return -EFAULT;
 		break;
-	 case HTC_BOARD:
-		 gyro_htc_board_info = htc_get_pcbid_info();
-		 if (copy_to_user((int *) arg, &gyro_htc_board_info, sizeof(int)))
-			 return -EFAULT;
-		 break;
 
 	default:
 		retval = -EINVAL;
diff --git a/drivers/misc/nct1008.c b/drivers/misc/nct1008.c
index 5ac8cf6..fd97944 100644
--- a/drivers/misc/nct1008.c
+++ b/drivers/misc/nct1008.c
@@ -81,7 +81,6 @@
 #define CELSIUS_TO_MILLICELSIUS(x) ((x)*1000)
 #define MILLICELSIUS_TO_CELSIUS(x) ((x)/1000)
 
-#define TEGRA_GPIO_PCC2		226
 #define	hysteresis_throttle	5
 static struct nct1008_data *pwr_data;
 static int nct1008_ready = 0;
@@ -485,7 +484,7 @@ static int nct1008_enable(struct i2c_client *client)
 	struct nct1008_data *data = i2c_get_clientdata(client);
 	int err;
 
-	printk(KERN_INFO "[TMS] nct1008_enable");
+	printk(KERN_INFO "[TMS] nct1008_enable\n");
 
 	err = i2c_smbus_write_byte_data(client, CONFIG_WR,
 				  data->config & ~STANDBY_BIT);
@@ -500,7 +499,7 @@ static int nct1008_disable(struct i2c_client *client)
 	struct nct1008_data *data = i2c_get_clientdata(client);
 	int err;
 
-	printk(KERN_INFO "[TMS] nct1008_disable");
+	printk(KERN_INFO "[TMS] nct1008_disable\n");
 
 	err = i2c_smbus_write_byte_data(client, CONFIG_WR,
 				  data->config | STANDBY_BIT);
@@ -527,7 +526,7 @@ static void nct1008_work_func(struct work_struct *work)
 	int intr_status;
 	struct timespec ts;
 
-	printk(KERN_INFO "[TMS] nct1008_work_func start");
+	printk(KERN_INFO "[TMS] nct1008_work_func start\n");
 
 	nct1008_disable(data->client);
 
@@ -546,7 +545,7 @@ static void nct1008_work_func(struct work_struct *work)
 
 	nct1008_enable(data->client);
 
-	printk(KERN_INFO "[TMS] nct1008_work_func end, status = %d ", intr_status);
+	printk(KERN_INFO "[TMS] nct1008_work_func end, status = %d\n", intr_status);
 
 	enable_irq(data->client->irq);
 }
@@ -583,9 +582,9 @@ static void nct1008_polling_func(struct work_struct *work)
 	temp_local = value_to_temperature(pdata->ext_range, value);
 
 	/* Get GPIO_PCC2 */
-	gpio_pcc2 = gpio_get_value(TEGRA_GPIO_PCC2);
+	gpio_pcc2 = gpio_get_value(pdata->gpio);
 
-	printk(KERN_INFO "[TMS] cpu temp = %d.%d, local temp = %d, gpio = %d ", temp_ext_hi, temp_ext_lo * 25,
+	printk(KERN_INFO "[TMS] cpu temp = %d.%d, local temp = %d, gpio = %d\n", temp_ext_hi, temp_ext_lo * 25,
 								temp_local, gpio_pcc2);
 
 	if (temp_ext_hi >= 85)
@@ -645,7 +644,7 @@ static void nct1008_read_temp_func(struct work_struct *work)
 	temp2 = value_to_temperature(pdata->ext_range, value);
 
 	printk(KERN_INFO "[PWR][TMS] cpu temp = %d.%d, local temp = %d,cpu shutdown temp = %d,"
-		"local shutdown temp = %d", temp_ext_hi, temp_ext_lo * 25, temp_local, temp2, temp);
+		"local shutdown temp = %d\n", temp_ext_hi, temp_ext_lo * 25, temp_local, temp2, temp);
 
 	/* Read config */
 	config = i2c_smbus_read_byte_data(data->client, CONFIG_RD);
@@ -658,9 +657,9 @@ static void nct1008_read_temp_func(struct work_struct *work)
 		goto error;
 
 	/* Get GPIO_PCC2 */
-	gpio_pcc2 = gpio_get_value(TEGRA_GPIO_PCC2);
+	gpio_pcc2 = gpio_get_value(pdata->gpio);
 
-	printk(KERN_INFO "[PWR][TMS] config = %d, status = %d ,gpio= %d ", config, intr_status, gpio_pcc2);
+	printk(KERN_INFO "[PWR][TMS] config = %d, status = %d ,gpio= %d\n", config, intr_status, gpio_pcc2);
 
 	schedule_delayed_work(&data->read_temp_work, msecs_to_jiffies(1000));
 
@@ -675,11 +674,11 @@ void nct1008_read_temp_for_key(int read_temp)
 
 	if (nct1008_ready) {
 		if (read_temp) {
-			printk(KERN_INFO "[PWR][TMS] start read temperature ");
+			printk(KERN_INFO "[PWR][TMS] start read temperature\n");
 			schedule_delayed_work(&data->read_temp_work, 0);
 		}
 		else {
-			printk(KERN_INFO "[PWR][TMS] stop read temperature ");
+			printk(KERN_INFO "[PWR][TMS] stop read temperature\n");
 			cancel_delayed_work(&data->read_temp_work);
 		}
 	}
@@ -690,7 +689,7 @@ static irqreturn_t nct1008_irq(int irq, void *dev_id)
 	struct nct1008_data *data = dev_id;
 
 	disable_irq_nosync(irq);
-	printk(KERN_INFO "[TMS] receive irq ");
+	printk(KERN_INFO "[TMS] receive irq\n");
 	queue_work(data->workqueue, &data->work);
 
 	return IRQ_HANDLED;
@@ -741,7 +740,7 @@ static int __devinit nct1008_configure_sensor(struct nct1008_data* data)
 	/* Read config */
 	value = i2c_smbus_read_byte_data(data->client, CONFIG_RD);
 	if (value < 0)
-		printk(KERN_INFO "[TMS] read config fail");
+		printk(KERN_INFO "[TMS] read config fail\n");
 	config = value & 4;
 
 	/* Place in Standby */
@@ -809,7 +808,7 @@ static int __devinit nct1008_configure_sensor(struct nct1008_data* data)
 	temp = value_to_temperature(config, value);
 	dev_dbg(&client->dev, "\n initial local temp = %d ", temp);
 
-	printk(KERN_INFO "[TMS] local temp = %d ", temp);
+	printk(KERN_INFO "[TMS] local temp = %d\n", temp);
 
 	value = i2c_smbus_read_byte_data(client, EXT_TEMP_RD_LO);
 	if (value < 0) {
@@ -828,12 +827,12 @@ static int __devinit nct1008_configure_sensor(struct nct1008_data* data)
 	if (temp2 > 0) {
 		dev_dbg(&client->dev, "\n initial ext temp = %d.%d deg",
 				temp, temp2 * 25);
-		printk(KERN_INFO "[TMS] remote temp = %d.%d ",
+		printk(KERN_INFO "[TMS] remote temp = %d.%d\n",
 				temp, temp2 * 25);
 	}
 	else {
 		dev_dbg(&client->dev, "\n initial ext temp = %d.0 deg", temp);
-		printk(KERN_INFO "[TMS] remote temp = %d.0 ", temp);
+		printk(KERN_INFO "[TMS] remote temp = %d.0\n", temp);
 	}
 
 	/* Remote channel offset */
@@ -909,17 +908,17 @@ int nct1008_thermal_set_limits(struct nct1008_data *data,
 	/* Read External Temp */
 	t_value = i2c_smbus_read_byte_data(data->client, EXT_TEMP_RD_LO);
 	if (t_value < 0)
-		printk(KERN_INFO "[TMS] read ext_temp_lo fail");
+		printk(KERN_INFO "[TMS] read ext_temp_lo fail\n");
 	temp_ext_lo = (t_value >> 6);
 
 	t_value = i2c_smbus_read_byte_data(data->client, EXT_TEMP_RD_HI);
 	if (t_value < 0)
-		printk(KERN_INFO "[TMS] read ext_temp_hi fail");
+		printk(KERN_INFO "[TMS] read ext_temp_hi fail\n");
 	temp_ext_hi = value_to_temperature(extended_range, t_value);
 
 	/* Get GPIO_PCC2 */
-	gpio_pcc2 = gpio_get_value(TEGRA_GPIO_PCC2);
-	printk(KERN_INFO "[TMS] current_temp=%d.%d, gpio_pcc2=%d", temp_ext_hi, temp_ext_lo * 25, gpio_pcc2);
+	gpio_pcc2 = gpio_get_value(data->plat_data.gpio);
+	printk(KERN_INFO "[TMS] current_temp=%d.%d, gpio_pcc2=%d\n", temp_ext_hi, temp_ext_lo * 25, gpio_pcc2);
 
 	if (lo_limit >= hi_limit)
 		return -EINVAL;
@@ -946,7 +945,7 @@ int nct1008_thermal_set_limits(struct nct1008_data *data,
 		data->current_hi_limit = hi_limit;
 	}
 
-	printk(KERN_INFO "[TMS] set hi_limit=%d, lo_limit=%d", hi_limit, lo_limit);
+	printk(KERN_INFO "[TMS] set hi_limit=%d, lo_limit=%d\n", hi_limit, lo_limit);
 
 	return 0;
 }
@@ -1074,14 +1073,14 @@ static int __devexit nct1008_remove(struct i2c_client *client)
 {
 	struct nct1008_data *data = i2c_get_clientdata(client);
 
-	printk(KERN_INFO "[TMS] nct1008_remove");
+	printk(KERN_INFO "[TMS] nct1008_remove\n");
 
 	if (data->dent)
 		debugfs_remove(data->dent);
 
 	free_irq(data->client->irq, data);
 
-	printk(KERN_INFO "[TMS] free irq(%d)", client->irq);
+	printk(KERN_INFO "[TMS] free irq(%d)\n", client->irq);
 
 	cancel_work_sync(&data->work);
 	sysfs_remove_group(&client->dev.kobj, &nct1008_attr_group);
@@ -1100,7 +1099,7 @@ static int nct1008_suspend(struct i2c_client *client, pm_message_t state)
 	int err;
 	struct nct1008_data *data = i2c_get_clientdata(client);
 
-	printk(KERN_INFO "[TMS] disable irq(%d)", client->irq);
+	printk(KERN_INFO "[TMS] disable irq(%d)\n", client->irq);
 	polling = 0;
 	cancel_delayed_work(&data->polling_work);
 	disable_irq(client->irq);
@@ -1120,7 +1119,7 @@ static int nct1008_resume(struct i2c_client *client)
 		return err;
 	}
 
-	printk(KERN_INFO "[TMS] enable irq(%d)", client->irq);
+	printk(KERN_INFO "[TMS] enable irq(%d)\n", client->irq);
 
 	enable_irq(client->irq);
 	/* shouldn't do here, wait irq trigger it */
diff --git a/drivers/misc/tegra_vibrator_enr.c b/drivers/misc/tegra_vibrator_enr.c
index 0c6ab1c..d93dc5e 100644
--- a/drivers/misc/tegra_vibrator_enr.c
+++ b/drivers/misc/tegra_vibrator_enr.c
@@ -28,6 +28,10 @@
 #include <linux/tegra_vibrator_enr.h>
 #include "../staging/android/timed_output.h"
 
+#include <linux/pm_qos_params.h>
+#include <linux/cpufreq.h>
+#define BOOST_CPU_FREQ_MIN 475000
+
 #define PLAYBACK_PERIOD_US 		50000
 #define PLAYBACK_DUTY_US 		36500
 #define ZERO_DUTY_US 			25000
@@ -50,10 +54,12 @@ struct vibrator {
 };
 
 struct vibrator *g_vib;
-//static struct regulator *regulator;
-static int timeout, debugmode;
+static struct regulator *regulator;
+static int cpulock, debugmode;
 static struct workqueue_struct *vib_work_queue;
 
+static struct pm_qos_request_list boost_cpu_freq_req;
+
 static enum hrtimer_restart vib_timer_func(struct hrtimer *timer)
 {
 	struct vibrator *vib = container_of(timer, struct vibrator, vib_timer);
@@ -65,10 +71,6 @@ static enum hrtimer_restart vib_timer_func(struct hrtimer *timer)
 	if(rc<0){
 		pr_err("[VIB] set gpio output direction fail in timer function\n");
 	}
-	rc = gpio_direction_output(vib->pdata->pwr_gpio, 0);
-	if(rc<0){
-		pr_err("[VIB] set pwr_gpio output direction fail in timer function\n");
-	}
 	queue_work(vib_work_queue, &vib->work);
 	I(" %s ---\n", __func__);
 	return HRTIMER_NORESTART;
@@ -80,17 +82,16 @@ static void vibrator_start(struct vibrator *vib)
 	I(" %s +++\n", __func__);
 	if (debugmode == 1)
 		printk("[VIB] vibrator_start\n");
-//	ret = regulator_is_enabled(regulator);
-//	if (ret > 0)
-//		regulator_disable(regulator);
+	ret = regulator_is_enabled(regulator);
+	if (ret > 0)
+		regulator_disable(regulator);
 	rc = pwm_config(vib->pdata->pwm_data.pwm_dev, g_vib->pwm_duty, PLAYBACK_PERIOD_US);
 	if (rc < 0) {
 		printk("[VIB][START]: pwm config fails\n");
 	}
 	pwm_enable(vib->pdata->pwm_data.pwm_dev);
 	gpio_direction_output(vib->pdata->ena_gpio, 1);
-//	regulator_enable(regulator);
-	gpio_direction_output(vib->pdata->pwr_gpio, 1);
+	regulator_enable(regulator);
 	I(" %s ---\n", __func__);
 }
 
@@ -108,10 +109,9 @@ static void vibrator_stop(struct vibrator *vib)
 	pwm_enable(vib->pdata->pwm_data.pwm_dev);
 	gpio_direction_output(vib->pdata->ena_gpio, 0);
 	pwm_disable(vib->pdata->pwm_data.pwm_dev);
-//	ret = regulator_is_enabled(regulator);
-//	if (ret > 0)
-//		regulator_disable(regulator);
-	gpio_direction_output(vib->pdata->pwr_gpio, 0);
+	ret = regulator_is_enabled(regulator);
+	if (ret > 0)
+		regulator_disable(regulator);
 	I(" %s ---\n", __func__);
 }
 
@@ -123,19 +123,32 @@ static void vibrator_stop(struct vibrator *vib)
 static void vibrator_enable(struct timed_output_dev *dev, int value)
 {
 	struct vibrator *vib = container_of(dev, struct vibrator, timed_dev);
-	timeout = value;
+	struct cpufreq_policy policy;
+	bool is_only_cpu0_online = (! (cpu_online(1) || cpu_online(2) || cpu_online(3)) );
 
 	I(" %s +++\n", __func__);
-
 	if (value < 0)
-		value = 0;
+		return;
 	if (value) {
-		printk("[VIB] vibrator_enable, vibration start and duration time = %d ms\n", value);
+		printk("[VIB] vibration enable and duration time = %d ms\n", value);
+		if(value==18) {
+			if(is_only_cpu0_online && cpufreq_get(0) < 475000) {
+				printk("[VIB] boost CPU#0 freq to 475MHZ\n");
+				/* To get policy of current cpu */
+				cpufreq_get_policy(&policy, smp_processor_id());
+				pm_qos_update_request(&boost_cpu_freq_req, (s32)BOOST_CPU_FREQ_MIN);
+				/* update frequency request right now */
+				cpufreq_driver_target(&policy,
+						BOOST_CPU_FREQ_MIN, CPUFREQ_RELATION_L);
+				cpulock = 1;
+			}
+		}
 		vibrator_start(vib);
 		hrtimer_start(&vib->vib_timer,
 			      ktime_set(value / 1000, (value % 1000) * 1000000),
 			      HRTIMER_MODE_REL);
 	} else {
+		printk("[VIB] vibration disable.\n");
 		vibrator_stop(vib);
 	}
 	I(" %s ---\n", __func__);
@@ -146,6 +159,10 @@ static void vib_work_func(struct work_struct *work)
 	struct vibrator *vib = container_of(work, struct vibrator, work);
 	I(" %s +++\n", __func__);
 	vibrator_stop(vib);
+	if( cpulock==1 ) {
+		pm_qos_update_request(&boost_cpu_freq_req, (s32)PM_QOS_CPU_FREQ_MIN_DEFAULT_VALUE);
+		cpulock = 0;
+	}
 	I(" %s ---\n", __func__);
 }
 
@@ -221,10 +238,9 @@ static int vibrator_probe(struct platform_device *pdev)
 		pr_err("[VIB] %s: failed on allocate pm8xxx_pwm_data memory\n", __func__);
 		goto err_platform_data_allocate;
 	}
-
+	pm_qos_add_request(&boost_cpu_freq_req, PM_QOS_CPU_FREQ_MIN, (s32)PM_QOS_CPU_FREQ_MIN_DEFAULT_VALUE);
 	vib->pdata->pwm_gpio = pdata->pwm_gpio;
 	vib->pdata->ena_gpio = pdata->ena_gpio;
-	vib->pdata->pwr_gpio = pdata->pwr_gpio;
 	vib->pdata->pwm_data.name = pdata->pwm_data.name;
 	vib->pdata->pwm_data.bank = pdata->pwm_data.bank;
 	vib->pwm_duty = PLAYBACK_DUTY_US;
@@ -249,21 +265,9 @@ static int vibrator_probe(struct platform_device *pdev)
 		goto err_ena_output;
 	}
 	tegra_gpio_enable(vib->pdata->ena_gpio);
-	gpio_free(vib->pdata->pwr_gpio);
-	rc = gpio_request(vib->pdata->pwr_gpio, "vibrator_pwr");
-	if (rc) {
-			rc = -ENOMEM;
-			pr_err("[VIB] request pwr gpio fail\n");
-		}
-	rc = gpio_direction_output(vib->pdata->pwr_gpio,0);
-	if(rc<0){
-		pr_err("[VIB] set gpio output direction fail\n");
-		goto err_pwr_output;
-	}
-	tegra_gpio_enable(vib->pdata->pwr_gpio);
-//	regulator = regulator_get(NULL, "v_vib_3v");
-//	if( (regulator==NULL) | (IS_ERR(regulator)) )
-//		pr_err("[VIB] Fail to get regulator: v_vib_3v");
+	regulator = regulator_get(NULL, "v_vib_3v");
+	if( (regulator==NULL) | (IS_ERR(regulator)) )
+		pr_err("[VIB] Fail to get regulator: v_vib_3v");
 
 	vib->timed_dev.name = "vibrator";
 	vib->timed_dev.get_time = vibrator_get_time;
@@ -289,7 +293,7 @@ static int vibrator_probe(struct platform_device *pdev)
 
 	g_vib = vib;
 	g_vib->pwm_duty = PLAYBACK_DUTY_US;
-	debugmode = 0;
+	debugmode = cpulock = 0;
 	platform_set_drvdata(pdev, vib);
 
 	printk("[VIB][PROBE] vibrator_probe ---\n");
@@ -297,8 +301,6 @@ static int vibrator_probe(struct platform_device *pdev)
 
 err_create_file:
 	timed_output_dev_unregister(&vib->timed_dev);
-err_pwr_output:
-	gpio_free(vib->pdata->pwr_gpio);
 err_ena_output:
 	gpio_free(vib->pdata->ena_gpio);
 	gpio_free(vib->pdata->pwm_gpio);
@@ -336,16 +338,15 @@ static int vibrator_resume(struct platform_device *pdev)
 static int __devexit vibrator_remove(struct platform_device *pdev)
 {
 	struct vibrator *vib = platform_get_drvdata(pdev);
-
+	pm_qos_remove_request(&boost_cpu_freq_req);
 	cancel_work_sync(&vib->work);
 	hrtimer_cancel(&vib->vib_timer);
 	gpio_free(vib->pdata->pwm_gpio);
 	gpio_free(vib->pdata->ena_gpio);
-	gpio_free(vib->pdata->pwr_gpio);
 	kfree(vib->pdata);
 	kfree(vib);
 	timed_output_dev_unregister(&vib->timed_dev);
-//	regulator_put(regulator);
+	regulator_put(regulator);
 	destroy_workqueue(vib_work_queue);
 	return 0;
 }
diff --git a/drivers/misc/ti-st/gps_drv.c b/drivers/misc/ti-st/gps_drv.c
index 56a88a4..8553dc2 100644
--- a/drivers/misc/ti-st/gps_drv.c
+++ b/drivers/misc/ti-st/gps_drv.c
@@ -260,7 +260,7 @@ void gpsdrv_tsklet_write(unsigned long data)
     if (((!hgps->st_write) || (0 == hgps->tx_count))
             || ((skb_queue_empty(&hgps->tx_list)))) {
 		spin_unlock(&hgps->lock);
-        GPSDRV_ERR("Sanity check Failed exiting %s", __func__);
+        GPSDRV_DBG("Sanity check Failed exiting %s", __func__);
         return;
     }
     /* hgps->tx_list not empty skb already present
@@ -438,7 +438,7 @@ ssize_t gpsdrv_read(struct file *file, char __user *data, size_t size,
     unsigned long timeout = GPSDRV_READ_TIMEOUT;
     struct gpsdrv_data *hgps;
 
-    //GPSDRV_DBG(" Inside %s", __func__);
+    GPSDRV_DBG(" Inside %s", __func__);
 
     /* Validate input parameters */
     if ((NULL == file) || (((NULL == data) || (0 == size)))) {
@@ -642,7 +642,7 @@ static long gpsdrv_ioctl(struct file *file,
     int     retCode = GPS_SUCCESS;
     struct gpsdrv_data *hgps;
 
-    //GPSDRV_DBG(" Inside %s", __func__);
+    GPSDRV_DBG(" Inside %s", __func__);
 
     /* Validate input parameters */
     if ((NULL == file) || (0 == cmd)) {
diff --git a/drivers/misc/ti-st/st_core.c b/drivers/misc/ti-st/st_core.c
index 247025c..d12d430 100644
--- a/drivers/misc/ti-st/st_core.c
+++ b/drivers/misc/ti-st/st_core.c
@@ -30,7 +30,6 @@
 
 #include <linux/ti_wilink_st.h>
 #include "gps_drv.h"
-#include <htc/log.h>
 
 #ifdef PWR_DEVICE_TAG
 #undef PWR_DEVICE_TAG
@@ -275,7 +274,7 @@ void st_int_recv(void *disc_data,
 			switch (st_gdata->rx_state) {
 			/* Waiting for complete packet ? */
 			case ST_W4_DATA:
-				sp_pr_info("Complete pkt received\n");
+				pr_debug("Complete pkt received\n");
 				/* Ask ST CORE to forward
 				 * the packet to protocol driver */
 				st_send_frame(st_gdata->rx_chnl, st_gdata);
@@ -289,14 +288,14 @@ void st_int_recv(void *disc_data,
 				plen =
 				&st_gdata->rx_skb->data
 				[proto->offset_len_in_hdr];
-				sp_pr_debug("plen pointing to %x\n", *plen);
+				pr_debug("plen pointing to %x\n", *plen);
 				if (proto->len_size == 1)/* 1 byte len field */
 					payload_len = *(unsigned char *)plen;
 				else if (proto->len_size == 2)
 					payload_len =
 					__le16_to_cpu(*(unsigned short *)plen);
 				else
-					sp_pr_info("%s: invalid length "
+					pr_info("%s: invalid length "
 					"for id %d\n",
 					__func__, proto->chnl_id);
 				st_check_data_len(st_gdata, proto->chnl_id,
@@ -314,7 +313,7 @@ void st_int_recv(void *disc_data,
 		case LL_SLEEP_IND:
 		case LL_SLEEP_ACK:
 		case LL_WAKE_UP_IND:
-			sp_pr_debug("PM packet\n");
+			pr_debug("PM packet\n");
 			/* this takes appropriate action based on
 			 * sleep state received --
 			 */
@@ -331,7 +330,7 @@ void st_int_recv(void *disc_data,
 			count--;
 			continue;
 		case LL_WAKE_UP_ACK:
-			sp_pr_debug("PM packet\n");
+			pr_debug("PM packet\n");
 
 			spin_unlock_irqrestore(&st_gdata->lock, flags);
 			/* wake up ack received */
@@ -554,11 +553,12 @@ long st_register(struct st_proto_s *new_proto)
 		set_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);
 		st_recv = st_kim_recv;
 
+		/* enable the ST LL - to set default chip state */
+		st_ll_enable(st_gdata);
+
 		/* release lock previously held - re-locked below */
 		spin_unlock_irqrestore(&st_gdata->lock, flags);
 
-		/* enable the ST LL - to set default chip state */
-		st_ll_enable(st_gdata);
 		/* this may take a while to complete
 		 * since it involves BT fw download
 		 */
@@ -569,9 +569,13 @@ long st_register(struct st_proto_s *new_proto)
 			    (test_bit(ST_REG_PENDING, &st_gdata->st_state))) {
 				pr_err(" KIM failure complete callback \n");
 				st_reg_complete(st_gdata, err);
+				clear_bit(ST_REG_PENDING, &st_gdata->st_state);
 			}
 			return -EINVAL;
 		}
+
+		spin_lock_irqsave(&st_gdata->lock, flags);
+
 		clear_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);
 
 		st_recv = st_int_recv;
@@ -592,10 +596,10 @@ long st_register(struct st_proto_s *new_proto)
 		if (st_gdata->is_registered[new_proto->chnl_id] == true) {
 			pr_err(" proto %d already registered \n",
 				   new_proto->chnl_id);
+			spin_unlock_irqrestore(&st_gdata->lock, flags);
 			return -EALREADY;
 		}
 
-		spin_lock_irqsave(&st_gdata->lock, flags);
 		add_channel_to_table(st_gdata, new_proto);
 		st_gdata->protos_registered++;
 		new_proto->write = st_write;
@@ -635,8 +639,8 @@ long st_unregister(struct st_proto_s *proto)
 
 	spin_lock_irqsave(&st_gdata->lock, flags);
 
-	if (st_gdata->list[proto->chnl_id] == NULL) {
-		sp_pr_err(" chnl_id %d not registered\n", proto->chnl_id);
+	if (st_gdata->is_registered[proto->chnl_id] == false) {
+		pr_err(" chnl_id %d not registered\n", proto->chnl_id);
 		spin_unlock_irqrestore(&st_gdata->lock, flags);
 		return -EPROTONOSUPPORT;
 	}
@@ -645,9 +649,13 @@ long st_unregister(struct st_proto_s *proto)
 	remove_channel_from_table(st_gdata, proto);
 	spin_unlock_irqrestore(&st_gdata->lock, flags);
 
+	/* paranoid check */
+	if (st_gdata->protos_registered < ST_EMPTY)
+	    st_gdata->protos_registered = ST_EMPTY;
+
 	if ((st_gdata->protos_registered == ST_EMPTY) &&
 	    (!test_bit(ST_REG_PENDING, &st_gdata->st_state))) {
-		sp_pr_info(" all chnl_ids unregistered \n");
+		pr_info(" all chnl_ids unregistered \n");
 
 		/* stop traffic on tty */
 		if (st_gdata->tty) {
@@ -743,7 +751,7 @@ static void st_tty_close(struct tty_struct *tty)
 	spin_lock_irqsave(&st_gdata->lock, flags);
 	for (i = ST_BT; i < ST_MAX_CHANNELS; i++) {
 		if (st_gdata->is_registered[i] == true)
-			sp_pr_err("%d not un-registered\n", i);
+			pr_err("%d not un-registered\n", i);
 		st_gdata->list[i] = NULL;
 	}
 	st_gdata->protos_registered = 0;
diff --git a/drivers/misc/ti-st/st_kim.c b/drivers/misc/ti-st/st_kim.c
index 6d9a9c6..a6653bd 100644
--- a/drivers/misc/ti-st/st_kim.c
+++ b/drivers/misc/ti-st/st_kim.c
@@ -30,6 +30,7 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/sched.h>
+#include <linux/sysfs.h>
 #include <linux/tty.h>
 
 #include <linux/serial_core.h>
@@ -64,7 +65,7 @@ static struct rfkill_ops wl127x_rfkill_ops = {
 /* rfkill define end */
 
 static struct platform_device *st_kim_devices[MAX_ST_DEVICES];
-static int rfkilltool_on = 0;
+
 /**********************************************************************/
 /* internal functions */
 
@@ -471,8 +472,9 @@ long st_kim_start(void *kim_data)
 	long retry = POR_RETRY_COUNT;
 	struct kim_data_s	*kim_gdata = (struct kim_data_s *)kim_data;
 	struct ti_st_plat_data	*pdata = kim_gdata->kim_pdev->dev.platform_data;
+	struct tty_struct	*tty = kim_gdata->core_data->tty;
 
-	printk("st_kim_start_entering 1222 v3\n");
+	printk("st_kim_start_entering 0419 v4\n");
 	pr_info(" %s\n", __func__);
 
 	blue_pincfg_uartc_resume();
@@ -505,6 +507,14 @@ long st_kim_start(void *kim_data)
 
 		if (!err) {	/* timeout */
 			pr_err("line disc installation timed out ");
+
+			if (tty) {	/* can be called before ldisc is installed */
+				/* Flush any pending characters in the driver and discipline. */
+				tty_ldisc_flush(tty);
+				tty_driver_flush_buffer(tty);
+				tty->ops->flush_buffer(tty);
+			}
+
 			kim_gdata->ldisc_install = 0;
 			pr_info("ldisc_install = 0\n");
 			pr_info("Close UART and retry\n");
@@ -523,6 +533,16 @@ long st_kim_start(void *kim_data)
 			err = download_firmware(kim_gdata);
 			if (err != 0) {
 				pr_err("download firmware failed");
+
+				if (tty) {
+					/* Flush any pending characters in the driver and
+					 * discipline.
+					 */
+					tty_ldisc_flush(tty);
+					tty_driver_flush_buffer(tty);
+					tty->ops->flush_buffer(tty);
+				}
+
 				kim_gdata->ldisc_install = 0;
 				pr_info("ldisc_install = 0\n");
 				sysfs_notify(&kim_gdata->kim_pdev->dev.kobj,
@@ -558,13 +578,16 @@ long st_kim_stop(void *kim_data)
 
 	struct ti_st_plat_data	*pdata =
 		kim_gdata->kim_pdev->dev.platform_data;
-
+	struct tty_struct	*tty = kim_gdata->core_data->tty;
 
 	INIT_COMPLETION(kim_gdata->ldisc_installed);
 
+	if (tty) {	/* can be called before ldisc is installed */
 	/* Flush any pending characters in the driver and discipline. */
-	tty_ldisc_flush(kim_gdata->core_data->tty);
-	tty_driver_flush_buffer(kim_gdata->core_data->tty);
+		tty_ldisc_flush(tty);
+		tty_driver_flush_buffer(tty);
+		tty->ops->flush_buffer(tty);
+	}
 
 	/* send uninstall notification to UIM */
 	pr_info("ldisc_install = 0\n");
@@ -622,23 +645,6 @@ static ssize_t show_install(struct device *dev,
 	return sprintf(buf, "%d\n", kim_data->ldisc_install);
 }
 
-static ssize_t show_rfkilltool(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct kim_data_s *kim_data = dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", rfkilltool_on);
-}
-
-static ssize_t store_rfkilltool(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct kim_data_s *kim_data = dev_get_drvdata(dev);
-	kim_data->rfkilltool = 1;
-	rfkilltool_on = 1;
-	pr_info("set store_rfkilltool on\n");
-	return kim_data->rfkilltool;
-}
-
 static ssize_t show_dev_name(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -673,15 +679,11 @@ __ATTR(baud_rate, 0444, (void *)show_baud_rate, NULL);
 static struct kobj_attribute uart_flow_cntrl =
 __ATTR(flow_cntrl, 0444, (void *)show_flow_cntrl, NULL);
 
-static struct kobj_attribute rfkilltool =
-__ATTR(rfkilltool, 0644, (void *)show_rfkilltool, (void *)store_rfkilltool);
-
 static struct attribute *uim_attrs[] = {
 	&ldisc_install.attr,
 	&uart_dev_name.attr,
 	&uart_baud_rate.attr,
 	&uart_flow_cntrl.attr,
-	&rfkilltool.attr,
 	NULL,
 };
 
@@ -950,10 +952,6 @@ static int wl127x_set_power(void *data, bool blocked)
 static void wl127x_config_bt_off()
 {
 	pr_info("wl127x_config_bt_off: Entering\n");
-        if (rfkilltool_on == 0) {
-                pr_info("wl127x_config_bt_off, rfkilltool_on off\n");
-                return;
-        }
 
         blue_pincfg_uartc_suspend();
 	mdelay(1);
@@ -972,10 +970,6 @@ static void wl127x_config_bt_off()
 static void wl127x_config_bt_on()
 {
 	pr_info("wl127x_config_bt_on: Entering\n");
-	if (rfkilltool_on == 0) {
-		pr_info("wl127x_config_bt_on, rfkilltool_on off\n");
-		return;
-	}
 	//Avoid change rfkill state after boot up 
 	if ((rfkill_counter != 0) && (get_suspend_state() == PM_SUSPEND_ON) && (!after_BT_GPS_on)) {
 		long err = 0;
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 15570e7..66cfcb2 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -328,10 +328,13 @@ static int mmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
 	from = blk_rq_pos(req);
 	nr = blk_rq_sectors(req);
 
+/*
 	if (mmc_can_trim(card) && !mmc_erase_group_aligned(card, from, nr))
 		arg = MMC_SECURE_TRIM1_ARG;
 	else
 		arg = MMC_SECURE_ERASE_ARG;
+*/
+	arg = MMC_ERASE_ARG;
 
 	if (card->quirks & MMC_QUIRK_INAND_CMD38) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
@@ -557,9 +560,10 @@ static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 		spin_unlock_irq(&md->lock);
 	} while (ret);
 
+/*
 	if (brq.cmd.resp[0] & R1_URGENT_BKOPS)
 		mmc_card_set_need_bkops(card);
-
+*/
 	mmc_release_host(card->host);
 
 	return 1;
@@ -780,6 +784,7 @@ static int mmc_blk_probe(struct mmc_card *card)
 	mmc_set_bus_resume_policy(card->host, 1);
 #endif
 	add_disk(md->disk);
+	card->mmcblk_dev = disk_to_dev(md->disk);
 	return 0;
 
  out:
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 111cc52..b9bedbf 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1547,6 +1547,11 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		/* Do not retry else we can't see errors */
 		err = mmc_wait_for_cmd(card->host, &cmd, 0);
 		if (err || (cmd.resp[0] & 0xFDF92000)) {
+			if (cmd.resp[0] & 0x08000000) {
+				printk(KERN_ERR "Invalid erase parameters: ARG(0x%08x) FROM(0x%08x) TO(0x%08x)\n",
+					arg, from, to);
+			}
+
 			printk(KERN_ERR "error %d requesting status %#x\n",
 				err, cmd.resp[0]);
 			err = -EIO;
@@ -1660,10 +1665,9 @@ EXPORT_SYMBOL(mmc_can_discard);
 
 int mmc_can_secure_erase_trim(struct mmc_card *card)
 {
-/*
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN)
 		return 1;
-*/
+
 	return 0;
 }
 EXPORT_SYMBOL(mmc_can_secure_erase_trim);
@@ -1930,11 +1934,11 @@ int mmc_suspend_host(struct mmc_host *host)
 
 	if (mmc_bus_needs_resume(host))
 		return 0;
-
+/*
 	if (mmc_card_mmc(host->card) && mmc_card_doing_bkops(host->card))
 		mmc_interrupt_hpi(host->card);
 	mmc_card_clr_need_bkops(host->card);
-
+*/
 	if (host->caps & MMC_CAP_DISABLE)
 		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
@@ -2009,7 +2013,7 @@ int mmc_resume_host(struct mmc_host *host)
 			err = 0;
 		}
 	}
-#if defined CONFIG_MACH_ENDEAVORU || defined CONFIG_MACH_ENDEAVORTD
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
     if(host->index==1) {
         host->pm_flags &= ~MMC_PM_KEEP_POWER;
     }
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 21ba65f..813e38b 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -22,6 +22,13 @@
 #include "mmc_ops.h"
 #include "sd_ops.h"
 
+#include <linux/android_alarm.h>
+
+extern int htc_mmc_needs_bkops;
+extern int htc_mmc_bkops_flag;
+extern u64 bkops_end;
+extern u64 bkops_start;
+
 static const unsigned int tran_exp[] = {
 	10000,		100000,		1000000,	10000000,
 	0,		0,		0,		0
@@ -457,6 +464,19 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
+	if (oldcard && host->index == 0 && htc_mmc_bkops_flag) {
+		bkops_end = ktime_to_ms(ktime_get_real());
+
+		if (bkops_end > bkops_start)
+			htc_mmc_needs_bkops -= (bkops_end - bkops_start);
+
+		if (htc_mmc_needs_bkops < 0)
+			htc_mmc_needs_bkops = 0;
+
+		mmc_card_clr_doing_bkops(oldcard);
+		htc_mmc_bkops_flag = 0;
+	}
+
 	/*
 	 * Since we're changing the OCR value, we seem to
 	 * need to tell some cards to go back to the idle
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 9e7cc41..96fba7b 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -618,7 +618,7 @@ int mmc_send_bk_ops_cmd(struct mmc_card *card, bool is_synchronous)
 
 	cmd.opcode = MMC_SWITCH;
 	cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-		(EXT_CSD_BKOPS_EN << 16) |
+		(EXT_CSD_BKOPS_START << 16) |
 		(1 << 8) |
 		EXT_CSD_CMD_SET_NORMAL;
 	if (is_synchronous)
@@ -631,6 +631,9 @@ int mmc_send_bk_ops_cmd(struct mmc_card *card, bool is_synchronous)
 		return err;
 
 	/* Must check status to be sure of no errors */
+	if (!is_synchronous)
+		return 0;
+
 	do {
 		err = mmc_send_status(card, &status);
 		if (err)
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 36e5c03..0dbbcf3 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -914,7 +914,7 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 		}
 	}
 
-#if defined CONFIG_MACH_ENDEAVORU || defined CONFIG_MACH_ENDEAVORTD
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 	if (!err && host->pm_flags & MMC_PM_KEEP_POWER && mmc_card_wake_sdio_irq(host)) {
 #else
 	if (!err && host->pm_flags & MMC_PM_KEEP_POWER) {
@@ -941,7 +941,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	if (mmc_card_is_removable(host) || !mmc_card_is_powered_resumed(host)) {
 		err = mmc_sdio_init_card(host, host->ocr, host->card,
 								 (host->pm_flags & MMC_PM_KEEP_POWER));
-#if defined CONFIG_MACH_ENDEAVORU || defined CONFIG_MACH_ENDEAVORTD
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 	} else if (mmc_card_is_powered_resumed(host) && mmc_card_wake_sdio_irq(host)) {
 #else
 	} else if (mmc_card_is_powered_resumed(host)) {
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index 94b78b1..5ecced0 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -30,13 +30,18 @@
 #include <linux/mmc/host.h>
 
 #include <linux/io.h>
+#include <linux/mmc/card.h>
 #include <linux/mmc/sdhci-pltfm.h>
 
 #include "sdhci.h"
 #include "sdhci-pltfm.h"
 
+#include <linux/android_alarm.h>
+
+#define cls_dev_to_mmc_host(d)	container_of(d, struct mmc_host, class_dev)
+
 //HTC_CSP_START
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 #include <mach/iomap.h>
 
 struct platform_device *mmci_get_platform_device(void);
@@ -52,6 +57,78 @@ wlan_sdioDrv_t g_wlan_sdioDrv;
 #endif
 //HTC_CSP_END
 
+struct alarm htc_mmc_bkops_alarm;
+int htc_mmc_bkops_flag = 0;
+int htc_mmc_bkops_alarm_flag = 0;
+u64 htc_mmc_needs_bkops = 0;
+u64 bkops_start = 0;
+u64 bkops_end = 0;
+
+static ssize_t mmc_bkops_store(struct device *dev,
+							struct device_attribute *attr,
+							const char *buf, size_t count)
+{
+	sscanf(buf, "%llu", &htc_mmc_needs_bkops);
+	return count;
+}
+
+static ssize_t mmc_bkops_show(struct device *dev,
+							struct device_attribute *attr,
+							const char *buf)
+{
+	return sprintf(buf, "%llu\n", htc_mmc_needs_bkops);
+}
+static DEVICE_ATTR(bkops, 0664, mmc_bkops_show, mmc_bkops_store);
+
+static ssize_t mmc_bkops_time_show(struct device *dev,
+							struct device_attribute *attr,
+							const char *buf)
+{
+	u64 time_spent = 0;
+	if (bkops_end > bkops_start)
+		time_spent = bkops_end - bkops_start;
+
+	return sprintf(buf, "%llu\n", time_spent);
+}
+static DEVICE_ATTR(bkops_time, 0664, mmc_bkops_time_show, NULL);
+
+static void mmc_bkops_alarm_handler(struct alarm *alarm)
+{
+	printk(KERN_INFO "mmc0: %s\n", __func__);
+    return;
+}
+
+static ssize_t
+show_burst(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mmc_host *host = cls_dev_to_mmc_host(dev);
+	if (!host)
+		return 0;
+	return sprintf(buf, "%d", host->burst_mode);
+}
+
+static ssize_t
+set_burst(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct mmc_host *host = cls_dev_to_mmc_host(dev);
+	char *envp[3] = {"SWITCH_NAME=camera_burst",0, 0};
+	if (!host || !host->card || !host->card->mmcblk_dev)
+		return 0;
+	sscanf(buf, "%d", &host->burst_mode);
+	pr_info("%s: %d\n", __func__, host->burst_mode);
+	if (!host->burst_mode) {
+		envp[1] = "SWITCH_STATE=0";
+	} else {
+		envp[1] = "SWITCH_STATE=1";
+	}
+
+	kobject_uevent_env(&host->card->mmcblk_dev->kobj, KOBJ_CHANGE, envp);
+	return count;
+}
+static DEVICE_ATTR(burst, S_IRUGO | S_IWUSR | S_IWGRP,
+		show_burst, set_burst);
+
 /*****************************************************************************\
  *                                                                           *
  * SDHCI core callbacks                                                      *
@@ -88,7 +165,7 @@ static int __devinit sdhci_pltfm_probe(struct platform_device *pdev)
 	}
 
 //HTC_CSP_START
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
     int addr = 0;
     addr = iomem->start;
     //printk(KERN_INFO "start addr = 0x%x\n", addr);
@@ -149,7 +226,7 @@ static int __devinit sdhci_pltfm_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, host);
 
 //HTC_CSP_START
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 //printk(KERN_INFO "[SD] SdioDrv_probe pdev:0x%x  mmc:0x%x  mmc->index=%d pdev->resource[1].start=%x, addr=%x\n",
 //		   (int)pdev, host->mmc, host->mmc->index, pdev->resource[1].start, addr);
 
@@ -164,6 +241,27 @@ static int __devinit sdhci_pltfm_probe(struct platform_device *pdev)
 #endif
 //HTC_CSP_END
 
+	if (addr == TEGRA_SDMMC4_BASE) {
+		printk(KERN_INFO "mmc0: bkops alarm init\n");
+		alarm_init(&htc_mmc_bkops_alarm,
+            ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+            mmc_bkops_alarm_handler);
+
+		ret = device_create_file(&host->mmc->class_dev,
+				&dev_attr_bkops);
+		if (ret)
+			goto err_add_host;
+
+		ret = device_create_file(&host->mmc->class_dev,
+				&dev_attr_bkops_time);
+		if (ret)
+			goto err_add_host;
+
+		ret = device_create_file(&host->mmc->class_dev,
+				&dev_attr_burst);
+		if (ret)
+			goto err_add_host;
+	}
 
 	return 0;
 
@@ -263,25 +361,90 @@ static int sdhci_pltfm_resume(struct platform_device *dev)
 
 	return ret;
 }
+
+static int sdhci_pltfm_suspend_pm(struct device *dev)
+{
+	struct platform_device *plt_dev = to_platform_device(dev);
+	return sdhci_pltfm_suspend(plt_dev, PMSG_SUSPEND);
+}
+
+static int sdhci_pltfm_resume_pm(struct device *dev)
+{
+	struct platform_device *plt_dev = to_platform_device(dev);
+	return sdhci_pltfm_resume(plt_dev);
+}
 #else
 #define sdhci_pltfm_suspend	NULL
 #define sdhci_pltfm_resume	NULL
+#define sdhci_pltfm_suspend_pm	NULL
+#define sdhci_pltfm_resume_pm	NULL
 #endif	/* CONFIG_PM */
 
+static int sdhci_pltfm_prepare(struct device *dev) {
+	struct platform_device *plt_dev = to_platform_device(dev);
+	struct sdhci_host *host = platform_get_drvdata(plt_dev);
+
+	if (host->mmc && host->mmc->card && host->mmc->card->type == MMC_TYPE_MMC) {
+		if (htc_mmc_needs_bkops) {
+			ktime_t interval;
+			ktime_t next_alarm;
+			long alarm_sec = ((u32) htc_mmc_needs_bkops) / 1000 + 20;
+
+			interval = ktime_set(alarm_sec, 0);
+			printk(KERN_INFO "mmc0: setup alarm, and wake up system after %llu ms\n",
+				ktime_to_ms(interval));
+
+			next_alarm = ktime_add(alarm_get_elapsed_realtime(), interval);
+
+			alarm_start_range(&htc_mmc_bkops_alarm,
+				next_alarm, ktime_add(next_alarm, ktime_set(0,0)));
+
+			htc_mmc_bkops_alarm_flag = 1;
+		}
+	}
+
+	return 0;
+}
+
+static int sdhci_pltfm_complete(struct device *dev) {
+/*
+	struct platform_device *plt_dev = to_platform_device(dev);
+	struct sdhci_host *host = platform_get_drvdata(plt_dev);
+	int ret = 0;
+
+	if (host->mmc && host->mmc->card && host->mmc->card->type == MMC_TYPE_MMC) {
+		printk(KERN_INFO "mmc0: Cancel alarm if it exists (%s)\n", __func__);
+		if (htc_mmc_bkops_alarm_flag) {
+			ret = alarm_cancel(&htc_mmc_bkops_alarm);
+			htc_mmc_bkops_alarm_flag = 0;
+		}
+	}
+*/
+	return 0;
+}
+
+static struct dev_pm_ops htc_mmc_pm_ops = {
+    .prepare = sdhci_pltfm_prepare,
+    .complete = sdhci_pltfm_complete,
+	.suspend = sdhci_pltfm_suspend_pm,
+	.resume	= sdhci_pltfm_resume_pm,
+};
+
 static struct platform_driver sdhci_pltfm_driver = {
 	.driver = {
 		.name	= "sdhci",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &htc_mmc_pm_ops,
+#endif
 	},
 	.probe		= sdhci_pltfm_probe,
 	.remove		= __devexit_p(sdhci_pltfm_remove),
 	.id_table	= sdhci_pltfm_ids,
-	.suspend	= sdhci_pltfm_suspend,
-	.resume		= sdhci_pltfm_resume,
 };
 
 //HTC_CSP_START
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 struct platform_device *mmci_get_platform_device(void){
 	printk(KERN_INFO "sdhci-tegra.c  g_wlan_sdioDrv.pdev = 0x%x\n", g_wlan_sdioDrv.pdev);
 	return g_wlan_sdioDrv.pdev;
diff --git a/drivers/mmc/host/sdhci-tegra.c b/drivers/mmc/host/sdhci-tegra.c
index b135a7d..41b1053 100644
--- a/drivers/mmc/host/sdhci-tegra.c
+++ b/drivers/mmc/host/sdhci-tegra.c
@@ -56,10 +56,13 @@
 #define TEGRA2_SDHOST_STD_FREQ	50000000
 #define TEGRA3_SDHOST_STD_FREQ	104000000
 
+#define TEGRA_PRIMARY_ICTLR_BASE 0x60004000
+
 static unsigned int tegra_sdhost_min_freq;
 static unsigned int tegra_sdhost_std_freq;
 static void tegra_3x_sdhci_set_card_clock(struct sdhci_host *sdhci, unsigned int clock);
 static void tegra3_sdhci_post_reset_init(struct sdhci_host *sdhci);
+static void tegra_sdhci_dump_irq_reg(struct sdhci_host *sdhci);
 
 static unsigned int tegra3_sdhost_max_clk[4] = {
 	208000000,	104000000,	208000000,	104000000 };
@@ -666,6 +669,7 @@ static int tegra_sdhci_pltfm_init(struct sdhci_host *host,
 
 	host->mmc->caps |= MMC_CAP_ERASE;
 	host->mmc->caps |= MMC_CAP_DISABLE;
+	host->mmc->caps |= MMC_CAP_BKOPS;
 	/* enable 1/8V DDR capable */
 	host->mmc->caps |= MMC_CAP_1_8V_DDR;
 	if (plat->is_8bit)
@@ -848,6 +852,13 @@ static int tegra_sdhci_get_min_clock(struct sdhci_host *sdhci)
 	return 400000;
 }
 
+static void tegra_sdhci_dump_irq_reg(struct sdhci_host *sdhci)
+{
+	if (sdhci && sdhci->mmc)
+		printk(KERN_INFO "%s: PRI_ICTRL_ISR_0: 0x%08x\n",
+			mmc_hostname(sdhci->mmc), readl(IO_ADDRESS(TEGRA_PRIMARY_ICTLR_BASE + 0x10)));
+}
+
 static struct sdhci_ops tegra_sdhci_ops = {
 	.get_ro     = tegra_sdhci_get_ro,
 	.read_l     = tegra_sdhci_readl,
@@ -862,6 +873,7 @@ static struct sdhci_ops tegra_sdhci_ops = {
 	.platform_reset_exit = tegra_sdhci_reset_exit,
 	.set_uhs_signaling = tegra_sdhci_set_uhs_signaling,
 	.switch_signal_voltage = tegra_sdhci_signal_voltage_switch,
+	.dump_irq_reg = tegra_sdhci_dump_irq_reg,
 };
 
 struct sdhci_pltfm_data sdhci_tegra_pdata = {
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index f9acb7c..0e573a3 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -29,6 +29,8 @@
 
 #include "sdhci.h"
 
+#include <linux/android_alarm.h>
+
 #define DRIVER_NAME "sdhci"
 
 #define DBG(f, x...) \
@@ -41,6 +43,12 @@
 
 #define MAX_TUNING_LOOP 40
 
+extern struct alarm htc_mmc_bkops_alarm;
+extern int htc_mmc_bkops_flag;
+extern int htc_mmc_bkops_alarm_flag;
+extern u64 htc_mmc_needs_bkops;
+extern u64 bkops_start;
+
 static unsigned int debug_quirks = 0;
 
 static void sdhci_prepare_data(struct sdhci_host *, struct mmc_data *);
@@ -1062,9 +1070,9 @@ out:
 	host->clock = clock;
 }
 // HTC_WIFI_START
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 static int wifi_is_on = 0;
-extern int enterprise_wifi_power(int on);
+extern int endeavor_wifi_power(int on);
 void set_wifi_is_on (int on){
     wifi_is_on = on;
 }
@@ -1077,9 +1085,9 @@ static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
 
 	if (power != (unsigned short)-1) {
 		// HTC_WIFI_START
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 	if(host->mmc->index==1)
-		enterprise_wifi_power(1);
+		endeavor_wifi_power(1);
 #endif
 		// HTC_WIFI_END
 		switch (1 << power) {
@@ -1100,9 +1108,9 @@ static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
 	}
 	else {
 		// HTC_WIFI_START
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 		if(host->mmc->index==1)
-			enterprise_wifi_power(0);
+			endeavor_wifi_power(0);
 #endif
 		// HTC_WIFI_END
 	}
@@ -1827,6 +1835,9 @@ static void sdhci_timeout_timer(unsigned long data)
 			"interrupt.\n", mmc_hostname(host->mmc));
 		sdhci_dumpregs(host);
 
+		if(host->ops && host->ops->dump_irq_reg)
+			host->ops->dump_irq_reg(host);
+
 		if (host->data) {
 			host->data->error = -ETIMEDOUT;
 			sdhci_finish_data(host);
@@ -2145,11 +2156,24 @@ int sdhci_suspend_host(struct sdhci_host *host, pm_message_t state)
 
 	sdhci_disable_card_detection(host);
 
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 	if (mmc->card) { //austin && (mmc->card->type != MMC_TYPE_SDIO))
 #else
     if (mmc->card && (mmc->card->type != MMC_TYPE_SDIO)) {
 #endif
+		if (mmc->card->type == MMC_TYPE_MMC) {
+			if (htc_mmc_needs_bkops) {
+				int ret = 0;
+				pr_info("%s: Force to do bkops at least %llu ms\n",
+					mmc_hostname(mmc), htc_mmc_needs_bkops);
+
+				if (ret = mmc_bkops_start(mmc->card, false))
+					pr_err("%s: Failed to send bkops (%d)\n", mmc_hostname(mmc), ret);
+
+				htc_mmc_bkops_flag = 1;
+				bkops_start = ktime_to_ms(ktime_get_real());
+			}
+		}
         ret = mmc_suspend_host(host->mmc);
     }
 
@@ -2197,7 +2221,7 @@ int sdhci_resume_host(struct sdhci_host *host)
 		if (mmc->card->type != MMC_TYPE_SDIO) {
 			ret = mmc_resume_host(host->mmc);
 		} else {
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
             printk("wifi_is_on: %d\n",wifi_is_on);
             if (host->mmc->index == 1 && wifi_is_on == 1) {
                 printk("%s: host->mmc->index = %d, call mmc_resume_host()\n"
@@ -2424,7 +2448,7 @@ int sdhci_add_host(struct sdhci_host *host)
 	if ((host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION) &&
 	    mmc_card_is_removable(mmc))
 		mmc->caps |= MMC_CAP_NEEDS_POLL;
-#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD)
+#if defined(CONFIG_MACH_ENDEAVORU) || defined(CONFIG_MACH_ENDEAVORTD) || defined(CONFIG_MACH_ERAU)
 	/* HTC_WIFI_START */
 	if(host->mmc->index==1) {
 		mmc->caps |= MMC_CAP_NONREMOVABLE;
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index cac06f4..8498529 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -264,6 +264,8 @@ struct sdhci_ops {
 	int	(*set_uhs_signaling)(struct sdhci_host *host, unsigned int uhs);
 	int	(*switch_signal_voltage)(struct sdhci_host *host,
 				unsigned int signal_voltage);
+	/* Dump irq register for debug usage */
+	void (*dump_irq_reg)(struct sdhci_host *host);
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index 6d83ec2..a4815d8 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -31,3 +31,6 @@ obj-$(CONFIG_USB_VL600)		+= lg-vl600.o
 ifeq (${CONFIG_MACH_ENDEAVORU},y)
 obj-$(CONFIG_USB_NET_RAW_IP)	+= raw_ip_net.o
 endif
+ifeq (${CONFIG_MACH_ERAU},y)
+obj-$(CONFIG_USB_NET_RAW_IP)	+= raw_ip_net.o
+endif
diff --git a/drivers/net/usb/raw_ip_net.c b/drivers/net/usb/raw_ip_net.c
index c2d1c3b..c3b4669 100644
--- a/drivers/net/usb/raw_ip_net.c
+++ b/drivers/net/usb/raw_ip_net.c
@@ -830,7 +830,7 @@ static int usb_net_raw_ip_rx_urb_submit(struct baseband_usb *usb)
 	usb->usb.rx_urb = urb;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		pr_err("usb_submit_urb() failed - err %d\n", err);
+		pr_info("usb_submit_urb() failed - err %d\n", err);
 		usb->usb.rx_urb = (struct urb *) 0;
 		return err;
 	}
@@ -841,7 +841,16 @@ static int usb_net_raw_ip_rx_urb_submit(struct baseband_usb *usb)
 
 static void usb_net_raw_ip_rx_urb_comp(struct urb *urb)
 {
-	struct baseband_usb *usb = (struct baseband_usb *) urb->context;
+	struct baseband_usb *usb;
+	if (verbose) pr_info("usb_net_raw_ip_rx_urb_comp { urb %p\n", urb);
+
+	/* check input */
+	if (!urb) {
+		pr_err("no urb\n");
+		return;
+	}
+
+	usb = (struct baseband_usb *) urb->context;
 	int i = usb->baseband_index;
 
 	//+Sophia:0112
@@ -865,13 +874,6 @@ static void usb_net_raw_ip_rx_urb_comp(struct urb *urb)
 		NET_IP_ETHERTYPE,
 	};
 
-	if (verbose) pr_info("usb_net_raw_ip_rx_urb_comp { urb %p\n", urb);
-
-	/* check input */
-	if (!urb) {
-		pr_err("no urb\n");
-		return;
-	}
 	/* 77969-8 patch */
 	switch (urb->status) {
 	case 0:
@@ -947,6 +949,10 @@ static void usb_net_raw_ip_rx_urb_comp(struct urb *urb)
 	/* mark rx urb complete */
 	usb->usb.rx_urb = (struct urb *) 0;
 
+	/* do not submit urb if interface is suspending */
+	if (urb->status == -ENOENT)
+		return;
+
 	/* submit next rx urb */
 	usb_net_raw_ip_rx_urb_submit(usb);
 /* 77969-7 patch */
@@ -1182,7 +1188,7 @@ static void usb_net_raw_ip_tx_urb_work(struct work_struct *work)
 
 static void usb_net_raw_ip_tx_urb_comp(struct urb *urb)
 {
-	struct baseband_usb *usb = (struct baseband_usb *) urb->context;
+	struct baseband_usb *usb;
 
 	if (verbose) pr_debug("usb_net_raw_ip_tx_urb_comp {\n");
 	/* 77969-7 patch */
@@ -1191,6 +1197,9 @@ static void usb_net_raw_ip_tx_urb_comp(struct urb *urb)
 		pr_err("no urb\n");
 		return;
 	}
+
+	usb = (struct baseband_usb *) urb->context;
+
 	/* 77969-8 patch */
 	switch (urb->status) {
 	case 0:
diff --git a/drivers/power/tps65200.c b/drivers/power/tps65200.c
index 866c701..637c59f 100644
--- a/drivers/power/tps65200.c
+++ b/drivers/power/tps65200.c
@@ -311,7 +311,8 @@ static int tps65200_dump_register(void)
 	pr_tps_info("regh 0x06=%x, 0x08=%x, regh 0x09=%x, regh 0x0A=%x\n",
 			regh0, regh1, regh2, regh3);
 #else
-	pr_tps_info("regh 0x06=%x\n", regh0);
+	tps65200_i2c_read_byte(&regh3, 0x0A);
+	pr_tps_info("regh 0x06=%x, regh 0x0A=%x\n", regh0, regh3);
 #endif
 
 	return 0;
diff --git a/drivers/regulator/tps80031-regulator.c b/drivers/regulator/tps80031-regulator.c
index e34b724..6da7e23 100644
--- a/drivers/regulator/tps80031-regulator.c
+++ b/drivers/regulator/tps80031-regulator.c
@@ -641,6 +641,7 @@ static int tps80031_vbus_enable(struct regulator_dev *rdev)
 	struct tps80031_regulator *ri = rdev_get_drvdata(rdev);
 	struct device *parent = to_tps80031_dev(rdev);
 	int ret;
+
 	if (ri->platform_flags & VBUS_SW_ONLY) {
 		WARN_ON(1);
 		return 0;
@@ -666,6 +667,7 @@ static int tps80031_vbus_disable(struct regulator_dev *rdev)
 	struct tps80031_regulator *ri = rdev_get_drvdata(rdev);
 	struct device *parent = to_tps80031_dev(rdev);
 	int ret = 0;
+
 	if (ri->platform_flags & VBUS_SW_ONLY) {
 		WARN_ON(1);
 		if (ri->platform_flags & VBUS_DISCHRG_EN_PDN)
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 459349b..58131cd 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -126,6 +126,12 @@ config RTC_INTF_ALARM_DEV
 	help
 	  Exports the alarm interface to user-space.
 
+config ANDROID_RTC_CHANGE_WAIT
+	bool "Android rtc wait event"
+	depends on RTC_INTF_ALARM_DEV
+	default n
+	help
+	  Exports the alarm interface to wait set rtc.
 
 config RTC_DRV_TEST
 	tristate "Test driver/device"
diff --git a/drivers/rtc/alarm-dev.c b/drivers/rtc/alarm-dev.c
index 686e6f7..072b86d 100644
--- a/drivers/rtc/alarm-dev.c
+++ b/drivers/rtc/alarm-dev.c
@@ -51,6 +51,10 @@ static int alarm_opened;
 static DEFINE_SPINLOCK(alarm_slock);
 static struct wake_lock alarm_wake_lock;
 static DECLARE_WAIT_QUEUE_HEAD(alarm_wait_queue);
+#ifdef CONFIG_ANDROID_RTC_CHANGE_WAIT
+static DECLARE_WAIT_QUEUE_HEAD(rtc_change_wait_queue);
+static uint32_t rtc_changed = 0;
+#endif
 static uint32_t alarm_pending;
 static uint32_t alarm_enabled;
 static uint32_t wait_pending;
@@ -70,7 +74,12 @@ static long alarm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	if (alarm_type >= ANDROID_ALARM_TYPE_COUNT)
 		return -EINVAL;
 
+#ifdef CONFIG_ANDROID_RTC_CHANGE_WAIT
+	if( ANDROID_ALARM_BASE_CMD(cmd)!=ANDROID_ALARM_GET_TIME(0) &&
+		ANDROID_ALARM_BASE_CMD(cmd)!=ANDROID_RTC_CHANGE_WAIT ){
+#else
 	if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_GET_TIME(0)) {
+#endif
 		if ((file->f_flags & O_ACCMODE) == O_RDONLY)
 			return -EPERM;
 		if (file->private_data == NULL &&
@@ -146,6 +155,16 @@ from_old_alarm_set:
 		alarm_pending = 0;
 		spin_unlock_irqrestore(&alarm_slock, flags);
 		break;
+#ifdef CONFIG_ANDROID_RTC_CHANGE_WAIT
+	case ANDROID_RTC_CHANGE_WAIT:
+		rv = wait_event_interruptible(rtc_change_wait_queue, rtc_changed);
+		spin_lock_irqsave(&alarm_slock, flags);
+		rtc_changed = 0;
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (rv)
+			goto err1;
+		break;
+#endif
 	case ANDROID_ALARM_SET_RTC:
 		if (copy_from_user(&new_rtc_time, (void __user *)arg,
 		    sizeof(new_rtc_time))) {
@@ -156,6 +175,10 @@ from_old_alarm_set:
 		spin_lock_irqsave(&alarm_slock, flags);
 		alarm_pending |= ANDROID_ALARM_TIME_CHANGE_MASK;
 		wake_up(&alarm_wait_queue);
+#ifdef CONFIG_ANDROID_RTC_CHANGE_WAIT
+		rtc_changed = 1;
+		wake_up(&rtc_change_wait_queue);
+#endif
 		spin_unlock_irqrestore(&alarm_slock, flags);
 		if (rv < 0)
 			goto err1;
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
index 74a4d62..411889a 100644
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -33,7 +33,7 @@
 #define ANDROID_ALARM_PRINT_FLOW (1U << 6)
 
 static int debug_mask = ANDROID_ALARM_PRINT_ERROR | \
-			ANDROID_ALARM_PRINT_INIT_STATUS | ANDROID_ALARM_PRINT_SUSPEND;
+			ANDROID_ALARM_PRINT_INIT_STATUS;
 module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
 #define OFFALARM_SIZE	(10)
 
diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index ef1aba5..ef6316a 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -357,11 +357,11 @@ int rtc_set_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
 
 	err = rtc_valid_tm(&alarm->time);
 	if (err != 0)
-		goto error;
+		return err;
 
 	err = mutex_lock_interruptible(&rtc->ops_lock);
 	if (err)
-		goto error;
+		return err;
 	if (rtc->aie_timer.enabled) {
 		rtc_timer_remove(rtc, &rtc->aie_timer);
 	}
@@ -371,10 +371,6 @@ int rtc_set_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
 		err = rtc_timer_enqueue(rtc, &rtc->aie_timer);
 	}
 	mutex_unlock(&rtc->ops_lock);
-
-error:
-	if (err)
-		pr_info("set invalid alarm\n");
 	return err;
 }
 EXPORT_SYMBOL_GPL(rtc_set_alarm);
diff --git a/drivers/rtc/rtc-tps6591x.c b/drivers/rtc/rtc-tps6591x.c
index 878c204..102c8a2 100644
--- a/drivers/rtc/rtc-tps6591x.c
+++ b/drivers/rtc/rtc-tps6591x.c
@@ -161,8 +161,8 @@ static int tps6591x_rtc_read_time(struct device *dev, struct rtc_time *tm)
 	tm->tm_min = buff[1];
 	tm->tm_hour = buff[2];
 	tm->tm_mday = buff[3];
-	tm->tm_mon = buff[4];
-	tm->tm_year = buff[5];
+	tm->tm_mon = buff[4] - 1;
+	tm->tm_year = buff[5] + RTC_YEAR_OFFSET;
 	tm->tm_wday = buff[6];
 	print_time(dev, tm);
 	return tps6591x_rtc_valid_tm(tm);
@@ -249,8 +249,8 @@ static int tps6591x_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	buff[1] = tm->tm_min;
 	buff[2] = tm->tm_hour;
 	buff[3] = tm->tm_mday;
-	buff[4] = tm->tm_mon;
-	buff[5] = tm->tm_year;
+	buff[4] = tm->tm_mon + 1;
+	buff[5] = tm->tm_year % RTC_YEAR_OFFSET;
 	buff[6] = tm->tm_wday;
 
 	print_time(dev, tm);
@@ -308,8 +308,8 @@ static int tps6591x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 	buff[1] = alrm->time.tm_min;
 	buff[2] = alrm->time.tm_hour;
 	buff[3] = alrm->time.tm_mday;
-	buff[4] = alrm->time.tm_mon;
-	buff[5] = alrm->time.tm_year;
+	buff[4] = alrm->time.tm_mon + 1;
+	buff[5] = alrm->time.tm_year % RTC_YEAR_OFFSET;
 	convert_decimal_to_bcd(buff, sizeof(buff));
 	err = tps6591x_write_regs(dev, RTC_ALARM, sizeof(buff), buff);
 	if (err)
@@ -332,8 +332,8 @@ static int tps6591x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 	alrm->time.tm_min = buff[1];
 	alrm->time.tm_hour = buff[2];
 	alrm->time.tm_mday = buff[3];
-	alrm->time.tm_mon = buff[4];
-	alrm->time.tm_year = buff[5];
+	alrm->time.tm_mon = buff[4] - 1;
+	alrm->time.tm_year = buff[5] + RTC_YEAR_OFFSET;
 
 	dev_info(dev->parent, "\n getting alarm time::\n");
 	print_time(dev, &alrm->time);
@@ -468,7 +468,7 @@ static int __devinit tps6591x_rtc_probe(struct platform_device *pdev)
 			pdata->time.tm_year = RTC_YEAR_OFFSET;
 			pdata->time.tm_mday = 1;
 		} else
-		pdata->time.tm_year -= OS_REF_YEAR;
+			pdata->time.tm_year -= OS_REF_YEAR;
 		tps6591x_rtc_set_time(&pdev->dev, &pdata->time);
 	}
 
diff --git a/drivers/spi/spi_tegra.c b/drivers/spi/spi_tegra.c
index f6b6d2a..520aa9b 100644
--- a/drivers/spi/spi_tegra.c
+++ b/drivers/spi/spi_tegra.c
@@ -42,6 +42,18 @@
 #include <mach/dma.h>
 #include <mach/clk.h>
 
+#ifdef CONFIG_SERIAL_SC8800G
+#define DEBUG_SPI_MASTER_OOPS
+#define DEBUG_949393
+#define DEBUG_960388
+#define WORKAROUND_949393
+#define SOLUTION_959947
+#define DEBUG_962049
+#define WORKAROUND_962049
+#define SOLUTION_967438
+//#define WORKAROUND_949393_PRINT_LOG
+#endif
+
 #define SLINK_COMMAND		0x000
 #define   SLINK_BIT_LENGTH(x)		(((x) & 0x1f) << 0)
 #define   SLINK_WORD_SIZE(x)		(((x) & 0x1f) << 5)
@@ -178,6 +190,9 @@ struct spi_tegra_data {
 	char			port_name[32];
 
 	struct clk		*clk;
+#ifdef CONFIG_SERIAL_SC8800G
+	struct clk		*sclk;
+#endif
 	void __iomem		*base;
 	phys_addr_t		phys;
 	unsigned		irq;
@@ -246,6 +261,71 @@ struct spi_tegra_data {
 	struct work_struct spi_transfer_work;
 };
 
+#ifdef DEBUG_962049
+static int g_enable_debug_962049 = 0;
+static int g_spi_tegra_transfer_debug_flag = 0;
+static int g_tegra_spi_transfer_work_debug_flag = 0;
+static int g_spi_tegra_curr_transfer_complete_debug_flag = 0;
+static int g_spi_tegra_start_dma_based_transfer_debug_flag = 0;
+static int g_spi_tegra_start_cpu_based_transfer_debug_flag = 0;
+void spi_tegra_962049_debug_set(int enable)
+{
+	if ( g_enable_debug_962049 != enable ) {
+		g_enable_debug_962049 = enable;
+	}
+}
+void spi_tegra_962049_debug_get_info()
+{
+	pr_err("[%s] g_enable_debug_962049=[%d][%d][%d][%d][%d][%d]\n", __func__,
+		g_enable_debug_962049, g_spi_tegra_transfer_debug_flag,
+		g_tegra_spi_transfer_work_debug_flag, g_spi_tegra_curr_transfer_complete_debug_flag,
+		g_spi_tegra_start_dma_based_transfer_debug_flag, g_spi_tegra_start_cpu_based_transfer_debug_flag);
+}
+#else
+void spi_tegra_962049_debug_set(int enable){}
+void spi_tegra_962049_debug_get_info(){}
+#endif
+
+#ifdef DEBUG_960388
+static struct spi_master *tegra_masters[6] = {0};
+static struct device *tegra_master_devices[6] = {0};
+static struct device_private *tegra_master_device_privates[6] = {0};
+static inline void *spi_master_get_devdata_debug(struct spi_master *master)
+{
+	int i = 0;
+	if (master == NULL ) {
+		spi_tegra_962049_debug_get_info();
+		BUG_ON(1);
+	}
+
+	while (i < 6) {
+		if (master != tegra_masters[i]) {
+			i++; /* check next */
+			continue;
+		}
+		if (unlikely(&master->dev != tegra_master_devices[i])) {
+			pr_err("[%s] &master->dev=%p corrupted\n", __func__, &master->dev);
+			pr_err("[%s] it was %p in store\n", __func__, tegra_master_devices[i]);
+			BUG();
+		}
+		if (unlikely(master->dev.p != tegra_master_device_privates[i])) {
+			pr_err("[%s] master->dev.p=%p corrupted\n", __func__, master->dev.p);
+			pr_err("[%s] it was %p in store\n", __func__, tegra_master_devices[i]);
+			BUG();
+		}
+		return spi_master_get_devdata(master);
+	}
+	pr_err("[%s] master %p doesn't match any in store\n", __func__, master);
+	for (i = 0; i < 6; i++) {
+		pr_err("[%s] tegra_masters[%d]=%p\n", __func__, i, tegra_masters[i]);
+	}
+	BUG();
+	return NULL; /* fake for compiler warning */
+}
+#else
+#define spi_master_get_devdata_debug spi_master_get_devdata
+#endif
+
 static inline unsigned long spi_tegra_readl(struct spi_tegra_data *tspi,
 		    unsigned long reg)
 {
@@ -262,6 +342,21 @@ static inline void spi_tegra_writel(struct spi_tegra_data *tspi,
 	writel(val, tspi->base + reg);
 }
 
+#if defined (DEBUG_949393)
+static inline void print_registers(struct spi_tegra_data *tspi)
+{
+	unsigned addr = 0;
+	unsigned long data[0x20/4];
+	char line[256] = {0};
+	while (addr < 0x20) {
+		data[addr/4] = spi_tegra_readl(tspi, addr);
+		sprintf(line, "%s0x%08X ", line, data[addr/4]);
+		addr += 4;
+	}
+	pr_err("[%s] %s\n", __func__, line);
+}
+#endif
+
 static void spi_tegra_clear_status(struct spi_tegra_data *tspi)
 {
 	unsigned long val;
@@ -354,6 +449,12 @@ static unsigned spi_tegra_fill_tx_fifo_from_client_txbuf(
 	unsigned long x;
 	unsigned int written_words;
 
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0 ) {
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s+\n",  __func__);
+	}
+#endif
+
 	fifo_status = spi_tegra_readl(tspi, SLINK_STATUS2);
 	tx_empty_count = SLINK_TX_FIFO_EMPTY_COUNT(fifo_status);
 
@@ -381,6 +482,11 @@ static unsigned spi_tegra_fill_tx_fifo_from_client_txbuf(
 		written_words = max_n_32bit;
 	}
 	tspi->cur_tx_pos += written_words * tspi->bytes_per_word;
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0 ) {
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s-\n",  __func__);
+	}
+#endif
 	return written_words;
 }
 
@@ -394,9 +500,50 @@ static unsigned int spi_tegra_read_rx_fifo_to_client_rxbuf(
 	unsigned long x;
 	unsigned int read_words = 0;
 	unsigned len;
+#if defined (DEBUG_949393)
+	unsigned long dma_ctl;
+	unsigned dma_block_size;
+#if defined (WORKAROUND_949393)
+	unsigned long rx_fifo;
+#endif
+
+	dma_ctl = spi_tegra_readl(tspi, SLINK_DMA_CTL);
+	dma_block_size = SLINK_DMA_BLOCK_SIZE(dma_ctl);
+#endif
 
 	fifo_status = spi_tegra_readl(tspi, SLINK_STATUS2);
 	rx_full_count = SLINK_RX_FIFO_FULL_COUNT(fifo_status);
+
+#if defined (DEBUG_949393)
+	if (tspi->pdev->id == 0 && rx_full_count != (dma_block_size + 1)) {
+		dev_err(&tspi->pdev->dev,
+			"rx_full_count %d, dma_ctl 0x%08X, fifo_status 0x%08X\n",
+			rx_full_count, dma_ctl, fifo_status);
+#ifdef WORKAROUND_949393_PRINT_LOG
+		print_registers(tspi);
+#endif
+#if defined (WORKAROUND_949393)
+		if (tspi->is_packed) {
+			//BUG_ON(1); /* no workaround for packed mode so far */
+		} else {
+			for (i = 0; i < (rx_full_count - (dma_block_size +1)); i++) {
+				/* pop unexpected rx_fifo */
+				rx_fifo = spi_tegra_readl(tspi, SLINK_RX_FIFO);
+				dev_err(&tspi->pdev->dev,
+					"rx_fifo[%i(%d, %d)] 0x%08X\n",
+					i, rx_full_count, dma_block_size, rx_fifo);
+				if ( i > 512 ) {
+					break;
+				}
+			}
+			rx_full_count = (dma_block_size + 1);
+		//	WARN_ON(1);
+		}
+#else
+		//BUG_ON(1);
+#endif
+	}
+#endif
 	dev_dbg(&tspi->pdev->dev, "Rx fifo count %d\n", rx_full_count);
 	if (tspi->is_packed) {
 		len = tspi->curr_dma_words * tspi->bytes_per_word;
@@ -429,6 +576,15 @@ static void spi_tegra_copy_client_txbuf_to_spi_txbuf(
 		struct spi_tegra_data *tspi, struct spi_transfer *t)
 {
 	unsigned len;
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0) {
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s+\n",  __func__);
+	}
+#endif
+#ifdef SOLUTION_959947
+	dma_sync_single_for_cpu(&tspi->pdev->dev, tspi->tx_dma_req.source_addr,
+		tspi->dma_buf_size, DMA_TO_DEVICE);
+#endif
 	if (tspi->is_packed) {
 		len = tspi->curr_dma_words * tspi->bytes_per_word;
 		memcpy(tspi->tx_buf, t->tx_buf + tspi->cur_pos, len);
@@ -448,13 +604,25 @@ static void spi_tegra_copy_client_txbuf_to_spi_txbuf(
 		}
 	}
 	tspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
+#ifdef SOLUTION_959947
+	dma_sync_single_for_device(&tspi->pdev->dev, tspi->tx_dma_req.source_addr,
+		tspi->dma_buf_size, DMA_TO_DEVICE);
+#endif
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0) {
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s-\n",  __func__);
+	}
+#endif
 }
 
 static void spi_tegra_copy_spi_rxbuf_to_client_rxbuf(
 		struct spi_tegra_data *tspi, struct spi_transfer *t)
 {
 	unsigned len;
-
+#ifdef SOLUTION_959947
+	dma_sync_single_for_cpu(&tspi->pdev->dev, tspi->rx_dma_req.dest_addr,
+		tspi->dma_buf_size, DMA_FROM_DEVICE);
+#endif
 	if (tspi->is_packed) {
 		len = tspi->curr_dma_words * tspi->bytes_per_word;
 		memcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_buf, len);
@@ -477,8 +645,26 @@ static void spi_tegra_copy_spi_rxbuf_to_client_rxbuf(
 		}
 	}
 	tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
+#ifdef SOLUTION_959947
+	dma_sync_single_for_device(&tspi->pdev->dev, tspi->rx_dma_req.dest_addr,
+		tspi->dma_buf_size, DMA_FROM_DEVICE);
+#endif
 }
 
+#ifdef SOLUTION_959947
+static void spi_tegra_init_rx_buf(struct spi_tegra_data *tspi)
+{
+	int i;
+	unsigned char *data = (unsigned char *)tspi->rx_buf;
+	dma_sync_single_for_cpu(&tspi->pdev->dev, tspi->rx_dma_req.dest_addr,
+		tspi->dma_buf_size, DMA_TO_DEVICE);
+	for (i = 0; i < tspi->dma_buf_size; i++)
+		data[i] = 0x5a;
+	dma_sync_single_for_device(&tspi->pdev->dev, tspi->rx_dma_req.dest_addr,
+		tspi->dma_buf_size, DMA_TO_DEVICE);
+ }
+#endif
+
 static int spi_tegra_start_dma_based_transfer(
 		struct spi_tegra_data *tspi, struct spi_transfer *t)
 {
@@ -487,6 +673,27 @@ static int spi_tegra_start_dma_based_transfer(
 	unsigned int len;
 	int ret = 0;
 
+#ifdef WORKAROUND_962049
+	u64 usec_start = 0;
+	u32 usec_total = 0;
+	int spi_tegra_readl_count = 0;
+	static int spi_962049_resend_count = 0;
+#endif
+
+#if defined (DEBUG_949393)
+#ifdef WORKAROUND_949393_PRINT_LOG
+	unsigned long status2;
+	unsigned long rx_fifo_full_count;
+	unsigned long tx_fifo_empty_count;
+
+	status2 = spi_tegra_readl(tspi, SLINK_STATUS2);
+	rx_fifo_full_count = SLINK_RX_FIFO_FULL_COUNT(status2);
+	tx_fifo_empty_count = SLINK_TX_FIFO_EMPTY_COUNT(status2);
+#endif
+#endif
+#ifdef DEBUG_962049
+	g_spi_tegra_start_dma_based_transfer_debug_flag = 1;
+#endif
 	INIT_COMPLETION(tspi->rx_dma_complete);
 	INIT_COMPLETION(tspi->tx_dma_complete);
 
@@ -511,29 +718,105 @@ static int spi_tegra_start_dma_based_transfer(
 	if (tspi->cur_direction & DATA_DIR_RX)
 		val |= SLINK_IE_RXC;
 
+#ifdef DEBUG_962049
+	g_spi_tegra_start_dma_based_transfer_debug_flag = 2;
+#endif
+
 	spi_tegra_writel(tspi, val, SLINK_DMA_CTL);
 	tspi->dma_control_reg = val;
 
+#ifdef DEBUG_962049
+	g_spi_tegra_start_dma_based_transfer_debug_flag = 3;
+#endif
+
 	if (tspi->cur_direction & DATA_DIR_TX) {
 		spi_tegra_copy_client_txbuf_to_spi_txbuf(tspi, t);
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 4;
+#endif
 		wmb();
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 5;
+#endif
 		tspi->tx_dma_req.size = len;
 		ret = tegra_dma_enqueue_req(tspi->tx_dma, &tspi->tx_dma_req);
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 6;
+#endif
 		if (ret < 0) {
 			dev_err(&tspi->pdev->dev, "Error in starting tx dma "
 						" error = %d\n", ret);
 			return ret;
 		}
 
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 7;
+#endif
+
 		/* Wait for tx fifo to be fill before starting slink */
 		test_val = spi_tegra_readl(tspi, SLINK_STATUS);
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 8;
+#endif
+#ifdef WORKAROUND_962049
+		usec_start = cpu_clock(UINT_MAX);
+		while (!(test_val & SLINK_TX_FULL)) {
+			test_val = spi_tegra_readl(tspi, SLINK_STATUS);
+
+			usec_total = ((u32)(cpu_clock(UINT_MAX) - usec_start) / 1000);
+
+			if ( spi_tegra_readl_count > 1000 && usec_total > (500 * 1000) ) {
+				/*over 500ms, trigger workaround*/
+				pr_err("[%s] SLINK_TX_FULL debug message=[%d][%d][%d][%d]\n", __func__, usec_total, spi_tegra_readl_count, tspi->master->bus_num, tspi->status_reg);
+				print_registers(tspi);
+
+				tegra_dma_dequeue_req(tspi->tx_dma, &tspi->tx_dma_req);
+
+				tegra_periph_reset_assert(tspi->clk);
+				udelay(2);
+				tegra_periph_reset_deassert(tspi->clk);
+				WARN_ON(1);
+
+				if ( spi_962049_resend_count > 10 ) {
+					pr_err("[%s] SLINK_TX_FULL debug EIO=[%d]\n", __func__, spi_962049_resend_count);
+					return -EIO;
+				} else {
+					pr_err("[%s] SLINK_TX_FULL debug return EIO(%d)\n", __func__, spi_962049_resend_count);
+#if 0/*enable resend*/
+					spi_962049_resend_count++;
+					/*enable resend*/
+					return -EAGAIN;
+#else
+					return -EIO;
+#endif
+				}
+			}
+			spi_tegra_readl_count++;
+
+		}
+		spi_962049_resend_count = 0;
+#else
 		while (!(test_val & SLINK_TX_FULL))
 			test_val = spi_tegra_readl(tspi, SLINK_STATUS);
+#endif
+
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 9;
+#endif
 	}
 
 	if (tspi->cur_direction & DATA_DIR_RX) {
+#ifdef SOLUTION_959947
+		spi_tegra_init_rx_buf(tspi);
+#endif
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 10;
+#endif
 		tspi->rx_dma_req.size = len;
 		ret = tegra_dma_enqueue_req(tspi->rx_dma, &tspi->rx_dma_req);
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 11;
+#endif
 		if (ret < 0) {
 			dev_err(&tspi->pdev->dev, "Error in starting rx dma "
 						" error = %d\n", ret);
@@ -543,16 +826,44 @@ static int spi_tegra_start_dma_based_transfer(
 			return ret;
 		}
 	}
+#ifdef DEBUG_962049
+	g_spi_tegra_start_dma_based_transfer_debug_flag = 12;
+#endif
 	tspi->is_curr_dma_xfer = true;
 	if (tspi->is_packed) {
 		val |= SLINK_PACKED;
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 13;
+#endif
 		spi_tegra_writel(tspi, val, SLINK_DMA_CTL);
 		udelay(1);
+#ifdef DEBUG_962049
+		g_spi_tegra_start_dma_based_transfer_debug_flag = 14;
+#endif
 		wmb();
 	}
+#ifdef DEBUG_962049
+	g_spi_tegra_start_dma_based_transfer_debug_flag = 15;
+#endif
 
 	val |= SLINK_DMA_EN;
+#if defined (DEBUG_949393)
+#ifdef WORKAROUND_949393_PRINT_LOG
+	if ( tspi->pdev->id == 0
+		&& ((rx_fifo_full_count != 0) || (tx_fifo_empty_count != 0x20))) {
+		dev_err(&tspi->pdev->dev, "[%s] before setting DMA_EN val=0x%08X\n",
+			__func__, val);
+		print_registers(tspi);
+	}
+#endif
+#endif
+#ifdef DEBUG_962049
+	g_spi_tegra_start_dma_based_transfer_debug_flag = 16;
+#endif
 	spi_tegra_writel(tspi, val, SLINK_DMA_CTL);
+#ifdef DEBUG_962049
+	g_spi_tegra_start_dma_based_transfer_debug_flag = 17;
+#endif
 	return ret;
 }
 
@@ -561,7 +872,20 @@ static int spi_tegra_start_cpu_based_transfer(
 {
 	unsigned long val;
 	unsigned curr_words;
+#if defined (DEBUG_949393)
+#ifdef WORKAROUND_949393_PRINT_LOG
+	unsigned long status2;
+	unsigned long rx_fifo_full_count;
+	unsigned long tx_fifo_empty_count;
 
+	status2 = spi_tegra_readl(tspi, SLINK_STATUS2);
+	rx_fifo_full_count = SLINK_RX_FIFO_FULL_COUNT(status2);
+	tx_fifo_empty_count = SLINK_TX_FIFO_EMPTY_COUNT(status2);
+#endif
+#endif
+#ifdef DEBUG_962049
+	g_spi_tegra_start_cpu_based_transfer_debug_flag = 1;
+#endif
 	val = tspi->packed_size;
 	if (tspi->cur_direction & DATA_DIR_TX)
 		val |= SLINK_IE_TXC;
@@ -571,24 +895,65 @@ static int spi_tegra_start_cpu_based_transfer(
 
 	spi_tegra_writel(tspi, val, SLINK_DMA_CTL);
 	tspi->dma_control_reg = val;
+#ifdef DEBUG_962049
+	g_spi_tegra_start_cpu_based_transfer_debug_flag = 2;
+#endif
 
-	if (tspi->cur_direction & DATA_DIR_TX)
+	if (tspi->cur_direction & DATA_DIR_TX) {
+#ifdef DEBUG_962049
+		g_spi_tegra_start_cpu_based_transfer_debug_flag = 3;
+#endif
 		curr_words = spi_tegra_fill_tx_fifo_from_client_txbuf(tspi, t);
-	else
+#ifdef DEBUG_962049
+		g_spi_tegra_start_cpu_based_transfer_debug_flag = 4;
+#endif
+	} else {
 		curr_words = tspi->curr_dma_words;
+	}
+#ifdef DEBUG_962049
+	g_spi_tegra_start_cpu_based_transfer_debug_flag = 5;
+#endif
 	val |= SLINK_DMA_BLOCK_SIZE(curr_words - 1);
 	spi_tegra_writel(tspi, val, SLINK_DMA_CTL);
 	tspi->dma_control_reg = val;
+#ifdef DEBUG_962049
+	g_spi_tegra_start_cpu_based_transfer_debug_flag = 6;
+#endif
 
 	tspi->is_curr_dma_xfer = false;
 	if (tspi->is_packed) {
 		val |= SLINK_PACKED;
+#ifdef DEBUG_962049
+		g_spi_tegra_start_cpu_based_transfer_debug_flag = 7;
+#endif
 		spi_tegra_writel(tspi, val, SLINK_DMA_CTL);
 		udelay(1);
+#ifdef DEBUG_962049
+		g_spi_tegra_start_cpu_based_transfer_debug_flag = 8;
+#endif
 		wmb();
 	}
+#ifdef DEBUG_962049
+	g_spi_tegra_start_cpu_based_transfer_debug_flag = 9;
+#endif
 	val |= SLINK_DMA_EN;
+#if defined (DEBUG_949393)
+#ifdef WORKAROUND_949393_PRINT_LOG
+	if ( tspi->pdev->id == 0
+		&& ((rx_fifo_full_count != 0) || (tx_fifo_empty_count != 0x20))) {
+		dev_err(&tspi->pdev->dev, "[%s] before setting DMA_EN val=0x%08X\n",
+			__func__, val);
+		print_registers(tspi);
+	}
+#endif
+#endif
+#ifdef DEBUG_962049
+	g_spi_tegra_start_cpu_based_transfer_debug_flag = 10;
+#endif
 	spi_tegra_writel(tspi, val, SLINK_DMA_CTL);
+#ifdef DEBUG_962049
+	g_spi_tegra_start_cpu_based_transfer_debug_flag = 11;
+#endif
 	return 0;
 }
 
@@ -650,16 +1015,28 @@ static void set_best_clk_source(struct spi_tegra_data *tspi,
 	}
 }
 
+#ifdef WORKAROUND_962049
+static void spi_tegra_curr_transfer_complete(struct spi_tegra_data *tspi, unsigned err, unsigned cur_xfer_size, unsigned long *irq_flags);
+#endif
+
 static void spi_tegra_start_transfer(struct spi_device *spi,
 		    struct spi_transfer *t, bool is_first_of_msg,
 		    bool is_single_xfer)
 {
+#ifdef DEBUG_SPI_MASTER_OOPS
+	struct spi_tegra_data *tspi = NULL;
+#else
 	struct spi_tegra_data *tspi = spi_master_get_devdata(spi->master);
+#endif
 	u32 speed;
 	u8 bits_per_word;
 	unsigned total_fifo_words;
 	int ret;
+#ifdef DEBUG_SPI_MASTER_OOPS
+	struct tegra_spi_device_controller_data *cdata = NULL;
+#else
 	struct tegra_spi_device_controller_data *cdata = spi->controller_data;
+#endif
 	unsigned long command;
 	unsigned long command2;
 #ifndef CONFIG_ARCH_TEGRA_2x_SOC
@@ -675,6 +1052,29 @@ static void spi_tegra_start_transfer(struct spi_device *spi,
 			SLINK_CS_POLARITY3,
 	};
 
+#ifdef DEBUG_SPI_MASTER_OOPS
+	/* For SPI master Oops debug */
+	if ( spi == NULL ) {
+		printk("[SPI_TEGRA] spi == NULL\n");
+		BUG_ON(1);
+	}
+
+	if ( spi->master == NULL ) {
+		dev_info(&spi->dev, "[SPI_TEGRA] spi->master == NULL, [0x%x][0x%x][0x%x]\n", spi, spi->master, spi->dev);
+		dev_info(&spi->dev, "[SPI_TEGRA] [%s],[%d],[%d]\n", spi->modalias, spi->max_speed_hz, spi->chip_select);
+#ifndef DEBUG_960388
+		BUG_ON(1);
+#endif
+	}
+
+#ifdef DEBUG_960388
+	tspi = spi_master_get_devdata_debug(spi->master);
+#else
+	tspi = spi_master_get_devdata(spi->master);
+#endif
+	cdata = spi->controller_data;
+#endif
+
 	bits_per_word = t->bits_per_word ? t->bits_per_word :
 					spi->bits_per_word;
 
@@ -771,8 +1171,22 @@ static void spi_tegra_start_transfer(struct spi_device *spi,
 	spi_tegra_writel(tspi, command2, SLINK_COMMAND2);
 	tspi->command2_reg = command2;
 
+#ifdef WORKAROUND_962049
+	if (total_fifo_words > SPI_FIFO_DEPTH) {
+		ret = spi_tegra_start_dma_based_transfer(tspi, t);
+
+		 if ( ret == -EIO ) {
+			unsigned long flags;
+			pr_err("[%s] SLINK_TX_FULL debug ret=[%d]\n", __func__, ret);
+			spin_lock_irqsave(&tspi->lock, flags);
+			spi_tegra_curr_transfer_complete(tspi, true, t->len, &flags);
+			spin_unlock_irqrestore(&tspi->lock, flags);
+		}
+	}
+#else
 	if (total_fifo_words > SPI_FIFO_DEPTH)
 		ret = spi_tegra_start_dma_based_transfer(tspi, t);
+#endif
 	else
 		ret = spi_tegra_start_cpu_based_transfer(tspi, t);
 	WARN_ON(ret < 0);
@@ -780,7 +1194,11 @@ static void spi_tegra_start_transfer(struct spi_device *spi,
 
 static int spi_tegra_setup(struct spi_device *spi)
 {
+#ifdef DEBUG_960388
+	struct spi_tegra_data *tspi = spi_master_get_devdata_debug(spi->master);
+#else
 	struct spi_tegra_data *tspi = spi_master_get_devdata(spi->master);
+#endif
 	unsigned long cs_bit;
 	unsigned long val;
 	unsigned long flags;
@@ -848,40 +1266,87 @@ static void tegra_spi_transfer_work(struct work_struct *work)
 
 	tspi = container_of(work, struct spi_tegra_data, spi_transfer_work);
 
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s+\n",  __func__);
+
+	g_tegra_spi_transfer_work_debug_flag = 1;
+#endif
+
 	spin_lock_irqsave(&tspi->lock, flags);
+#ifdef DEBUG_962049
+	g_tegra_spi_transfer_work_debug_flag = 2;
+#endif
 
 	if (tspi->is_transfer_in_progress || tspi->is_suspended) {
 		spin_unlock_irqrestore(&tspi->lock, flags);
+#ifdef DEBUG_962049
+		if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+			dev_info(&tspi->pdev->dev, "[debug_962049]%s-, tspi->is_transfer_in_progress=[%d],tspi->is_suspended=[%d]\n",  __func__, tspi->is_transfer_in_progress, tspi->is_suspended);
+		g_tegra_spi_transfer_work_debug_flag = 3;
+#endif
 		return;
 	}
 	if (list_empty(&tspi->queue)) {
+#ifdef DEBUG_962049
+		if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+			dev_info(&tspi->pdev->dev, "[debug_962049]%s-, list_empty\n",  __func__);
+		g_tegra_spi_transfer_work_debug_flag = 4;
+#endif
 		spin_unlock_irqrestore(&tspi->lock, flags);
 		return;
 	}
 
 	m = list_first_entry(&tspi->queue, struct spi_message, queue);
+#ifdef DEBUG_962049
+	g_tegra_spi_transfer_work_debug_flag = 5;
+#endif
 	spi = m->state;
 	single_xfer = list_is_singular(&m->transfers);
 	m->actual_length = 0;
 	m->status = 0;
 	t = list_first_entry(&m->transfers, struct spi_transfer, transfer_list);
 	tspi->is_transfer_in_progress = true;
-
+#ifdef DEBUG_962049
+	g_tegra_spi_transfer_work_debug_flag = 6;
+#endif
 	spin_unlock_irqrestore(&tspi->lock, flags);
+#ifdef DEBUG_962049
+	g_tegra_spi_transfer_work_debug_flag = 7;
+#endif
 	spi_tegra_start_transfer(spi, t, true, single_xfer);
+#ifdef DEBUG_962049
+	g_tegra_spi_transfer_work_debug_flag = 8;
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s-\n",  __func__);
+#endif
 }
 
 static int spi_tegra_transfer(struct spi_device *spi, struct spi_message *m)
 {
+#ifdef DEBUG_960388
+	struct spi_tegra_data *tspi = spi_master_get_devdata_debug(spi->master);
+#else
 	struct spi_tegra_data *tspi = spi_master_get_devdata(spi->master);
+#endif
 	struct spi_transfer *t;
 	unsigned long flags;
 	int was_empty;
 	int bytes_per_word;
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s+\n",  __func__);
+
+	g_spi_tegra_transfer_debug_flag = 1;
+#endif
 
 	if (list_empty(&m->transfers) || !m->complete)
 		return -EINVAL;
 
+#ifdef DEBUG_962049
+	g_spi_tegra_transfer_debug_flag = 2;
+#endif
+
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->bits_per_word > 32) // t->bits_per_word never < 0
 			return -EINVAL;
@@ -902,20 +1367,50 @@ static int spi_tegra_transfer(struct spi_device *spi, struct spi_message *m)
 			return -EINVAL;
 	}
 
+#ifdef DEBUG_962049
+	g_spi_tegra_transfer_debug_flag = 3;
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s: lock\n",  __func__);
+#endif
+
 	spin_lock_irqsave(&tspi->lock, flags);
 
+#ifdef DEBUG_962049
+	g_spi_tegra_transfer_debug_flag = 4;
+#endif
+
 	if (WARN_ON(tspi->is_suspended)) {
 		spin_unlock_irqrestore(&tspi->lock, flags);
+#ifdef DEBUG_962049
+		if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+			dev_info(&tspi->pdev->dev, "[debug_962049]%s-, tspi->is_suspended\n",  __func__);
+
+		g_spi_tegra_transfer_debug_flag = 5;
+#endif
 		return -EBUSY;
 	}
 
 	m->state = spi;
 	was_empty = list_empty(&tspi->queue);
 	list_add_tail(&m->queue, &tspi->queue);
+
+#ifdef DEBUG_962049
+	g_spi_tegra_transfer_debug_flag = 6;
+#endif
+
 	if (was_empty)
 		queue_work(tspi->spi_workqueue, &tspi->spi_transfer_work);
 
+#ifdef DEBUG_962049
+	g_spi_tegra_transfer_debug_flag = 7;
+#endif
+
 	spin_unlock_irqrestore(&tspi->lock, flags);
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s-\n",  __func__);
+	g_spi_tegra_transfer_debug_flag = 8;
+#endif
 	return 0;
 }
 
@@ -927,12 +1422,26 @@ static void spi_tegra_curr_transfer_complete(struct spi_tegra_data *tspi,
 	struct spi_transfer *t;
 	int single_xfer = 0;
 
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s+\n",  __func__);
+	g_spi_tegra_curr_transfer_complete_debug_flag = 1;
+#endif
+
 	/* Check if CS need to be toggele here */
 	if (tspi->cur && tspi->cur->cs_change &&
 				tspi->cur->delay_usecs) {
 		udelay(tspi->cur->delay_usecs);
 	}
 
+#ifdef SOLUTION_967438
+	/* Check queue list to make sure it is not empty */
+	if( list_empty(&tspi->queue) ) {
+		pr_err("[%s] list_empty(&tspi->queue)\n", __func__);
+		return;
+	}
+#endif
+
 	m = list_first_entry(&tspi->queue, struct spi_message, queue);
 	if (err)
 		m->status = -EIO;
@@ -941,13 +1450,26 @@ static void spi_tegra_curr_transfer_complete(struct spi_tegra_data *tspi,
 	m->actual_length += cur_xfer_size;
 
 	if ( (tspi->cur != NULL) && (!list_is_last(&tspi->cur->transfer_list, &m->transfers)) ) {
+#ifdef DEBUG_962049
+		g_spi_tegra_curr_transfer_complete_debug_flag = 2;
+#endif
 		tspi->cur = list_first_entry(&tspi->cur->transfer_list,
 			struct spi_transfer, transfer_list);
 		spin_unlock_irqrestore(&tspi->lock, *irq_flags);
+#ifdef DEBUG_962049
+		g_spi_tegra_curr_transfer_complete_debug_flag = 3;
+#endif
 		spi_tegra_start_transfer(spi, tspi->cur, false, 0);
+#ifdef DEBUG_962049
+		g_spi_tegra_curr_transfer_complete_debug_flag = 4;
+#endif
 		spin_lock_irqsave(&tspi->lock, *irq_flags);
+#ifdef DEBUG_962049
+		g_spi_tegra_curr_transfer_complete_debug_flag = 5;
+#endif
 	} else {
 		list_del(&m->queue);
+		tspi->cur = 0;
 		m->complete(m->context);
 		if (!list_empty(&tspi->queue)) {
 			if (tspi->is_suspended) {
@@ -956,6 +1478,12 @@ static void spi_tegra_curr_transfer_complete(struct spi_tegra_data *tspi,
 				spi_tegra_writel(tspi, tspi->def_command2_reg,
 						SLINK_COMMAND2);
 				tspi->is_transfer_in_progress = false;
+#ifdef DEBUG_962049
+				if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+					dev_info(&tspi->pdev->dev, "[debug_962049]%s-, tspi->is_suspended\n",  __func__);
+
+				g_spi_tegra_curr_transfer_complete_debug_flag = 6;
+#endif
 				return;
 			}
 			m = list_first_entry(&tspi->queue, struct spi_message,
@@ -967,34 +1495,69 @@ static void spi_tegra_curr_transfer_complete(struct spi_tegra_data *tspi,
 
 			t = list_first_entry(&m->transfers, struct spi_transfer,
 						transfer_list);
+#ifdef DEBUG_962049
+			g_spi_tegra_curr_transfer_complete_debug_flag = 7;
+#endif
 			spin_unlock_irqrestore(&tspi->lock, *irq_flags);
+#ifdef DEBUG_962049
+			g_spi_tegra_curr_transfer_complete_debug_flag = 8;
+#endif
 			spi_tegra_start_transfer(spi, t, true, single_xfer);
+#ifdef DEBUG_962049
+			g_spi_tegra_curr_transfer_complete_debug_flag = 9;
+#endif
 			spin_lock_irqsave(&tspi->lock, *irq_flags);
+#ifdef DEBUG_962049
+			g_spi_tegra_curr_transfer_complete_debug_flag = 10;
+#endif
 		} else {
 			spi_tegra_writel(tspi, tspi->def_command_reg,
 								SLINK_COMMAND);
 			spi_tegra_writel(tspi, tspi->def_command2_reg,
 								SLINK_COMMAND2);
+#ifdef DEBUG_962049
+			g_spi_tegra_curr_transfer_complete_debug_flag = 11;
+#endif
 			if (!tspi->is_clkon_always) {
 				if (tspi->clk_state) {
 					/* Provide delay to stablize the signal
 					   state */
+#ifdef DEBUG_962049
+					g_spi_tegra_curr_transfer_complete_debug_flag = 12;
+#endif
 					spin_unlock_irqrestore(&tspi->lock,
 							*irq_flags);
 					udelay(10);
+#ifdef DEBUG_962049
+					g_spi_tegra_curr_transfer_complete_debug_flag = 13;
+#endif
 					pm_runtime_put_sync(&tspi->pdev->dev);
+#ifdef DEBUG_962049
+					g_spi_tegra_curr_transfer_complete_debug_flag = 14;
+#endif
 					spin_lock_irqsave(&tspi->lock,
 							*irq_flags);
+#ifdef DEBUG_962049
+					g_spi_tegra_curr_transfer_complete_debug_flag = 15;
+#endif
 					tspi->clk_state = 0;
 				}
 			}
 			tspi->is_transfer_in_progress = false;
+#ifdef DEBUG_962049
+			g_spi_tegra_curr_transfer_complete_debug_flag = 16;
+#endif
 			/* Check if any new request has come between
 			 * clock disable */
 			queue_work(tspi->spi_workqueue,
 					&tspi->spi_transfer_work);
 		}
 	}
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s-\n",  __func__);
+	g_spi_tegra_curr_transfer_complete_debug_flag = 17;
+#endif
 	return;
 }
 
@@ -1002,12 +1565,20 @@ static void tegra_spi_tx_dma_complete(struct tegra_dma_req *req)
 {
 	struct spi_tegra_data *tspi = req->dev;
 	//dump_stack();
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s\n",  __func__);
+#endif
 	complete(&tspi->tx_dma_complete);
 }
 
 static void tegra_spi_rx_dma_complete(struct tegra_dma_req *req)
 {
 	struct spi_tegra_data *tspi = req->dev;
+#ifdef DEBUG_962049
+	if ( g_enable_debug_962049 && tspi->pdev->id == 0)
+		dev_info(&tspi->pdev->dev, "[debug_962049]%s\n",  __func__);
+#endif
 	complete(&tspi->rx_dma_complete);
 }
 
@@ -1067,6 +1638,9 @@ static irqreturn_t spi_tegra_isr_thread(int irq, void *context_data)
 	unsigned total_fifo_words;
 	unsigned long flags;
 
+	if (t == NULL)
+		return IRQ_HANDLED;
+
 	if (!tspi->is_curr_dma_xfer) {
 		handle_cpu_based_xfer(context_data);
 		return IRQ_HANDLED;
@@ -1191,6 +1765,16 @@ static int __init spi_tegra_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
+#ifdef DEBUG_SPI_MASTER_OOPS
+	dev_info(&pdev->dev, "master=[0x%x]\n", master);
+#endif
+
+#ifdef DEBUG_960388
+	tegra_masters[pdev->id] = master;
+	tegra_master_devices[pdev->id] = &master->dev;
+	tegra_master_device_privates[pdev->id] = master->dev.p;
+#endif
+
 	/* the spi->mode bits understood by this driver: */
 	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
 
@@ -1202,7 +1786,11 @@ static int __init spi_tegra_probe(struct platform_device *pdev)
 	master->num_chipselect = MAX_CHIP_SELECT;
 
 	dev_set_drvdata(&pdev->dev, master);
+#ifdef DEBUG_960388
+	tspi = spi_master_get_devdata_debug(master);
+#else
 	tspi = spi_master_get_devdata(master);
+#endif
 	tspi->master = master;
 	tspi->pdev = pdev;
 	tspi->is_transfer_in_progress = false;
@@ -1239,7 +1827,7 @@ static int __init spi_tegra_probe(struct platform_device *pdev)
 
 	sprintf(tspi->port_name, "tegra_spi_%d", pdev->id);
 	ret = request_threaded_irq(tspi->irq, spi_tegra_isr,
-			spi_tegra_isr_thread, IRQF_DISABLED,
+			spi_tegra_isr_thread, IRQF_ONESHOT,
 			tspi->port_name, tspi);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",
@@ -1247,13 +1835,26 @@ static int __init spi_tegra_probe(struct platform_device *pdev)
 		goto fail_irq_req;
 	}
 
+#ifdef CONFIG_SERIAL_SC8800G
+	tspi->clk = clk_get(&pdev->dev, "spi");
+#else
 	tspi->clk = clk_get(&pdev->dev, NULL);
+#endif
+
 	if (IS_ERR(tspi->clk)) {
 		dev_err(&pdev->dev, "can not get clock\n");
 		ret = PTR_ERR(tspi->clk);
 		goto fail_clk_get;
 	}
 
+#ifdef CONFIG_SERIAL_SC8800G
+	tspi->sclk = clk_get(&pdev->dev, "sclk");
+	if (IS_ERR(tspi->sclk)) {
+		dev_err(&pdev->dev, "can not get sclock\n");
+		ret = PTR_ERR(tspi->sclk);
+		goto fail_sclk_get;
+	}
+#endif
 	INIT_LIST_HEAD(&tspi->queue);
 
 	if (pdata) {
@@ -1384,6 +1985,7 @@ skip_dma_alloc:
 
 	INIT_WORK(&tspi->spi_transfer_work, tegra_spi_transfer_work);
 
+	printk(KERN_INFO "[SPI] %s, tegra_spi_%d done \n", __func__, pdev->id);
 	return ret;
 
 fail_workqueue:
@@ -1405,6 +2007,10 @@ fail_rx_buf_alloc:
 		tegra_dma_free_channel(tspi->rx_dma);
 fail_rx_dma_alloc:
 	pm_runtime_disable(&pdev->dev);
+#ifdef CONFIG_SERIAL_SC8800G
+	clk_put(tspi->sclk);
+fail_sclk_get:
+#endif
 	clk_put(tspi->clk);
 fail_clk_get:
 	free_irq(tspi->irq, tspi);
@@ -1414,6 +2020,7 @@ fail_io_map:
 	release_mem_region(r->start, (r->end - r->start) + 1);
 fail_no_mem:
 	spi_master_put(master);
+	printk(KERN_INFO "[SPI] %s, tegra_spi_%d error \n", __func__, pdev->id);
 	return ret;
 }
 
@@ -1424,7 +2031,15 @@ static int __devexit spi_tegra_remove(struct platform_device *pdev)
 	struct resource		*r;
 
 	master = dev_get_drvdata(&pdev->dev);
+#ifdef DEBUG_960388
+	tspi = spi_master_get_devdata_debug(master);
+#else
 	tspi = spi_master_get_devdata(master);
+#endif
+
+#ifdef DEBUG_SPI_MASTER_OOPS
+	dev_info(&pdev->dev, "[SPI_TEGRA] spi_tegra_remove~\n");
+#endif
 
 	if (tspi->tx_buf)
 		dma_free_coherent(&pdev->dev, tspi->dma_buf_size,
@@ -1442,6 +2057,9 @@ static int __devexit spi_tegra_remove(struct platform_device *pdev)
 		tspi->clk_state = 0;
 	}
 	pm_runtime_disable(&pdev->dev);
+#ifdef CONFIG_SERIAL_SC8800G
+	clk_put(tspi->sclk);
+#endif
 	clk_put(tspi->clk);
 	iounmap(tspi->base);
 
@@ -1465,7 +2083,11 @@ static int spi_tegra_suspend(struct platform_device *pdev, pm_message_t state)
 	unsigned long flags;
 
 	master = dev_get_drvdata(&pdev->dev);
+#ifdef DEBUG_960388
+	tspi = spi_master_get_devdata_debug(master);
+#else
 	tspi = spi_master_get_devdata(master);
+#endif
 	spin_lock_irqsave(&tspi->lock, flags);
 
 	/* Wait for all transfer completes */
@@ -1521,7 +2143,11 @@ static int spi_tegra_resume(struct platform_device *pdev)
 	unsigned long flags;
 
 	master = dev_get_drvdata(&pdev->dev);
+#ifdef DEBUG_960388
+	tspi = spi_master_get_devdata_debug(master);
+#else
 	tspi = spi_master_get_devdata(master);
+#endif
 
 	pm_runtime_get_sync(&pdev->dev);
 	tspi->clk_state = 1;
@@ -1560,9 +2186,16 @@ static int tegra_spi_runtime_idle(struct device *dev)
 	struct spi_master	*master;
 	struct spi_tegra_data	*tspi;
 	master = dev_get_drvdata(dev);
+#ifdef DEBUG_960388
+	tspi = spi_master_get_devdata_debug(master);
+#else
 	tspi = spi_master_get_devdata(master);
+#endif
 
 	clk_disable(tspi->clk);
+#ifdef CONFIG_SERIAL_SC8800G
+	clk_disable(tspi->sclk);
+#endif
 	return 0;
 }
 
@@ -1571,8 +2204,15 @@ static int tegra_spi_runtime_resume(struct device *dev)
 	struct spi_master	*master;
 	struct spi_tegra_data	*tspi;
 	master = dev_get_drvdata(dev);
+#ifdef DEBUG_960388
+	tspi = spi_master_get_devdata_debug(master);
+#else
 	tspi = spi_master_get_devdata(master);
+#endif
 
+#ifdef CONFIG_SERIAL_SC8800G
+	clk_enable(tspi->sclk);
+#endif
 	clk_enable(tspi->clk);
 	return 0;
 }
diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 3b29618..e13b4c4 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -27,7 +27,6 @@
 #include <linux/nsproxy.h>
 #include <linux/poll.h>
 #include <linux/debugfs.h>
-#include <linux/proc_fs.h>
 #include <linux/rbtree.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
@@ -46,8 +45,6 @@ static HLIST_HEAD(binder_dead_nodes);
 
 static struct dentry *binder_debugfs_dir_entry_root;
 static struct dentry *binder_debugfs_dir_entry_proc;
-static struct proc_dir_entry *binder_proc_dir_entry_root;
-static struct proc_dir_entry *binder_proc_dir_entry_proc;
 static struct binder_node *binder_context_mgr_node;
 static uid_t binder_context_mgr_uid = -1;
 static int binder_last_id;
@@ -70,9 +67,6 @@ static const struct file_operations binder_##name##_fops = { \
 static int binder_proc_show(struct seq_file *m, void *unused);
 BINDER_DEBUG_ENTRY(proc);
 
-static int procfs_binder_read_proc_proc(char *page, char **start, off_t off,
-				 int count, int *eof, void *data);
-
 /* This is only defined in include/asm-arm/sizes.h */
 #ifndef SZ_1K
 #define SZ_1K                               0x400
@@ -2876,32 +2870,6 @@ err_bad_arg:
 	return ret;
 }
 
-static int proc_match(int len, const char *name, struct proc_dir_entry *de)
-{
-	if (de->namelen != len)
-		return 0;
-	return !memcmp(name, de->name, len);
-}
-
-static int exist_proc_entry(const char *name, struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry **p;
-	struct proc_dir_entry *de = NULL;
-	int len;
-
-	len = strlen(name);
-	for (p = &parent->subdir; *p; p = &(*p)->next) {
-		if (proc_match(len, name, *p)) {
-			de = *p;
-			*p = de->next;
-			de->next = NULL;
-			break;
-		}
-	}
-
-	return de != NULL;
-}
-
 static int binder_open(struct inode *nodp, struct file *filp)
 {
 	struct binder_proc *proc;
@@ -2932,17 +2900,6 @@ static int binder_open(struct inode *nodp, struct file *filp)
 			binder_debugfs_dir_entry_proc, proc, &binder_proc_fops);
 	}
 
-	if (binder_proc_dir_entry_proc) {
-		char strbuf[11];
-		snprintf(strbuf, sizeof(strbuf), "%u", proc->pid);
-		if (exist_proc_entry(strbuf, binder_proc_dir_entry_proc))
-			remove_proc_entry(strbuf, binder_proc_dir_entry_proc);
-
-		create_proc_read_entry(strbuf, S_IRUGO,
-				       binder_proc_dir_entry_proc,
-				       procfs_binder_read_proc_proc, proc);
-	}
-
 	return 0;
 }
 
@@ -2978,11 +2935,6 @@ static int binder_release(struct inode *nodp, struct file *filp)
 {
 	struct binder_proc *proc = filp->private_data;
 	debugfs_remove(proc->debugfs_entry);
-	if (binder_proc_dir_entry_proc) {
-		char strbuf[11];
-		snprintf(strbuf, sizeof(strbuf), "%u", proc->pid);
-		remove_proc_entry(strbuf, binder_proc_dir_entry_proc);
-	}
 	binder_defer_work(proc, BINDER_DEFERRED_RELEASE);
 
 	return 0;
@@ -3340,235 +3292,6 @@ static void print_binder_proc(struct seq_file *m,
 		m->count = start_pos;
 }
 
-static char *procfs_print_binder_transaction(char *buf, char *end, const char *prefix,
-				      struct binder_transaction *t)
-{
-	buf += snprintf(buf, end - buf,
-			"%s %d: %p from %d:%d to %d:%d code %x "
-			"flags %x pri %ld r%d",
-			prefix, t->debug_id, t,
-			t->from ? t->from->proc->pid : 0,
-			t->from ? t->from->pid : 0,
-			t->to_proc ? t->to_proc->pid : 0,
-			t->to_thread ? t->to_thread->pid : 0,
-			t->code, t->flags, t->priority, t->need_reply);
-	if (buf >= end)
-		return buf;
-	if (t->buffer == NULL) {
-		buf += snprintf(buf, end - buf, " buffer free\n");
-		return buf;
-	}
-	if (t->buffer->target_node) {
-		buf += snprintf(buf, end - buf, " node %d",
-				t->buffer->target_node->debug_id);
-		if (buf >= end)
-			return buf;
-	}
-	buf += snprintf(buf, end - buf, " size %zd:%zd data %p\n",
-			t->buffer->data_size, t->buffer->offsets_size,
-			t->buffer->data);
-	return buf;
-}
-
-static char *procfs_print_binder_buffer(char *buf, char *end, const char *prefix,
-				 struct binder_buffer *buffer)
-{
-	buf += snprintf(buf, end - buf, "%s %d: %p size %zd:%zd %s\n",
-			prefix, buffer->debug_id, buffer->data,
-			buffer->data_size, buffer->offsets_size,
-			buffer->transaction ? "active" : "delivered");
-	return buf;
-}
-
-static char *procfs_print_binder_work(char *buf, char *end, const char *prefix,
-			       const char *transaction_prefix,
-			       struct binder_work *w)
-{
-	struct binder_node *node;
-	struct binder_transaction *t;
-
-	switch (w->type) {
-	case BINDER_WORK_TRANSACTION:
-		t = container_of(w, struct binder_transaction, work);
-		buf = procfs_print_binder_transaction(buf, end, transaction_prefix, t);
-		break;
-	case BINDER_WORK_TRANSACTION_COMPLETE:
-		buf += snprintf(buf, end - buf,
-				"%stransaction complete\n", prefix);
-		break;
-	case BINDER_WORK_NODE:
-		node = container_of(w, struct binder_node, work);
-		buf += snprintf(buf, end - buf, "%snode work %d: u%p c%p\n",
-				prefix, node->debug_id, node->ptr,
-				node->cookie);
-		break;
-	case BINDER_WORK_DEAD_BINDER:
-		buf += snprintf(buf, end - buf, "%shas dead binder\n", prefix);
-		break;
-	case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
-		buf += snprintf(buf, end - buf,
-				"%shas cleared dead binder\n", prefix);
-		break;
-	case BINDER_WORK_CLEAR_DEATH_NOTIFICATION:
-		buf += snprintf(buf, end - buf,
-				"%shas cleared death notification\n", prefix);
-		break;
-	default:
-		buf += snprintf(buf, end - buf, "%sunknown work: type %d\n",
-				prefix, w->type);
-		break;
-	}
-	return buf;
-}
-
-static char *procfs_print_binder_thread(char *buf, char *end,
-				 struct binder_thread *thread,
-				 int print_always)
-{
-	struct binder_transaction *t;
-	struct binder_work *w;
-	char *start_buf = buf;
-	char *header_buf;
-
-	buf += snprintf(buf, end - buf, "  thread %d: l %02x\n",
-			thread->pid, thread->looper);
-	header_buf = buf;
-	t = thread->transaction_stack;
-	while (t) {
-		if (buf >= end)
-			break;
-		if (t->from == thread) {
-			buf = procfs_print_binder_transaction(buf, end,
-						"    outgoing transaction", t);
-			t = t->from_parent;
-		} else if (t->to_thread == thread) {
-			buf = procfs_print_binder_transaction(buf, end,
-						"    incoming transaction", t);
-			t = t->to_parent;
-		} else {
-			buf = procfs_print_binder_transaction(buf, end,
-						"    bad transaction", t);
-			t = NULL;
-		}
-	}
-	list_for_each_entry(w, &thread->todo, entry) {
-		if (buf >= end)
-			break;
-		buf = procfs_print_binder_work(buf, end, "    ",
-					"    pending transaction", w);
-	}
-	if (!print_always && buf == header_buf)
-		buf = start_buf;
-	return buf;
-}
-
-static char *procfs_print_binder_node(char *buf, char *end, struct binder_node *node)
-{
-	struct binder_ref *ref;
-	struct hlist_node *pos;
-	struct binder_work *w;
-	int count;
-
-	count = 0;
-	hlist_for_each_entry(ref, pos, &node->refs, node_entry)
-		count++;
-
-	buf += snprintf(buf, end - buf,
-			"  node %d: u%p c%p hs %d hw %d ls %d lw %d "
-			"is %d iw %d",
-			node->debug_id, node->ptr, node->cookie,
-			node->has_strong_ref, node->has_weak_ref,
-			node->local_strong_refs, node->local_weak_refs,
-			node->internal_strong_refs, count);
-	if (buf >= end)
-		return buf;
-	if (count) {
-		buf += snprintf(buf, end - buf, " proc");
-		if (buf >= end)
-			return buf;
-		hlist_for_each_entry(ref, pos, &node->refs, node_entry) {
-			buf += snprintf(buf, end - buf, " %d", ref->proc->pid);
-			if (buf >= end)
-				return buf;
-		}
-	}
-	buf += snprintf(buf, end - buf, "\n");
-	list_for_each_entry(w, &node->async_todo, entry) {
-		if (buf >= end)
-			break;
-		buf = procfs_print_binder_work(buf, end, "    ",
-					"    pending async transaction", w);
-	}
-	return buf;
-}
-
-static char *procfs_print_binder_ref(char *buf, char *end, struct binder_ref *ref)
-{
-	buf += snprintf(buf, end - buf,
-			"  ref %d: desc %d %snode %d s %d w %d d %p\n",
-			ref->debug_id, ref->desc,
-			ref->node->proc ? "" : "dead ", ref->node->debug_id,
-			ref->strong, ref->weak, ref->death);
-	return buf;
-}
-
-static char *procfs_print_binder_proc(char *buf, char *end,
-			       struct binder_proc *proc, int print_all)
-{
-	struct binder_work *w;
-	struct rb_node *n;
-	char *start_buf = buf;
-	char *header_buf;
-
-	buf += snprintf(buf, end - buf, "proc %d\n", proc->pid);
-	header_buf = buf;
-
-	for (n = rb_first(&proc->threads);
-	     n != NULL && buf < end;
-	     n = rb_next(n))
-		buf = procfs_print_binder_thread(buf, end,
-					  rb_entry(n, struct binder_thread,
-						   rb_node), print_all);
-	for (n = rb_first(&proc->nodes);
-	     n != NULL && buf < end;
-	     n = rb_next(n)) {
-		struct binder_node *node = rb_entry(n, struct binder_node,
-						    rb_node);
-		if (print_all || node->has_async_transaction)
-			buf = procfs_print_binder_node(buf, end, node);
-	}
-	if (print_all) {
-		for (n = rb_first(&proc->refs_by_desc);
-		     n != NULL && buf < end;
-		     n = rb_next(n))
-			buf = procfs_print_binder_ref(buf, end,
-					       rb_entry(n, struct binder_ref,
-							rb_node_desc));
-	}
-	for (n = rb_first(&proc->allocated_buffers);
-	     n != NULL && buf < end;
-	     n = rb_next(n))
-		buf = procfs_print_binder_buffer(buf, end, "  buffer",
-					  rb_entry(n, struct binder_buffer,
-						   rb_node));
-	list_for_each_entry(w, &proc->todo, entry) {
-		if (buf >= end)
-			break;
-		buf = procfs_print_binder_work(buf, end, "  ",
-					"  pending transaction", w);
-	}
-	list_for_each_entry(w, &proc->delivered_death, entry) {
-		if (buf >= end)
-			break;
-		buf += snprintf(buf, end - buf,
-				"  has delivered dead binder\n");
-		break;
-	}
-	if (!print_all && buf == header_buf)
-		buf = start_buf;
-	return buf;
-}
-
 static const char *binder_return_strings[] = {
 	"BR_ERROR",
 	"BR_OK",
@@ -3808,329 +3531,6 @@ static int binder_transaction_log_show(struct seq_file *m, void *unused)
 	return 0;
 }
 
-static char *procfs_print_binder_stats(char *buf, char *end, const char *prefix,
-				struct binder_stats *stats)
-{
-	int i;
-
-	BUILD_BUG_ON(ARRAY_SIZE(stats->bc) !=
-			ARRAY_SIZE(binder_command_strings));
-	for (i = 0; i < ARRAY_SIZE(stats->bc); i++) {
-		if (stats->bc[i])
-			buf += snprintf(buf, end - buf, "%s%s: %d\n", prefix,
-					binder_command_strings[i],
-					stats->bc[i]);
-		if (buf >= end)
-			return buf;
-	}
-
-	BUILD_BUG_ON(ARRAY_SIZE(stats->br) !=
-			ARRAY_SIZE(binder_return_strings));
-	for (i = 0; i < ARRAY_SIZE(stats->br); i++) {
-		if (stats->br[i])
-			buf += snprintf(buf, end - buf, "%s%s: %d\n", prefix,
-					binder_return_strings[i], stats->br[i]);
-		if (buf >= end)
-			return buf;
-	}
-
-	BUILD_BUG_ON(ARRAY_SIZE(stats->obj_created) !=
-			ARRAY_SIZE(binder_objstat_strings));
-	BUILD_BUG_ON(ARRAY_SIZE(stats->obj_created) !=
-			ARRAY_SIZE(stats->obj_deleted));
-	for (i = 0; i < ARRAY_SIZE(stats->obj_created); i++) {
-		if (stats->obj_created[i] || stats->obj_deleted[i])
-			buf += snprintf(buf, end - buf,
-					"%s%s: active %d total %d\n", prefix,
-					binder_objstat_strings[i],
-					stats->obj_created[i] -
-						stats->obj_deleted[i],
-					stats->obj_created[i]);
-		if (buf >= end)
-			return buf;
-	}
-	return buf;
-}
-
-static char *procfs_print_binder_proc_stats(char *buf, char *end,
-				     struct binder_proc *proc)
-{
-	struct binder_work *w;
-	struct rb_node *n;
-	int count, strong, weak;
-
-	buf += snprintf(buf, end - buf, "proc %d\n", proc->pid);
-	if (buf >= end)
-		return buf;
-	count = 0;
-	for (n = rb_first(&proc->threads); n != NULL; n = rb_next(n))
-		count++;
-	buf += snprintf(buf, end - buf, "  threads: %d\n", count);
-	if (buf >= end)
-		return buf;
-	buf += snprintf(buf, end - buf, "  requested threads: %d+%d/%d\n"
-			"  ready threads %d\n"
-			"  free async space %zd\n", proc->requested_threads,
-			proc->requested_threads_started, proc->max_threads,
-			proc->ready_threads, proc->free_async_space);
-	if (buf >= end)
-		return buf;
-	count = 0;
-	for (n = rb_first(&proc->nodes); n != NULL; n = rb_next(n))
-		count++;
-	buf += snprintf(buf, end - buf, "  nodes: %d\n", count);
-	if (buf >= end)
-		return buf;
-	count = 0;
-	strong = 0;
-	weak = 0;
-	for (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {
-		struct binder_ref *ref = rb_entry(n, struct binder_ref,
-						  rb_node_desc);
-		count++;
-		strong += ref->strong;
-		weak += ref->weak;
-	}
-	buf += snprintf(buf, end - buf, "  refs: %d s %d w %d\n",
-			count, strong, weak);
-	if (buf >= end)
-		return buf;
-
-	count = 0;
-	for (n = rb_first(&proc->allocated_buffers); n != NULL; n = rb_next(n))
-		count++;
-	buf += snprintf(buf, end - buf, "  buffers: %d\n", count);
-	if (buf >= end)
-		return buf;
-
-	count = 0;
-	list_for_each_entry(w, &proc->todo, entry) {
-		switch (w->type) {
-		case BINDER_WORK_TRANSACTION:
-			count++;
-			break;
-		default:
-			break;
-		}
-	}
-	buf += snprintf(buf, end - buf, "  pending transactions: %d\n", count);
-	if (buf >= end)
-		return buf;
-
-	buf = procfs_print_binder_stats(buf, end, "  ", &proc->stats);
-
-	return buf;
-}
-
-
-static int procfs_binder_read_proc_state(char *page, char **start, off_t off,
-				  int count, int *eof, void *data)
-{
-	struct binder_proc *proc;
-	struct hlist_node *pos;
-	struct binder_node *node;
-	int len = 0;
-	char *buf = page;
-	char *end = page + PAGE_SIZE;
-	int do_lock = !binder_debug_no_lock;
-
-	if (off)
-		return 0;
-
-	if (do_lock)
-		mutex_lock(&binder_lock);
-
-	buf += snprintf(buf, end - buf, "binder state:\n");
-
-	if (!hlist_empty(&binder_dead_nodes))
-		buf += snprintf(buf, end - buf, "dead nodes:\n");
-	hlist_for_each_entry(node, pos, &binder_dead_nodes, dead_node) {
-		if (buf >= end)
-			break;
-		buf = procfs_print_binder_node(buf, end, node);
-	}
-
-	hlist_for_each_entry(proc, pos, &binder_procs, proc_node) {
-		if (buf >= end)
-			break;
-		buf = procfs_print_binder_proc(buf, end, proc, 1);
-	}
-	if (do_lock)
-		mutex_unlock(&binder_lock);
-	if (buf > page + PAGE_SIZE)
-		buf = page + PAGE_SIZE;
-
-	*start = page + off;
-
-	len = buf - page;
-	if (len > off)
-		len -= off;
-	else
-		len = 0;
-
-	return len < count ? len  : count;
-}
-
-static int procfs_binder_read_proc_stats(char *page, char **start, off_t off,
-				  int count, int *eof, void *data)
-{
-	struct binder_proc *proc;
-	struct hlist_node *pos;
-	int len = 0;
-	char *p = page;
-	int do_lock = !binder_debug_no_lock;
-
-	if (off)
-		return 0;
-
-	if (do_lock)
-		mutex_lock(&binder_lock);
-
-	p += snprintf(p, PAGE_SIZE, "binder stats:\n");
-
-	p = procfs_print_binder_stats(p, page + PAGE_SIZE, "", &binder_stats);
-
-	hlist_for_each_entry(proc, pos, &binder_procs, proc_node) {
-		if (p >= page + PAGE_SIZE)
-			break;
-		p = procfs_print_binder_proc_stats(p, page + PAGE_SIZE, proc);
-	}
-	if (do_lock)
-		mutex_unlock(&binder_lock);
-	if (p > page + PAGE_SIZE)
-		p = page + PAGE_SIZE;
-
-	*start = page + off;
-
-	len = p - page;
-	if (len > off)
-		len -= off;
-	else
-		len = 0;
-
-	return len < count ? len  : count;
-}
-
-static int procfs_binder_read_proc_transactions(char *page, char **start, off_t off,
-					 int count, int *eof, void *data)
-{
-	struct binder_proc *proc;
-	struct hlist_node *pos;
-	int len = 0;
-	char *buf = page;
-	char *end = page + PAGE_SIZE;
-	int do_lock = !binder_debug_no_lock;
-
-	if (off)
-		return 0;
-
-	if (do_lock)
-		mutex_lock(&binder_lock);
-
-	buf += snprintf(buf, end - buf, "binder transactions:\n");
-	hlist_for_each_entry(proc, pos, &binder_procs, proc_node) {
-		if (buf >= end)
-			break;
-		buf = procfs_print_binder_proc(buf, end, proc, 0);
-	}
-	if (do_lock)
-		mutex_unlock(&binder_lock);
-	if (buf > page + PAGE_SIZE)
-		buf = page + PAGE_SIZE;
-
-	*start = page + off;
-
-	len = buf - page;
-	if (len > off)
-		len -= off;
-	else
-		len = 0;
-
-	return len < count ? len  : count;
-}
-
-static int procfs_binder_read_proc_proc(char *page, char **start, off_t off,
-				 int count, int *eof, void *data)
-{
-	struct binder_proc *proc = data;
-	int len = 0;
-	char *p = page;
-	int do_lock = !binder_debug_no_lock;
-
-	if (off)
-		return 0;
-
-	if (do_lock)
-		mutex_lock(&binder_lock);
-	p += snprintf(p, PAGE_SIZE, "binder proc state:\n");
-	p = procfs_print_binder_proc(p, page + PAGE_SIZE, proc, 1);
-	if (do_lock)
-		mutex_unlock(&binder_lock);
-
-	if (p > page + PAGE_SIZE)
-		p = page + PAGE_SIZE;
-	*start = page + off;
-
-	len = p - page;
-	if (len > off)
-		len -= off;
-	else
-		len = 0;
-
-	return len < count ? len  : count;
-}
-
-static char *procfs_print_binder_transaction_log_entry(char *buf, char *end,
-					struct binder_transaction_log_entry *e)
-{
-	buf += snprintf(buf, end - buf,
-			"%d: %s from %d:%d to %d:%d node %d handle %d "
-			"size %d:%d\n",
-			e->debug_id, (e->call_type == 2) ? "reply" :
-			((e->call_type == 1) ? "async" : "call "), e->from_proc,
-			e->from_thread, e->to_proc, e->to_thread, e->to_node,
-			e->target_handle, e->data_size, e->offsets_size);
-	return buf;
-}
-
-static int procfs_binder_read_proc_transaction_log(
-	char *page, char **start, off_t off, int count, int *eof, void *data)
-{
-	struct binder_transaction_log *log = data;
-	int len = 0;
-	int i;
-	char *buf = page;
-	char *end = page + PAGE_SIZE;
-
-	if (off)
-		return 0;
-
-	if (log->full) {
-		for (i = log->next; i < ARRAY_SIZE(log->entry); i++) {
-			if (buf >= end)
-				break;
-			buf = procfs_print_binder_transaction_log_entry(buf, end,
-								&log->entry[i]);
-		}
-	}
-	for (i = 0; i < log->next; i++) {
-		if (buf >= end)
-			break;
-		buf = procfs_print_binder_transaction_log_entry(buf, end,
-							 &log->entry[i]);
-	}
-
-	*start = page + off;
-
-	len = buf - page;
-	if (len > off)
-		len -= off;
-	else
-		len = 0;
-
-	return len < count ? len  : count;
-}
-
 static const struct file_operations binder_fops = {
 	.owner = THIS_MODULE,
 	.poll = binder_poll,
@@ -4164,10 +3564,6 @@ static int __init binder_init(void)
 	if (binder_debugfs_dir_entry_root)
 		binder_debugfs_dir_entry_proc = debugfs_create_dir("proc",
 						 binder_debugfs_dir_entry_root);
-	binder_proc_dir_entry_root = proc_mkdir("binder", NULL);
-	if (binder_proc_dir_entry_root)
-		binder_proc_dir_entry_proc = proc_mkdir("proc",
-						binder_proc_dir_entry_root);
 	ret = misc_register(&binder_miscdev);
 	if (binder_debugfs_dir_entry_root) {
 		debugfs_create_file("state",
@@ -4196,34 +3592,6 @@ static int __init binder_init(void)
 				    &binder_transaction_log_failed,
 				    &binder_transaction_log_fops);
 	}
-
-	if (binder_proc_dir_entry_root) {
-		create_proc_read_entry("state",
-				       S_IRUGO,
-				       binder_proc_dir_entry_root,
-				       procfs_binder_read_proc_state,
-				       NULL);
-		create_proc_read_entry("stats",
-				       S_IRUGO,
-				       binder_proc_dir_entry_root,
-				       procfs_binder_read_proc_stats,
-				       NULL);
-		create_proc_read_entry("transactions",
-				       S_IRUGO,
-				       binder_proc_dir_entry_root,
-				       procfs_binder_read_proc_transactions,
-				       NULL);
-		create_proc_read_entry("transaction_log",
-				       S_IRUGO,
-				       binder_proc_dir_entry_root,
-				       procfs_binder_read_proc_transaction_log,
-				       &binder_transaction_log);
-		create_proc_read_entry("failed_transaction_log",
-				       S_IRUGO,
-				       binder_proc_dir_entry_root,
-				       procfs_binder_read_proc_transaction_log,
-				       &binder_transaction_log_failed);
-	}
 	return ret;
 }
 
diff --git a/drivers/staging/android/logger.c b/drivers/staging/android/logger.c
index fa76ce7..c8a9592 100644
--- a/drivers/staging/android/logger.c
+++ b/drivers/staging/android/logger.c
@@ -432,8 +432,11 @@ static int logger_release(struct inode *ignored, struct file *file)
 {
 	if (file->f_mode & FMODE_READ) {
 		struct logger_reader *reader = file->private_data;
+		struct logger_log *log = reader->log;
+		mutex_lock(&log->mutex);
 		list_del(&reader->list);
 		kfree(reader);
+		mutex_unlock(&log->mutex);
 	}
 
 	return 0;
diff --git a/drivers/thermal/thermal_sys.c b/drivers/thermal/thermal_sys.c
index f8a0b71..20426bb 100644
--- a/drivers/thermal/thermal_sys.c
+++ b/drivers/thermal/thermal_sys.c
@@ -595,7 +595,7 @@ static void thermal_zone_device_set_polling(struct thermal_zone_device *tz,
 	cancel_delayed_work(&(tz->poll_queue));
 
 	if (!delay) {
-		printk(KERN_INFO "[TMS] throttle end");
+		printk(KERN_INFO "[TMS] throttle end\n");
 		return;
 	}
 
@@ -640,7 +640,7 @@ static void thermal_zone_device_passive(struct thermal_zone_device *tz,
 				cdev->ops->get_max_state(cdev, &max_state);
 				if (state++ < max_state)
 					cdev->ops->set_cur_state(cdev, state);
-				printk(KERN_INFO "[TMS] throttling, state=%d", state);
+				printk(KERN_INFO "[TMS] throttling, state=%d\n", state);
 			}
 		} else if (trend < 0) { /* Cooling off? */
 			list_for_each_entry(instance, &tz->cooling_devices,
@@ -652,7 +652,7 @@ static void thermal_zone_device_passive(struct thermal_zone_device *tz,
 				cdev->ops->get_max_state(cdev, &max_state);
 				if (state > 0)
 					cdev->ops->set_cur_state(cdev, --state);
-				printk(KERN_INFO "[TMS] throttling, state=%d", state);
+				printk(KERN_INFO "[TMS] throttling, state=%d\n", state);
 			}
 		}
 		return;
@@ -673,7 +673,7 @@ static void thermal_zone_device_passive(struct thermal_zone_device *tz,
 		cdev->ops->get_max_state(cdev, &max_state);
 		if (state > 0)
 			cdev->ops->set_cur_state(cdev, --state);
-		printk(KERN_INFO "[TMS] throttling, state=%d", state);
+		printk(KERN_INFO "[TMS] throttling, state=%d\n", state);
 		if (state == 0) {
 			tz->passive = false;
 			if (tz->ops->get_temp(tz, &cur_temp)) {
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index e34d648..70784bf 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -37,7 +37,6 @@
 
 #include <asm/irq.h>
 #include <asm/uaccess.h>
-#include <htc/log.h>
 
 /*
  * This is used to lock changes in serial line configuration.
@@ -1299,7 +1298,6 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 		 * one, we've got real problems, since it means the
 		 * serial port won't be shutdown.
 		 */
-//		printk(KERN_ERR "uart_close: bad serial port count; tty->count is 1, "
 		printk(KERN_ERR "uart_close: bad serial port count; tty->count is 1, "
 		       "port->count is %d\n", port->count);
 		port->count = 1;
@@ -2022,6 +2020,10 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 	/*
 	 * Re-enable the console device after suspending.
 	 */
+#ifdef CONFIG_SERIAL_SC8800G
+	if (uport->line == 3)
+		printk("uart.3: uart_console(uport)=%d, (%d)", uart_console(uport), console_suspend_enabled);
+#endif
 	if (uart_console(uport)) {
 		/*
 		 * First try to use the console cflag setting.
diff --git a/drivers/tty/serial/tegra_hsuart.c b/drivers/tty/serial/tegra_hsuart.c
index c408ee7..f671d50 100644
--- a/drivers/tty/serial/tegra_hsuart.c
+++ b/drivers/tty/serial/tegra_hsuart.c
@@ -550,6 +550,10 @@ static void tegra_rx_dma_complete_callback(struct tegra_dma_req *req)
 	struct uart_port *u = &t->uport;
 	struct tty_struct *tty = u->state->port.tty;
 	int copied;
+/*remove WARN_ON(1) because the log message are too many*/
+#if 0
+	static int bytes_transferred_err = 0;
+#endif
 
 	/* If we are here, DMA is stopped */
 #ifdef UART_DATA_DEBUG
@@ -557,16 +561,28 @@ static void tegra_rx_dma_complete_callback(struct tegra_dma_req *req)
 		req->status);
 #endif
 	if (req->bytes_transferred) {
+		dma_sync_single_for_cpu(u->dev, t->rx_dma_req.dest_addr,
+			t->rx_dma_req.size, DMA_FROM_DEVICE);
 		t->uport.icount.rx += req->bytes_transferred;
 		copied = tty_insert_flip_string(tty,
 			((unsigned char *)(req->virt_addr)),
 			req->bytes_transferred);
+		dma_sync_single_for_device(u->dev, t->rx_dma_req.dest_addr,
+			t->rx_dma_req.size, DMA_TO_DEVICE);
+/*remove WARN_ON(1) because the log message are too many*/
+#if 0
 		if (copied != req->bytes_transferred) {
-			WARN_ON(1);
-			dev_err(t->uport.dev, "Not able to copy uart data "
-				"to tty layer Req %d and coped %d\n",
-				req->bytes_transferred, copied);
+			if ( bytes_transferred_err == 0 ) {
+				bytes_transferred_err = 1;
+				WARN_ON(1);
+				dev_err(t->uport.dev, "Not able to copy uart data "
+					"to tty layer Req %d and coped %d\n",
+					req->bytes_transferred, copied);
+			}
+		} else {
+			bytes_transferred_err = 0;
 		}
+#endif
 	}
 
 #ifdef MUX_UART_DEBUG
@@ -664,6 +680,13 @@ static char do_decode_rx_error(struct tegra_uart_port *t, u8 lsr)
 			/* Overrrun error  */
 			flag |= TTY_OVERRUN;
 			t->uport.icount.overrun++;
+#ifdef CONFIG_SERIAL_SC8800G
+			/*Reduce uart log for uart4 (MDM log usage for SC8800G)*/
+			if (t->uport.line == 3) {
+				if (t->uport.icount.overrun % 50 == 0)
+					dev_err(t->uport.dev, "Got overrun errors (%d)\n", t->uport.icount.overrun);
+			} else
+#endif
 			dev_err(t->uport.dev, "Got overrun errors\n");
 		} else if (lsr & UART_LSR_PE) {
 			/* Parity error */
@@ -673,8 +696,22 @@ static char do_decode_rx_error(struct tegra_uart_port *t, u8 lsr)
 		} else if (lsr & UART_LSR_FE) {
 			flag |= TTY_FRAME;
 			t->uport.icount.frame++;
+#ifdef CONFIG_SERIAL_SC8800G
+			/*Reduce uart log for uart4 (MDM log usage for SC8800G)*/
+			if (t->uport.line == 3) {
+				if (t->uport.icount.frame % 100 == 0)
+					dev_err(t->uport.dev, "Got frame errors (%d)\n", t->uport.icount.frame);
+			} else
+#endif
 			dev_err(t->uport.dev, "Got frame errors\n");
 		} else if (lsr & UART_LSR_BI) {
+#ifdef CONFIG_SERIAL_SC8800G
+			/*Reduce uart log for uart4 (MDM log usage for SC8800G)*/
+			if (t->uport.line == 3) {
+				if (t->uport.icount.brk % 500 == 0)
+					dev_err(t->uport.dev, "Got Break (%d)\n", t->uport.icount.brk);
+			} else
+#endif
 			dev_err(t->uport.dev, "Got Break\n");
 			t->uport.icount.brk++;
 			/* If FIFO read error without any data, reset Rx FIFO */
@@ -1292,6 +1329,10 @@ static int tegra_startup(struct uart_port *u)
 	struct tegra_uart_platform_data *pdata;
 
 	t = container_of(u, struct tegra_uart_port, uport);
+#ifdef CONFIG_SERIAL_SC8800G
+	if (t->uport.line == 3)
+		dev_info(u->dev,"+Start UART port %d\n", u->line);
+#endif
 	sprintf(t->port_name, "tegra_uart_%d", u->line);
 
 	t->use_tx_dma = false;
@@ -1344,6 +1385,11 @@ static int tegra_startup(struct uart_port *u)
 		dev_err(u->dev, "Failed to register ISR for IRQ %d\n", u->irq);
 		goto fail;
 	}
+#ifdef CONFIG_SERIAL_SC8800G
+	if (t->uport.line == 3)
+		dev_info(u->dev,"-Started UART port %d\n", u->line);
+	else
+#endif
 	dev_dbg(u->dev,"Started UART port %d\n", u->line);
 
 	return 0;
@@ -1768,13 +1814,23 @@ static void tegra_set_termios(struct uart_port *u, struct ktermios *termios,
 	unsigned char mcr;
 
 	t = container_of(u, struct tegra_uart_port, uport);
+#ifdef CONFIG_SERIAL_SC8800G
+	if (t->uport.line == 3)
+		dev_info(t->uport.dev, "+tegra_set_termios\n");
+	else
+#endif
 	dev_vdbg(t->uport.dev, "+tegra_set_termios\n");
 
 	spin_lock_irqsave(&u->lock, flags);
 
 	/* Changing configuration, it is safe to stop any rx now */
-	if (t->rts_active)
+	if (t->rts_active) {
+#if CONFIG_SERIAL_SC8800G
+		if (t->uport.line == 3)
+			disable_irq(u->irq);
+#endif
 		set_rts(t, false);
+	}
 
 	/* Parity */
 	lcr = t->lcr_shadow;
@@ -1824,6 +1880,7 @@ static void tegra_set_termios(struct uart_port *u, struct ktermios *termios,
 	spin_unlock_irqrestore(&u->lock, flags);
 	tegra_set_baudrate(t, baud);
 	spin_lock_irqsave(&u->lock, flags);
+	dev_info(t->uport.dev, "Set to baud rate: %d\n", t->baud);
 
 	/* Flow control */
 	if (termios->c_cflag & CRTSCTS)	{
@@ -1836,8 +1893,13 @@ static void tegra_set_termios(struct uart_port *u, struct ktermios *termios,
 		uart_writeb(t, mcr, UART_MCR);
 		t->use_cts_control = true;
 		/* if top layer has asked to set rts active then do so here */
-		if (t->rts_active)
+		if (t->rts_active) {
+#if CONFIG_SERIAL_SC8800G
+			if (t->uport.line == 3)
+				enable_irq(u->irq);
+#endif
 			set_rts(t, true);
+		}
 	} else {
 		mcr = t->mcr_shadow;
 		mcr &= ~UART_MCR_CTS_EN;
@@ -1851,6 +1913,11 @@ static void tegra_set_termios(struct uart_port *u, struct ktermios *termios,
 	uart_update_timeout(u, termios->c_cflag, baud);
 
 	spin_unlock_irqrestore(&u->lock, flags);
+#ifdef CONFIG_SERIAL_SC8800G
+	if (t->uport.line == 3)
+		dev_info(t->uport.dev, "-tegra_set_termios\n");
+	else
+#endif
 	dev_vdbg(t->uport.dev, "-tegra_set_termios\n");
 	return;
 }
@@ -2103,7 +2170,11 @@ static int tegra_uart_resume(struct platform_device *pdev)
 		pr_err("Invalid Uart instance (%d)\n", pdev->id);
 
 	u = &t->uport;
+#ifdef CONFIG_SERIAL_SC8800G
+	dev_info(t->uport.dev, "tegra_uart_resume called\n");
+#else
 	dev_dbg(t->uport.dev, "tegra_uart_resume called\n");
+#endif
 
 #ifdef CONFIG_SHARK_TD_WORKSHOP
 	if (t->uart_ipc) {
@@ -2143,7 +2214,11 @@ static int tegra_uart_resume(struct platform_device *pdev)
 #endif
 		uart_resume_port(&tegra_uart_driver, u);
 	}
+#ifdef CONFIG_SERIAL_SC8800G
+	dev_info(t->uport.dev, "tegra_uart_resume end\n");
+#else
 	printk("[SER] tegra_uart_resume end\n");
+#endif
 	return 0;
 }
 
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index fff032a..66e77dc 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -57,12 +57,21 @@ void tty_buffer_free_all(struct tty_struct *tty)
 static struct tty_buffer *tty_buffer_alloc(struct tty_struct *tty, size_t size)
 {
 	struct tty_buffer *p;
+	static int tty_buffer_alloc_err = 0;
 
-	if (tty->buf.memory_used + size > 65536)
+	if (tty->buf.memory_used + size > 65536) {
+		if ( tty_buffer_alloc_err == 0 ) {
+			tty_buffer_alloc_err = 1;
+			pr_err("%s: tty buffer overflow. (%s, %d, %d)\n", __func__, tty->driver->driver_name, tty->buf.memory_used, size);
+		}
 		return NULL;
+	}
+	tty_buffer_alloc_err = 0;
 	p = kmalloc(sizeof(struct tty_buffer) + 2 * size, GFP_ATOMIC);
-	if (p == NULL)
+	if (p == NULL) {
+		pr_err("%s: kmalloc failed for size %d\n", __func__, size);
 		return NULL;
+	}
 	p->used = 0;
 	p->size = size;
 	p->next = NULL;
@@ -304,6 +313,7 @@ int tty_insert_flip_string_flags(struct tty_struct *tty,
 		const unsigned char *chars, const char *flags, size_t size)
 {
 	int copied = 0;
+
 	do {
 		int goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);
 		int space = tty_buffer_request_room(tty, goal);
diff --git a/drivers/usb/class/Makefile b/drivers/usb/class/Makefile
index 7b4b6be..d3612a3 100644
--- a/drivers/usb/class/Makefile
+++ b/drivers/usb/class/Makefile
@@ -6,6 +6,9 @@
 ifeq (${CONFIG_MACH_ENDEAVORU},y)
 obj-$(CONFIG_USB_ACM)		+= cdc-acm.o
 endif
+ifeq (${CONFIG_MACH_ERAU},y)
+obj-$(CONFIG_USB_ACM)		+= cdc-acm.o
+endif
 obj-$(CONFIG_USB_PRINTER)	+= usblp.o
 obj-$(CONFIG_USB_WDM)		+= cdc-wdm.o
 obj-$(CONFIG_USB_TMC)		+= usbtmc.o
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index 52ec7e4..5a05299 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -95,12 +95,15 @@
 #include <asm/cacheflush.h>
 #include <linux/list.h>
 
+#include <linux/io.h>
+#include <mach/iomap.h>
+
 /* HTC include file */
 #include <mach/htc_hostdbg.h>
 #include <asm/cacheflush.h>
-#include <htc/log.h>
 
 #include "cdc-acm.h"
+#include "../../../arch/arm/mach-tegra/baseband-xmm-power.h"
 /* HTC: PRINTRPT */
 #include <mach/htc_ril_misc.h>
 #include <linux/ctype.h>
@@ -346,9 +349,12 @@ static int acm_start_wb(struct acm *acm, struct acm_wb *wb, char *func_name)
 		pr_info(MODULE_NAME "%s - acm_start_wb %s %p len=%d [%02x]\n",
 			__func__, func_name, wb->buf, wb->len, wb->buf[0]);
 
-	/* flush tx buffer from cache */
-	if (wb->len)
-		dmac_flush_range(wb->buf, wb->buf + wb->len -1);
+	 /* flush tx buffer from cache */
+	if (wb->len) {
+		dmac_flush_range(wb->buf, wb->buf + wb->len);
+		outer_flush_range(__pa(wb->buf), __pa(wb->buf+wb->len));
+	  }
+
 
 	rc = usb_submit_urb(wb->urb, GFP_ATOMIC);
 	if (rc < 0) {
@@ -385,7 +391,7 @@ static int acm_write_start(struct acm *acm, int wbn)
 
 	if (acm->susp_count) {
 #ifdef CONFIG_PM
-		sp_pr_debug("%s buffer urb %p len=%d, [%02x] anchor urb=%p\n",
+		printk("%s buffer urb %p len=%d, [%02x] anchor urb=%p\n",
 			__func__, wb->buf, wb->len, wb->buf[0], wb->urb);
 		acm->transmitting++;
 		wb->urb->transfer_buffer = wb->buf;
@@ -398,7 +404,7 @@ static int acm_write_start(struct acm *acm, int wbn)
 		if (!acm->delayed_wb) {
 			acm->delayed_wb = wb;
 			/* HTC */
-			sp_pr_debug(MODULE_NAME "%s - delayed wb, ttyACM%d, susp_cnt=%d, "
+			pr_info(MODULE_NAME "%s - delayed wb, ttyACM%d, susp_cnt=%d, "
 				"%p len=%d, [%02x]\n",
 				__func__, acm->minor, acm->susp_count, wb->buf, wb->len, wb->buf[0]);
 		} else {
@@ -574,10 +580,10 @@ static void acm_read_bulk(struct urb *urb)
 		//pr_info("%s: bulk rx status %d, acm->susp_count=%d\n", __func__, status, acm->susp_count);
 		dev_dbg(&acm->data->dev, "bulk rx status %d\n", status);
 		if (status == -EPROTO)	{
+			kobject_uevent(&acm->dev->dev.kobj,KOBJ_CHANGE);
+			pr_info(KERN_INFO "%s: -EPROTO HIT !!\n",__func__);
 			usb_register_dump();
-			//kobject_uevent(&acm->dev->dev.kobj,KOBJ_CHANGE);
-			//printk(KERN_INFO "-EPROTO HIT !!\n");
-
+			//trigger_radio_fatal_get_coredump();
 		}
 	}
 
@@ -678,6 +684,32 @@ next_buffer:
 		throttled = acm->throttle;
 		spin_unlock_irqrestore(&acm->throttle_lock, flags);
 		if (!throttled) {
+			/* check if buf->base did not get written by usb host controller
+			 * - we know if it was untouched by usb host controller because
+			 *   we filled rx urb buffer with 0xab byte pattern before
+			 *   we submitted rx urb
+			 */
+			{
+				int i;
+				for (i = 0; i < buf->size; i++)
+					if (buf->base[i] != 0xab)
+						break;
+				if ((buf->size > 0) && (i == buf->size)) {
+					pr_info("%s: rx urb contains 0xab byte pattern!  usb hc did not fill in rx urb buffer!\n", __func__);
+					/* Fence read for coherency of AHB master intiated writes (assume USB2 for HSIC) */
+#ifndef CONFIG_ARCH_TEGRA_2x_SOC
+#define USB2_PREFETCH_ID               18
+					readb(IO_ADDRESS(IO_PPCS_PHYS + USB2_PREFETCH_ID));
+#endif
+					/* recheck if fencing operation worked */
+					for (i = 0; i < buf->size; i++)
+						if (buf->base[i] != 0xab)
+							break;
+					if ((buf->size > 0) && (i == buf->size)) {
+						pr_info("%s: rx urb still contains 0xab byte pattern!  fencing operation failed!\n", __func__);
+					}
+				}
+			}
 			copied = tty_insert_flip_string(tty, buf->base, buf->size);
 			tty_flip_buffer_push(tty);
 			if (copied != buf->size && printk_ratelimit())
@@ -823,6 +855,7 @@ urbs:
 		memset(buf->base,0xaa,acm->readsize);
 		memset(buf->base,0xab,acm->readsize);
 		dmac_flush_range(buf->base,buf->base+acm->readsize-1);
+		outer_flush_range(__pa(buf->base),__pa(buf->base+acm->readsize-1));
 		//_range(current->,buf->base,buf->base+acm->readsize-1);
 		//memset(buf->base,0xaf,acm->readsize);
 
@@ -909,7 +942,7 @@ static int acm_tty_open(struct tty_struct *tty, struct file *filp)
 		pr_err("%s: tty NULL\n", __func__);
 		goto out;
 	}
-	if (tty->index >ACM_TTY_MINORS ) {
+	if (tty->index >= ACM_TTY_MINORS ) {
 		pr_err("%s: tty > ACM_TTY_MINORS\n", __func__);
 		goto out;
 	}
@@ -922,7 +955,7 @@ static int acm_tty_open(struct tty_struct *tty, struct file *filp)
 		rv = 0;
 
 #if 1 //HTC_CSP_START
-	printk(MODULE_NAME":%s ttyACM%d +\n",__FUNCTION__,acm->minor);
+		printk(MODULE_NAME":%s ttyACM%d +\n",__FUNCTION__,acm->minor);
 #endif //HTC_CSP_END
 
 	/* Current acm implementation does not have acm->disconnected
@@ -957,10 +990,24 @@ static int acm_tty_open(struct tty_struct *tty, struct file *filp)
 		goto out;
 	}
 
-	acm->ctrlurb->dev = acm->dev;
-	if (usb_submit_urb(acm->ctrlurb, GFP_KERNEL)) {
-		dbg("usb_submit_urb(ctrl irq) failed");
-		goto bail_out;
+	if ( tty->index == 1) {
+
+		printk(MODULE_NAME":%s tty->index =%d for ttyACM1 panic only\n",__FUNCTION__,tty->index);
+		//new patch for ttyACM1
+		INIT_LIST_HEAD(&acm->spare_read_urbs);
+		INIT_LIST_HEAD(&acm->spare_read_bufs);
+		INIT_LIST_HEAD(&acm->filled_read_bufs);
+
+		for (i = 0; i < acm->rx_buflimit; i++)
+			list_add(&(acm->ru[i].list), &acm->spare_read_urbs);
+		for (i = 0; i < acm->rx_buflimit; i++)
+			list_add(&(acm->rb[i].list), &acm->spare_read_bufs);
+		}
+
+		acm->ctrlurb->dev = acm->dev;
+		if (usb_submit_urb(acm->ctrlurb, GFP_KERNEL)) {
+			dbg("usb_submit_urb(ctrl irq) failed");
+			goto bail_out;
 	}
 
 	if (0 > acm_set_control(acm, acm->ctrlout = ACM_CTRL_DTR | ACM_CTRL_RTS) &&
@@ -969,6 +1016,9 @@ static int acm_tty_open(struct tty_struct *tty, struct file *filp)
 
 	reflog("[ref] - %s(%d) %d\n", __func__, __LINE__, --autopm_refcnt);
 	usb_autopm_put_interface(acm->control);
+	if ( tty->index != 1) {
+	//original code
+		printk(MODULE_NAME":%s tty->index =%d original code\n",__FUNCTION__,tty->index);
 
 	INIT_LIST_HEAD(&acm->spare_read_urbs);
 	INIT_LIST_HEAD(&acm->spare_read_bufs);
@@ -978,7 +1028,7 @@ static int acm_tty_open(struct tty_struct *tty, struct file *filp)
 		list_add(&(acm->ru[i].list), &acm->spare_read_urbs);
 	for (i = 0; i < acm->rx_buflimit; i++)
 		list_add(&(acm->rb[i].list), &acm->spare_read_bufs);
-
+	}
 	acm->throttle = 0;
 
 	set_bit(ASYNCB_INITIALIZED, &acm->port.flags);
@@ -1003,6 +1053,15 @@ out:
 full_bailout:
 	usb_kill_urb(acm->ctrlurb);
 bail_out:
+	if ( tty->index == 1) {
+
+		printk(MODULE_NAME":%s tty->index =%d for ttyACM1 only\n",__FUNCTION__,tty->index);
+	//new patch for ACM1
+		for (i = 0; i < acm->rx_buflimit; i++)
+			list_del(&(acm->ru[i].list));
+		for (i = 0; i < acm->rx_buflimit; i++)
+			list_del(&(acm->rb[i].list));
+	}
 	acm->port.count--;
 	mutex_unlock(&acm->mutex);
 	reflog("[ref] - %s(%d) %d\n", __func__, __LINE__, --autopm_refcnt);
@@ -1088,11 +1147,9 @@ static void acm_tty_hangup(struct tty_struct *tty)
 		printk(MODULE_NAME":%s ttyACM%d -\n",__FUNCTION__,acm->minor);
 #endif //HTC_CSP_END
 
+	pr_info("%s: ttyACM%d out: -\n", __func__, acm->minor);
 out:
 	mutex_unlock(&open_mutex);
-	pr_info("%s: ttyACM%d out: -\n", __func__, acm->minor);
-
-
 }
 
 
@@ -1474,8 +1531,7 @@ static int acm_probe(struct usb_interface *intf,
 	int i;
 	int combined_interfaces = 0;
 
-
-	pr_info("%s: 0311 - cdc drop urb fix intf->cur_altsetting->desc.bInterfaceNumber %d max_intfs=%d\n",
+	pr_info("%s: 0710 - zero length packet. intf->cur_altsetting->desc.bInterfaceNumber %d max_intfs=%d\n",
 		__func__, intf->cur_altsetting->desc.bInterfaceNumber,max_intfs);
 
 	/* normal quirks */
@@ -1573,7 +1629,7 @@ static int acm_probe(struct usb_interface *intf,
 			call_management_function = buffer[3];
 			call_interface_num = buffer[4];
 			if ( (quirks & NOT_A_MODEM) == 0 && (call_management_function & 3) != 3)
-				dev_err(&intf->dev, "This device cannot do calls on its own. It is not a modem.\n");
+				dev_dbg(&intf->dev, "This device cannot do calls on its own. It is not a modem.\n");
 			break;
 		default:
 			/* there are LOTS more CDC descriptors that
@@ -1742,7 +1798,7 @@ made_compressed_probe:
 	tty_port_init(&acm->port);
 	acm->port.ops = &acm_port_ops;
 
-	buf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_DMA, &acm->ctrl_dma);
+	buf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_DMA|GFP_KERNEL, &acm->ctrl_dma);
 	if (!buf) {
 		dev_dbg(&intf->dev, "out of memory (ctrl buffer alloc)\n");
 		goto alloc_fail2;
@@ -1776,7 +1832,7 @@ made_compressed_probe:
 		struct acm_rb *rb = &(acm->rb[i]);
 
 		rb->base = usb_alloc_coherent(acm->dev, readsize,
-				GFP_DMA, &rb->dma);
+				GFP_DMA|GFP_KERNEL, &rb->dma);
 		if (!rb->base) {
 			dev_dbg(&intf->dev,
 				"out of memory (read bufs usb_alloc_coherent)\n");
@@ -1801,7 +1857,7 @@ made_compressed_probe:
 			usb_fill_bulk_urb(snd->urb, usb_dev,
 				usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),
 				NULL, acm->writesize, acm_write_bulk, snd);
-		snd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		snd->urb->transfer_flags |= (URB_NO_TRANSFER_DMA_MAP + URB_ZERO_PACKET);
 		snd->instance = acm;
 	}
 
@@ -1860,7 +1916,7 @@ skip_countries:
 	acm_table[minor] = acm;
 
 	tty_register_device(acm_tty_driver, minor, &control_interface->dev);
-	
+
 	printk("%s: acm_ready_table[minor=%d]=ture\n", __func__,minor);
 	acm_ready_table[minor] = true;
 
@@ -1999,15 +2055,15 @@ static int acm_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct acm *acm = usb_get_intfdata(intf);
 	int cnt;
-#if 1 //HTC_CSP_START
-	printk(MODULE_NAME": %s ttyACM%d +\n",__FUNCTION__,acm->minor);
-#endif //HTC_CSP_END
-
 	if (!acm) {
 		pr_err("%s: !acm\n", __func__);
 		return -EBUSY;
 	}
 
+#if 1 //HTC_CSP_START
+		printk(MODULE_NAME": %s ttyACM%d +\n",__FUNCTION__,acm->minor);
+#endif //HTC_CSP_END
+
 	//pr_info("%s: cnt %d intf=%p &intf->dev=%p kobje=%s\n",
 		//	__func__, atomic_read(&intf->dev.power.usage_count),intf,&intf->dev,kobject_name(&intf->dev.kobj));
 
@@ -2081,7 +2137,6 @@ static int acm_resume(struct usb_interface *intf)
 		return -EBUSY;
 	}
 
-	
 	//pr_info("%s: cnt %d intf=%p &intf->dev=%p kobje=%s\n",
 		//	__func__, atomic_read(&intf->dev.power.usage_count),intf,&intf->dev,kobject_name(&intf->dev.kobj));
 
@@ -2174,13 +2229,13 @@ static int acm_reset_resume(struct usb_interface *intf)
 	struct acm *acm = usb_get_intfdata(intf);
 	struct tty_struct *tty = NULL;
 
-	printk(KERN_INFO"%s acm->port.count=%d\n",__func__,acm->port.count);
 	pr_info(MODULE_NAME "%s - don't hangup ttyacm\n", __func__);
 
 	if (!acm) {
 		pr_err("%s: !acm\n", __func__);
 		return -EBUSY;
 	}
+	printk(KERN_INFO"%s acm->port.count=%d\n",__func__,acm->port.count);
 /*
 	mutex_lock(&acm->mutex);
 	if (acm->port.count) {
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 36b4a1d..e77b648 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -30,9 +30,9 @@
 
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
-#include <htc/log.h>
 
 #include "usb.h"
+#include "../../../arch/arm/mach-tegra/baseband-xmm-power.h"
 
 /* HTC */
 #define MODULE_NAME "[USBHHUB] "
@@ -883,7 +883,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 					msecs_to_jiffies(delay));
 			return;		/* Continues at init3: below */
 		} else {
-			if (board_mfg_mode() == 2 /* recovery mode */) { /* htc */
+			if (board_mfg_mode() == BOARD_MFG_MODE_RECOVERY /* recovery mode */) { /* htc */
 				pr_info(MODULE_NAME "%s: debounce msleep(%d)\n", __func__, delay);
 				msleep(delay);
 			}
@@ -1529,7 +1529,7 @@ void usb_set_device_state(struct usb_device *udev,
 	/* HTC comment: all pr_deubg in this func is added by htc bert for debugging purpose */
 	spin_lock_irqsave(&device_state_lock, flags);
 	if (udev->state == USB_STATE_NOTATTACHED) {
-		sp_pr_debug(MODULE_NAME "%s, udev->state USB_STATE_NOTATTACHED", __func__);
+		pr_debug(MODULE_NAME "%s, udev->state USB_STATE_NOTATTACHED", __func__);
 	}
 	else if (new_state != USB_STATE_NOTATTACHED) {
 
@@ -1554,7 +1554,7 @@ void usb_set_device_state(struct usb_device *udev,
 			udev->active_duration += jiffies;
 		udev->state = new_state;
 	} else {
-		sp_pr_debug(MODULE_NAME "%s, recursively_mark_NOTATTACHED", __func__);
+		pr_debug(MODULE_NAME "%s, recursively_mark_NOTATTACHED", __func__);
 		recursively_mark_NOTATTACHED(udev);
 	}
 	spin_unlock_irqrestore(&device_state_lock, flags);
@@ -2070,7 +2070,7 @@ static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 	for (delay_time = 0;
 			delay_time < HUB_RESET_TIMEOUT;
 			delay_time += delay) {
-		if (board_mfg_mode() == 2 /* recovery mode */) { /* htc */
+		if (board_mfg_mode() == BOARD_MFG_MODE_RECOVERY /* recovery mode */) { /* htc */
 			/* wait to give the device a chance to reset */
 			pr_info(MODULE_NAME "%s: msleep(%d)\n", __func__, delay);
 			msleep(delay);
@@ -2154,7 +2154,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 		switch (status) {
 		case 0:
 			/* TRSTRCY = 10 ms; plus some extra */
-			if (board_mfg_mode() == 2 /* recovery mode */) { /* htc */
+			if (board_mfg_mode() == BOARD_MFG_MODE_RECOVERY /* recovery mode */) { /* htc */
 				pr_info(MODULE_NAME "%s: msleep(50)\n", __func__);
 				msleep(50);
 			}
@@ -3004,6 +3004,9 @@ pr_info("%s (b) hub_set_address- %d\n", __func__, __LINE__);
 				dev_err(&udev->dev,
 					"device not accepting address %d, error %d\n",
 					devnum, retval);
+
+				debug_gpio_dump(NULL,NULL,NULL,NULL);
+				//trigger_radio_fatal_get_coredump();
 				goto fail;
 			}
 			if (udev->speed == USB_SPEED_SUPER) {
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index 19af3a0..cef657a 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -241,12 +241,12 @@ static void android_work(struct work_struct *data)
 		spin_unlock_irqrestore(&cdev->lock, flags);
 		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE,
 							configured);
-		sp_pr_info("USB_STATE=CONFIGURED");
+		pr_info("USB_STATE=CONFIGURED");
 
 		/* hold perflock, wakelock for performance consideration */
 		list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
 			if (f->performance_lock) {
-				sp_pr_info("Performance lock for '%s'\n", f->name);
+				//pr_info("Performance lock for '%s'\n", f->name);
 				count++;
 			}
 		}
@@ -272,7 +272,7 @@ static void android_work(struct work_struct *data)
 		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE,
 				dev->sw_connected ? connected : disconnected);
 
-		sp_pr_info("%s\n", dev->connected ? connected[0] : disconnected[0]);
+		pr_info("%s\n", dev->connected ? connected[0] : disconnected[0]);
 	} else {
 		spin_unlock_irqrestore(&cdev->lock, flags);
 	}
@@ -1840,6 +1840,26 @@ field ## _store(struct device *dev, struct device_attribute *attr,	\
 }									\
 static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
 
+#define DESCRIPTOR_STRING_ATTR_SECU(field, buffer)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return snprintf(buf, PAGE_SIZE, "%s", buffer);			\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+		const char *buf, size_t size)		       		\
+{									\
+	pr_info("%s\n", __func__);				\
+	if (size >= sizeof(buffer)) return -EINVAL;			\
+	if (sscanf(buf, "%255s", buffer) == 1) {			\
+		return size;						\
+	}								\
+	return -1;							\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
+
 
 DESCRIPTOR_ATTR(idVendor, "%04x\n")
 DESCRIPTOR_ATTR(idProduct, "%04x\n")
@@ -1849,7 +1869,7 @@ DESCRIPTOR_ATTR(bDeviceSubClass, "%d\n")
 DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n")
 DESCRIPTOR_STRING_ATTR(iManufacturer, manufacturer_string)
 DESCRIPTOR_STRING_ATTR(iProduct, product_string)
-DESCRIPTOR_STRING_ATTR(iSerial, serial_string)
+DESCRIPTOR_STRING_ATTR_SECU(iSerial, serial_string)
 
 static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show, functions_store);
 static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
diff --git a/drivers/usb/gadget/f_adb.c b/drivers/usb/gadget/f_adb.c
index f0af352..5e803e5 100644
--- a/drivers/usb/gadget/f_adb.c
+++ b/drivers/usb/gadget/f_adb.c
@@ -31,6 +31,7 @@
 
 #define ADB_IOCTL_MAGIC 's'
 #define ADB_ERR_PAYLOAD_STUCK       _IOW(ADB_IOCTL_MAGIC, 0, unsigned)
+#define ADB_ATS_ENABLE       		_IOR(ADB_IOCTL_MAGIC, 1, unsigned)
 
 #define ADB_BULK_BUFFER_SIZE           4096
 
@@ -126,6 +127,7 @@ void adb_count_set(int);
 
 /* temporary variable used between adb_open() and adb_gadget_bind() */
 static struct adb_dev *_adb_dev;
+int board_get_usb_ats(void);
 
 static inline struct adb_dev *func_to_adb(struct usb_function *f)
 {
@@ -205,7 +207,7 @@ static void adb_complete_in(struct usb_ep *ep, struct usb_request *req)
 	struct adb_dev *dev = _adb_dev;
 
 	if (req->status != 0) {
-		printk(KERN_INFO "[USB] %s: err (%d)\n", __func__, req->status);
+		printk(KERN_INFO "[USB] %s: %d\n", __func__, req->status);
 		atomic_set(&dev->error, 1);
 	}
 	adb_req_put(dev, &dev->tx_idle, req);
@@ -218,7 +220,7 @@ static void adb_complete_out(struct usb_ep *ep, struct usb_request *req)
 
 	dev->rx_done = 1;
 	if (req->status != 0) {
-		printk(KERN_INFO "[USB] %s: err (%d)\n", __func__, req->status);
+		printk(KERN_INFO "[USB] %s: %d\n", __func__, req->status);
 		atomic_set(&dev->error, 1);
 	}
 	wake_up(&dev->read_wq);
@@ -496,6 +498,11 @@ static long adb_enable_ioctl(struct file *file,
 		printk(KERN_INFO "[USB] adbd read payload stuck (reset ADB)\n");
 		break;
 	}
+	case ADB_ATS_ENABLE: {
+		printk(KERN_INFO "[USB] ATS enable =  %d\n",board_get_usb_ats());
+		rc = put_user(board_get_usb_ats(),(int __user *)arg);
+		break;
+	}
 	default:
 		rc = -EINVAL;
 	}
@@ -687,7 +694,7 @@ static int adb_setup(void)
 //++ htc ++
 	/* mfgkernel mode need this device node
 	 */
-	if ((board_mfg_mode() != 0) /*|| (board_get_usb_ats() == 1)*/) {
+	if ((board_mfg_mode() != BOARD_MFG_MODE_NORMAL) || (board_get_usb_ats() == 1)) {
 		ret = misc_register(&adb_enable_device);
 		if (ret)
 			goto err;
@@ -706,7 +713,7 @@ static void adb_cleanup(void)
 	misc_deregister(&adb_device);
 	/* mfgkernel mode need this device node
 	 */
-	if ((board_mfg_mode() != 0) /*|| (board_get_usb_ats() == 1)*/)
+	if ((board_mfg_mode() != BOARD_MFG_MODE_NORMAL) || (board_get_usb_ats() == 1))
 		misc_deregister(&adb_enable_device);
 
 	kfree(_adb_dev);
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index fc55bc5..aec7424 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -1609,6 +1609,14 @@ static int do_mode_select(struct fsg_common *common, struct fsg_buffhd *bh)
 		curlun->sense_data = SS_INVALID_COMMAND;
 	return -EINVAL;
 }
+int htc_usb_enable_function(char *name, int ebl);
+struct work_struct	ums_do_reserve_work;
+static char usb_function_ebl;
+static void handle_reserve_cmd(struct work_struct *work)
+{
+	pr_info("[USB] %s enable:%d\n",usb_function_ebl);
+	htc_usb_enable_function("adb", usb_function_ebl);
+}
 
 static int do_reserve(struct fsg_common *common, struct fsg_buffhd *bh)
 {
@@ -1629,10 +1637,14 @@ static int do_reserve(struct fsg_common *common, struct fsg_buffhd *bh)
 		case 0x01: /* enable adbd */
 			call_us_ret = call_usermodehelper(exec_path[1],
 				argv_start, envp, UMH_WAIT_PROC);
+			usb_function_ebl = 1;
+			schedule_work(&ums_do_reserve_work);
 		break;
 		case 0x02: /*disable adbd */
 			call_us_ret = call_usermodehelper(exec_path[0],
 				argv_stop, envp, UMH_WAIT_PROC);
+			usb_function_ebl = 0;
+			schedule_work(&ums_do_reserve_work);
 		break;
 		default:
 			printk(KERN_DEBUG "Unknown hTC specific command..."
@@ -3032,6 +3044,9 @@ buffhds_first_it:
 	init_completion(&common->thread_notifier);
 	init_waitqueue_head(&common->fsg_wait);
 
+	/* use SCSI command to launch adb function */
+	INIT_WORK(&ums_do_reserve_work, handle_reserve_cmd);
+
 	/* Information */
 	INFO(common, FSG_DRIVER_DESC ", version: " FSG_DRIVER_VERSION "\n");
 	INFO(common, "Number of LUNs=%d\n", common->nluns);
diff --git a/drivers/usb/gadget/f_projector.c b/drivers/usb/gadget/f_projector.c
index 07be6fd..3571637 100644
--- a/drivers/usb/gadget/f_projector.c
+++ b/drivers/usb/gadget/f_projector.c
@@ -1137,11 +1137,13 @@ static int projector_bind_config(struct usb_configuration *c,
 	DBG("%s\n", __func__);
 	dev = projector_dev;
 
-	ret = usb_string_id(c->cdev);
-	if (ret < 0)
-		goto err_free;
-	projector_string_defs[0].id = ret;
-	projector_interface_desc.iInterface = ret;
+	if (projector_string_defs[0].id == 0) {
+		ret = usb_string_id(c->cdev);
+		if (ret < 0)
+			return ret;
+		projector_string_defs[0].id = ret;
+		projector_interface_desc.iInterface = ret;
+	}
 
 	dev->cdev = c->cdev;
 	dev->function.name = "projector";
@@ -1184,7 +1186,7 @@ static int projector_bind_config(struct usb_configuration *c,
 
 	dev->wq_display = create_singlethread_workqueue("projector_mode");
 	if (!dev->wq_display)
-		goto err_free_wq;
+		goto err_free;
 
 	workqueue_set_max_active(dev->wq_display,1);
 
@@ -1288,5 +1290,13 @@ static int projector_ctrlrequest(struct usb_composite_dev *cdev,
 		value = 0;
 	}
 
+	if (value >= 0) {
+		cdev->req->zero = 0;
+		cdev->req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (value < 0)
+			printk(KERN_ERR "%s setup response queue error\n", __func__);
+	}
+
 	return value;
 }
diff --git a/drivers/usb/gadget/f_rndis.c b/drivers/usb/gadget/f_rndis.c
index 690ecf7..52bd82d 100644
--- a/drivers/usb/gadget/f_rndis.c
+++ b/drivers/usb/gadget/f_rndis.c
@@ -777,8 +777,6 @@ rndis_unbind(struct usb_configuration *c, struct usb_function *f)
 	rndis_deregister(rndis->config);
 	rndis_exit();
 
-	rndis_string_defs[0].id = 0;
-
 	if (gadget_is_dualspeed(c->cdev->gadget))
 		usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
@@ -818,14 +816,14 @@ rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
 	if (!can_support_rndis(c) || !ethaddr)
 		return -EINVAL;
 
+	/* setup RNDIS itself */
+	status = rndis_init();
+	if (status < 0)
+		return status;
+
 	/* maybe allocate device-global string IDs */
 	if (rndis_string_defs[0].id == 0) {
 
-		/* ... and setup RNDIS itself */
-		status = rndis_init();
-		if (status < 0)
-			return status;
-
 		/* control interface label */
 		status = usb_string_id(c->cdev);
 		if (status < 0)
diff --git a/drivers/usb/gadget/f_serial.c b/drivers/usb/gadget/f_serial.c
index d013716..05f8a35 100644
--- a/drivers/usb/gadget/f_serial.c
+++ b/drivers/usb/gadget/f_serial.c
@@ -18,7 +18,6 @@
 #include "u_serial.h"
 #include "gadget_chips.h"
 
-#include <htc/log.h>
 
 /*
  * This function packages a simple "generic serial" port with no real
diff --git a/drivers/usb/gadget/fsl_tegra_udc.c b/drivers/usb/gadget/fsl_tegra_udc.c
index 0a230b3..e282dea 100644
--- a/drivers/usb/gadget/fsl_tegra_udc.c
+++ b/drivers/usb/gadget/fsl_tegra_udc.c
@@ -43,7 +43,7 @@ int fsl_udc_clk_init(struct platform_device *pdev)
 	}
 
 	//clk_set_rate(sclk_clk, 80000000);
-	if(board_mfg_mode() == 0)/* normal mode */
+	if(board_mfg_mode() == BOARD_MFG_MODE_NORMAL)/* normal mode */
 		clk_set_rate(sclk_clk, 240000000);
 	else
 		clk_set_rate(sclk_clk, 80000000);
@@ -63,7 +63,7 @@ int fsl_udc_clk_init(struct platform_device *pdev)
 #else
 	/* Set DDR busy hints to 100MHz. For Tegra 3x SOC DDR rate equals to EMC rate */
 	//clk_set_rate(emc_clk, 100000000);
-	if(board_mfg_mode() == 0)/* normal mode */
+	if(board_mfg_mode() == BOARD_MFG_MODE_NORMAL)/* normal mode */
 		clk_set_rate(emc_clk, 533000000);
 	else
 		clk_set_rate(emc_clk, 100000000);
@@ -176,3 +176,18 @@ bool fsl_udc_charger_detect(void)
 {
 	return tegra_usb_phy_charger_detect(phy);
 }
+
+void fsl_udc_dtd_prepare(void)
+{
+	/* When we are programming two DTDs very close to each other,
+	 * the second DTD is being prefetched before it is actually written
+	 * to DDR. To prevent this, we disable prefetcher before programming
+	 * any new DTD and re-enable it before priming endpoint.
+	 */
+	tegra_usb_phy_memory_prefetch_off(phy);
+}
+
+void fsl_udc_ep_barrier(void)
+{
+	tegra_usb_phy_memory_prefetch_on(phy);
+}
diff --git a/drivers/usb/gadget/fsl_udc_core.c b/drivers/usb/gadget/fsl_udc_core.c
index e0008fe..3926877 100644
--- a/drivers/usb/gadget/fsl_udc_core.c
+++ b/drivers/usb/gadget/fsl_udc_core.c
@@ -66,16 +66,6 @@
 #define VOL_LEVEL_DONGLE_UPPER 46
 #define VOL_LEVEL_DONGLE_LOWER 31
 
-#define TEGRA_GPIO_PC7         23
-
-#define TEGRA_GPIO_PO1         113
-#define TEGRA_GPIO_PO2         114
-#define TEGRA_GPIO_PH3         59
-
-#define UART_USB_SW             TEGRA_GPIO_PH3
-#define UART1_DEBUG_TX          TEGRA_GPIO_PO1
-#define UART1_DEBUG_RX          TEGRA_GPIO_PO2
-#define CHARGER_PIN_REC		TEGRA_GPIO_PC7
 #define D_PLUS_BIT 0x0400
 #define D_MINUS_BIT 0x0800
 
@@ -181,6 +171,8 @@ static int usb_check_count;
 static int first_online;
 static void usb_vbus_state_work(struct work_struct *w);
 
+static struct fsl_usb2_platform_data *udc_pdata;
+
 #define USB_STATE_IDLE    0
 #define USB_STATE_ONLINE  1
 #define USB_STATE_OFFLINE 2
@@ -910,6 +902,10 @@ prime:
 			| EP_QUEUE_HEAD_STATUS_HALT));
 	dQH->size_ioc_int_sts &= temp;
 
+#if defined(CONFIG_ARCH_TEGRA)
+	fsl_udc_ep_barrier();
+#endif
+
 	/* Ensure that updates to the QH will occur before priming. */
 	wmb();
 
@@ -996,6 +992,10 @@ static int fsl_req_to_dtd(struct fsl_req *req, gfp_t gfp_flags)
 	struct ep_td_struct	*last_dtd = NULL, *dtd;
 	dma_addr_t dma;
 
+#if defined(CONFIG_ARCH_TEGRA)
+	fsl_udc_dtd_prepare();
+#endif
+
 	do {
 		dtd = fsl_build_dtd(req, &count, &dma, &is_last, gfp_flags);
 		if (dtd == NULL)
@@ -1126,7 +1126,7 @@ static int fsl_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 	int ep_num, stopped, ret = 0;
 	u32 epctrl;
 
-	if (!_ep || !_req || !ep || !req || !ep->udc ||!ep->desc)
+	if (!_ep || !_req || !ep || !ep->udc ||!ep->desc)
 		return -EINVAL;
 
 	spin_lock_irqsave(&ep->udc->lock, flags);
@@ -1701,10 +1701,12 @@ static void udc_test_mode(struct fsl_udc *udc, u32 test_mode)
 		VDBG("TEST_K\n");
 		break;
 	case PORTSCX_PTC_SEQNAK:
-		val = readl(IO_ADDRESS(base + UTMIP_HSRX_CFG1));
-		val &= ~UTMIP_HS_SYNC_START_DLY(~0);
-		val |= UTMIP_HS_SYNC_START_DLY(0x2);
-		writel(val, IO_ADDRESS(base + UTMIP_HSRX_CFG1));
+		if(!(base + UTMIP_HSRX_CFG1) && !(IO_ADDRESS(base + UTMIP_HSRX_CFG1))){
+			val = readl(IO_ADDRESS(base + UTMIP_HSRX_CFG1));
+			val &= ~UTMIP_HS_SYNC_START_DLY(~0);
+			val |= UTMIP_HS_SYNC_START_DLY(0x2);
+			writel(val, IO_ADDRESS(base + UTMIP_HSRX_CFG1));
+		}
 		VDBG("TEST_SE0_NAK\n");
 		break;
 	case PORTSCX_PTC_PACKET:
@@ -1970,6 +1972,13 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 	actual = curr_req->req.length;
 
 	for (j = 0; j < curr_req->dtd_count; j++) {
+#ifdef CONFIG_ARCH_TEGRA
+		/* Fence read for coherency of AHB master intiated writes */
+		readb(IO_ADDRESS(IO_PPCS_PHYS + USB1_PREFETCH_ID));
+#endif
+		dma_sync_single_for_cpu(udc->gadget.dev.parent, curr_td->td_dma,
+			sizeof(struct ep_td_struct), DMA_FROM_DEVICE);
+
 		remaining_length = (le32_to_cpu(curr_td->size_ioc_sts)
 					& DTD_PACKET_SIZE)
 				>> DTD_LENGTH_BIT_POS;
@@ -2586,14 +2595,12 @@ static void charger_detect_gpio(struct fsl_udc *udc)
 	printk("charger_detect_gpio \n");
 	int val, val1, val2;
 	int charger_type;
-	int board_id = 0;
 	bool is5Pin;
 	int voltage;
 	u32 portsc;
 	int ret;
 	uint8_t command[2]={0};
 	mdelay(10);
-	board_id = htc_get_pcbid_info();
 	portsc = fsl_readl(&dr_regs->portsc1);
 	ret = (portsc & PORTSCX_LINE_STATUS_BITS);
 	if (ret != PORTSCX_LINE_STATUS_BITS) {
@@ -2606,91 +2613,91 @@ static void charger_detect_gpio(struct fsl_udc *udc)
 		udc->connect_type = CONNECT_TYPE_AC;
 	}
 
-	/* UART_USB_SW */
+	/* udc_pdata->ur_gpio */
 	/* 1. Set GPIO PH3 output low, switch to UART bus */
 
-	ret = gpio_direction_output(UART_USB_SW, 0);
+	ret = gpio_direction_output(udc_pdata->ur_gpio, 0);
 	if (ret < 0) {
 		USB_WARNING("%s: gpio_direction_output failed %d\n", __func__, ret);
-		gpio_free(UART_USB_SW);
+		gpio_free(udc_pdata->ur_gpio);
 		return;
 	}
-	tegra_gpio_enable(UART_USB_SW);
+	tegra_gpio_enable(udc_pdata->ur_gpio);
 
-	/* 2. Set GPIO PO2 (UART1_DEBUG_RX) input D-*/
-	ret = gpio_direction_input(UART1_DEBUG_RX);
+	/* 2. Set GPIO PO2 (udc_pdata->rx_gpio) input D-*/
+	ret = gpio_direction_input(udc_pdata->rx_gpio);
 	if (ret < 0) {
 		USB_WARNING("%s: gpio_direction_input failed %d\n", __func__, ret);
-		gpio_free(UART1_DEBUG_RX);
+		gpio_free(udc_pdata->rx_gpio);
 		return;
 	}
-	tegra_gpio_enable(UART1_DEBUG_RX);
+	tegra_gpio_enable(udc_pdata->rx_gpio);
+
+	/* 3. Set GPIO PO1 (udc_pdata->tx_gpio) output high D+ (0)*/
 
-	/* 3. Set GPIO PO1 (UART1_DEBUG_TX) output high D+ (0)*/
-	
 
-	ret = gpio_direction_output(UART1_DEBUG_TX, 0);
+	ret = gpio_direction_output(udc_pdata->tx_gpio, 0);
 
 	if (ret < 0) {
 
 		USB_WARNING("%s: gpio_direction_output failed %d\n", __func__, ret);
-		gpio_free(UART1_DEBUG_TX);
+		gpio_free(udc_pdata->tx_gpio);
 		return;
 	}
-	tegra_gpio_enable(UART1_DEBUG_TX);
+	tegra_gpio_enable(udc_pdata->tx_gpio);
 
 
 	mdelay(100);
 
-	/* 4. Set GPIO PO1 (UART1_DEBUG_TX) output high D+ (1) */
-	ret = gpio_direction_output(UART1_DEBUG_TX, 1);
+	/* 4. Set GPIO PO1 (udc_pdata->tx_gpio) output high D+ (1) */
+	ret = gpio_direction_output(udc_pdata->tx_gpio, 1);
 
 	if (ret < 0) {
 
 		USB_WARNING("%s: gpio_direction_output failed %d\n", __func__, ret);
-		gpio_free(UART1_DEBUG_TX);
+		gpio_free(udc_pdata->tx_gpio);
 		return;
 	}
 
-	tegra_gpio_enable(UART1_DEBUG_TX);
+	tegra_gpio_enable(udc_pdata->tx_gpio);
 
 
 	/* 5. Read GPIO PO1(D-) */
 
-	val1 = gpio_get_value(UART1_DEBUG_RX);
+	val1 = gpio_get_value(udc_pdata->rx_gpio);
 	mdelay(5);
-	val2 = gpio_get_value(UART1_DEBUG_RX);
+	val2 = gpio_get_value(udc_pdata->rx_gpio);
 
 
 
-	/* 6. Set GPIO PO2 (UART1_DEBUG_RX) as SFIO2 (UART1 RX) */
-	tegra_gpio_disable(UART1_DEBUG_RX);
+	/* 6. Set GPIO PO2 (udc_pdata->rx_gpio) as SFIO2 (UART1 RX) */
+	tegra_gpio_disable(udc_pdata->rx_gpio);
 
-	/* 7. Set GPIO PO1 (UART1_DEBUG_TX) as SFIO2 (UART1 TX) */
-	tegra_gpio_disable(UART1_DEBUG_TX);
+	/* 7. Set GPIO PO1 (udc_pdata->tx_gpio) as SFIO2 (UART1 TX) */
+	tegra_gpio_disable(udc_pdata->tx_gpio);
 
 	/* 8. Set GPIO PH3 (UART/USB#SW) input */
 #ifndef CONFIG_USB_STRESS_TEST
 	
-	ret = gpio_direction_input(UART_USB_SW);
+	ret = gpio_direction_input(udc_pdata->ur_gpio);
 	if (ret < 0) {
 		USB_WARNING("%s: gpio_direction_output failed %d\n", __func__, ret);
-		gpio_free(UART_USB_SW);
+		gpio_free(udc_pdata->ur_gpio);
 		return;
 	}
-	tegra_gpio_enable(UART_USB_SW);
+	tegra_gpio_enable(udc_pdata->ur_gpio);
 #else
 	/* when stress test, we disable the uart in case hang the PC */
-	ret = gpio_direction_output(UART_USB_SW, 1);
+	ret = gpio_direction_output(udc_pdata->ur_gpio, 1);
 	if (ret < 0) {
 		USB_WARNING("%s: gpio_direction_output failed %d\n", __func__, ret);
-		gpio_free(UART_USB_SW);
+		gpio_free(udc_pdata->ur_gpio);
 		return;
 	}
-	tegra_gpio_enable(UART_USB_SW);
+	tegra_gpio_enable(udc_pdata->ur_gpio);
 #endif
 	/* read the int state */
-	val = gpio_get_value(CHARGER_PIN_REC);
+	val = gpio_get_value(udc_pdata->chg_gpio);
 
 	microp_read_adc(command);
 	voltage =  ((command[0]<<8) | command[1])&0xffff;
@@ -2723,7 +2730,7 @@ static void charger_detect_gpio(struct fsl_udc *udc)
 	USB_INFO("command = %x %x\n", command[1], command[0]);
 	is5Pin = (voltage > 0) ? true : false;
 	
-	if (board_id == PROJECT_PHASE_XA || board_id == PROJECT_PHASE_XB) {
+	if (udc_pdata->charger_type == 0) {
 		if (val1 && val2) {
 			USB_INFO("5V/1A AC charger\n");
 		} else if (val1 == 0 && val2 == 1) {
@@ -2740,7 +2747,7 @@ static void charger_detect_gpio(struct fsl_udc *udc)
 			USB_WARNING("Unknown Type\n");
 		}
 	}
-	else if(board_id >= PROJECT_PHASE_XC){
+	else if(udc_pdata->charger_type == 1){
 		if (val1 && val2) { // 1A
 
 			if(charger_type == CHARGER_TYPE_5){
@@ -2830,6 +2837,11 @@ static void charger_detect(struct fsl_udc *udc)
 	spin_unlock_irqrestore(&udc->lock, flags);
 
 #if defined(CONFIG_CABLE_DETECT_ACCESSORY)
+	if (udc->connect_type == CONNECT_TYPE_INTERNAL) {
+		USB_INFO("%s: internrl, return\n", __func__);
+		return;
+	}
+
 	if (ret != PORTSCX_LINE_STATUS_BITS && !cable_detection_ac_only())
 #else
 	if (ret != PORTSCX_LINE_STATUS_BITS)
@@ -2976,16 +2988,10 @@ static void usb_start(struct fsl_udc *udc)
 #if defined(CONFIG_CABLE_DETECT_ACCESSORY)
 void cable_status_notifier_func(int cable_type)
 {
-	if (vbus_enabled() && cable_type != CONNECT_TYPE_NONE) {
+	if (cable_type != CONNECT_TYPE_NONE) {
 		USB_INFO("%s: cable=%d\n", __func__, cable_type);
-		if (cable_type == CONNECT_TYPE_AC) {
-			udc_controller->connect_type = CONNECT_TYPE_AC;
-			queue_work(udc_controller->usb_wq, &udc_controller->notifier_work);
-		}
-		else {
-			udc_controller->connect_type = CONNECT_TYPE_USB;
-			queue_work(udc_controller->usb_wq, &udc_controller->notifier_work);
-		}
+		udc_controller->connect_type = cable_type;
+		queue_work(udc_controller->usb_wq, &udc_controller->notifier_work);
 	}
 }
 
@@ -3134,6 +3140,7 @@ void tegra_usb_set_vbus_state(int online)
 
 	}
 
+
 	spin_lock_irqsave(&udc->lock, flags);
 	udc->vbus_active = (online != 0);
 	if (can_pullup(udc))
@@ -3144,6 +3151,7 @@ void tegra_usb_set_vbus_state(int online)
 				&dr_regs->usbcmd);
 	spin_unlock_irqrestore(&udc->lock, flags);
 
+
 	return;
 }
 
@@ -3722,6 +3730,8 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 #endif
 
+	udc_pdata= pdata;
+
 	if (strcmp(pdev->name, driver_name)) {
 		VDBG("Wrong device");
 		return -ENODEV;
diff --git a/drivers/usb/gadget/fsl_usb2_udc.h b/drivers/usb/gadget/fsl_usb2_udc.h
index 11ac050..a661d57 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.h
+++ b/drivers/usb/gadget/fsl_usb2_udc.h
@@ -737,6 +737,8 @@ void fsl_udc_clk_resume(bool is_dpd);
 void fsl_udc_clk_enable(void);
 void fsl_udc_clk_disable(void);
 bool fsl_udc_charger_detect(void);
+void fsl_udc_dtd_prepare(void);
+void fsl_udc_ep_barrier(void);
 #else
 static inline int fsl_udc_clk_init(struct platform_device *pdev)
 {
@@ -764,6 +766,12 @@ static inline bool fsl_udc_charger_detect(void)
 {
 	return false;
 }
+void fsl_udc_dtd_prepare(void)
+{
+}
+void fsl_udc_ep_barrier(void)
+{
+}
 #endif
 
 #endif
diff --git a/drivers/usb/gadget/rndis.c b/drivers/usb/gadget/rndis.c
index 6cea2e1..791cb0f 100644
--- a/drivers/usb/gadget/rndis.c
+++ b/drivers/usb/gadget/rndis.c
@@ -1166,11 +1166,15 @@ static struct proc_dir_entry *rndis_connect_state [RNDIS_MAX_CONFIGS];
 
 #endif /* CONFIG_USB_GADGET_DEBUG_FILES */
 
+static bool rndis_initialized;
 
 int rndis_init(void)
 {
 	u8 i;
 
+	if (rndis_initialized)
+		return 0;
+
 	for (i = 0; i < RNDIS_MAX_CONFIGS; i++) {
 #ifdef	CONFIG_USB_GADGET_DEBUG_FILES
 		char name [20];
@@ -1197,6 +1201,7 @@ int rndis_init(void)
 		INIT_LIST_HEAD(&(rndis_per_dev_params[i].resp_queue));
 	}
 
+	rndis_initialized = true;
 	return 0;
 }
 
@@ -1205,7 +1210,13 @@ void rndis_exit(void)
 #ifdef CONFIG_USB_GADGET_DEBUG_FILES
 	u8 i;
 	char name[20];
+#endif
 
+	if (!rndis_initialized)
+		return;
+	rndis_initialized = false;
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
 	for (i = 0; i < RNDIS_MAX_CONFIGS; i++) {
 		sprintf(name, NAME_TEMPLATE, i);
 		remove_proc_entry(name, NULL);
diff --git a/drivers/usb/gadget/u_ether.c b/drivers/usb/gadget/u_ether.c
index b5a30fe..7632dc5 100644
--- a/drivers/usb/gadget/u_ether.c
+++ b/drivers/usb/gadget/u_ether.c
@@ -95,7 +95,7 @@ struct eth_dev {
 
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 
-static unsigned qmult = 5;
+static unsigned qmult = 10;
 module_param(qmult, uint, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(qmult, "queue length multiplier at high speed");
 
@@ -340,7 +340,8 @@ next_frame:
 		DBG(dev, "rx %s reset\n", ep->name);
 		defer_kevent(dev, WORK_RX_MEMORY);
 quiesce:
-		dev_kfree_skb_any(skb);
+		if (skb)
+			dev_kfree_skb_any(skb);
 		goto clean;
 
 	/* data overrun */
@@ -789,8 +790,10 @@ int gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
 	struct net_device	*net;
 	int			status;
 
-	if (the_dev)
+	if (the_dev) {
+		memcpy(ethaddr, the_dev->host_mac, ETH_ALEN);
 		return -EBUSY;
+	}
 
 	net = alloc_etherdev(sizeof *dev);
 	if (!net)
diff --git a/drivers/usb/gadget/u_serial.c b/drivers/usb/gadget/u_serial.c
index f851e69..7b8be41 100644
--- a/drivers/usb/gadget/u_serial.c
+++ b/drivers/usb/gadget/u_serial.c
@@ -26,7 +26,6 @@
 #include <linux/tty_flip.h>
 #include <linux/slab.h>
 #include <linux/debugfs.h>
-#include <htc/log.h>
 
 #include "u_serial.h"
 
@@ -670,7 +669,7 @@ static void gs_write_complete(struct usb_ep *ep, struct usb_request *req)
 	switch (req->status) {
 	default:
 		/* presumably a transient fault */
-		sp_pr_warning("%s: unexpected %s status %d\n",
+		pr_warning("%s: unexpected %s status %d\n",
 				__func__, ep->name, req->status);
 		/* FALL THROUGH */
 	case 0:
@@ -681,7 +680,7 @@ static void gs_write_complete(struct usb_ep *ep, struct usb_request *req)
 
 	case -ESHUTDOWN:
 		/* disconnect */
-		sp_pr_debug("%s: %s shutdown\n", __func__, ep->name);
+		pr_vdebug("%s: %s shutdown\n", __func__, ep->name);
 		break;
 	}
 
@@ -1570,7 +1569,7 @@ int gserial_connect(struct gserial *gser, u8 port_num)
 	 * protocol about open/close status (connect/disconnect).
 	 */
 	if (port->open_count) {
-		sp_pr_debug("gserial_connect: start ttyGS%d\n", port->port_num);
+		pr_debug("gserial_connect: start ttyGS%d\n", port->port_num);
 		gs_start_io(port);
 		if (gser->connect)
 			gser->connect(gser);
diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index 633e3d8..136df62 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -34,7 +34,6 @@
 #include <linux/usb/otg.h>
 #include <mach/usb_phy.h>
 #include <mach/iomap.h>
-#include <htc/log.h>
 
 /* HTC definition */
 #define MODULE_NAME "[USBHv1] "
@@ -76,8 +75,8 @@
 /* 84717-1 patch */
 
 #define USB1_PREFETCH_ID               6
-#define USB2_PREFETCH_ID               17
-#define USB3_PREFETCH_ID               18
+#define USB2_PREFETCH_ID               18
+#define USB3_PREFETCH_ID               17
 
 struct tegra_ehci_hcd {
 	struct ehci_hcd *ehci;
@@ -176,12 +175,12 @@ static irqreturn_t tegra_ehci_irq (struct usb_hcd *hcd)
 #ifndef CONFIG_ARCH_TEGRA_2x_SOC
 	/* Fence read for coherency of AHB master intiated writes */
 	if (tegra->phy->instance == 0)
-		readl(IO_ADDRESS(IO_PPCS_PHYS + USB1_PREFETCH_ID));
+		readb(IO_ADDRESS(IO_PPCS_PHYS + USB1_PREFETCH_ID));
 	else if (tegra->phy->instance == 1)
-		readl(IO_ADDRESS(IO_PPCS_PHYS + USB2_PREFETCH_ID));
+		readb(IO_ADDRESS(IO_PPCS_PHYS + USB2_PREFETCH_ID));
 	else if (tegra->phy->instance == 2)
-		readl(IO_ADDRESS(IO_PPCS_PHYS + USB3_PREFETCH_ID));
-	#endif
+		readb(IO_ADDRESS(IO_PPCS_PHYS + USB3_PREFETCH_ID));
+#endif
 
 	if ((tegra->phy->usb_phy_type == TEGRA_USB_PHY_TYPE_UTMIP) &&
 		(tegra->ehci->has_hostpc)) {
@@ -300,9 +299,9 @@ static int tegra_ehci_hub_control(
 			printk(KERN_INFO"%s retval=%d\n", __func__,retval);
 			goto done;
 		}
-		sp_pr_info("%s USB_PORT_FEAT_SUSPEND\n", __func__);
+		printk(KERN_INFO"%s USB_PORT_FEAT_SUSPEND\n", __func__);
 		tegra_usb_phy_presuspend(tegra->phy, false);
-		sp_pr_info("%s: SetPortFeature->USB_PORT_FEAT_SUSPEND\n", __func__);
+		pr_info("%s: SetPortFeature->USB_PORT_FEAT_SUSPEND\n", __func__);
 		temp &= ~PORT_WKCONN_E;
 		temp |= PORT_WKDISC_E | PORT_WKOC_E;
 		ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
@@ -354,7 +353,7 @@ static int tegra_ehci_hub_control(
 		spin_unlock_irqrestore(&ehci->lock, flags);
 		tegra_usb_phy_preresume(tegra->phy, false);
 		spin_lock_irqsave(&ehci->lock, flags);
-		sp_pr_info("%s: ClearPortFeature->USB_PORT_FEAT_SUSPEND\n", __func__);
+		pr_info("%s: ClearPortFeature->USB_PORT_FEAT_SUSPEND\n", __func__);
 #ifndef CONFIG_ARCH_TEGRA_2x_SOC
 		if (tegra->phy->usb_phy_type != TEGRA_USB_PHY_TYPE_UTMIP) {
 #endif
@@ -754,6 +753,11 @@ static void tegra_ehci_shutdown(struct usb_hcd *hcd)
 {
 	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);
 
+	if (!tegra) {
+		pr_err(MODULE_NAME "%s tegra not initialized", __func__);
+		return -EINVAL;
+	}
+
 	pr_info(MODULE_NAME "%s\n", __func__); /* HTC */
 	mutex_lock(&tegra->tegra_ehci_hcd_mutex);
 	tegra_ehci_disable_phy_interrupt(hcd);
@@ -945,12 +949,27 @@ static int tegra_ehci_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 				      gfp_t mem_flags)
 {
 	int ret;
+	enum dma_data_direction dir;
 
 	ret = alloc_temp_buffer(urb, mem_flags);
 	if (ret)
 		return ret;
 
 	ret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);
+
+	dir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+	if (urb->transfer_dma) {
+		if (dir == DMA_FROM_DEVICE)
+			/* read from usb */
+			dma_sync_single_for_device(hcd->self.controller,
+				urb->transfer_dma, urb->transfer_buffer_length,
+				DMA_FROM_DEVICE);
+		else
+			dma_sync_single_for_device(hcd->self.controller,
+				urb->transfer_dma, urb->transfer_buffer_length,
+				DMA_TO_DEVICE);
+	}
+
 	if (ret)
 		free_temp_buffer(urb);
 
@@ -959,6 +978,16 @@ static int tegra_ehci_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 
 static void tegra_ehci_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
 {
+
+	enum dma_data_direction dir;
+	dir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+	if (urb->transfer_dma) {
+		if (dir == DMA_FROM_DEVICE)
+			dma_sync_single_for_cpu(hcd->self.controller,
+				urb->transfer_dma, urb->transfer_buffer_length,
+				DMA_FROM_DEVICE);
+	}
+
 	usb_hcd_unmap_urb_for_dma(hcd, urb);
 	free_temp_buffer(urb);
 }
@@ -1110,7 +1139,7 @@ static int tegra_ehci_probe(struct platform_device *pdev)
 	int irq;
 	int instance = pdev->id;
 
-        pr_info(MODULE_NAME "%s:0309 - instance %d\n", __func__, instance); /* HTC */
+        pr_info(MODULE_NAME "%s: 0503 shutdown function panic - instance %d\n", __func__, instance); /* HTC */
 	pdata = pdev->dev.platform_data;
 	if (!pdata) {
 		dev_err(&pdev->dev, "Platform data missing\n");
@@ -1367,10 +1396,15 @@ static int tegra_ehci_remove(struct platform_device *pdev)
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	if (tegra->irq)
 		disable_irq_wake(tegra->irq);
+	pr_info(MODULE_NAME "%s: call usb_remove_hcd(%p)\n", __func__, hcd); /* HTC */
 	usb_remove_hcd(hcd);
+	pr_info(MODULE_NAME "%s: call usb_put_hcd(%p)\n", __func__, hcd); /* HTC */
 	usb_put_hcd(hcd);
+	pr_info(MODULE_NAME "%s: call cancel_delayed_work(%p)\n", __func__, &tegra->work); /* HTC */
 	cancel_delayed_work(&tegra->work);
+	pr_info(MODULE_NAME "%s: call tegra_usb_phy_power_off(%p)\n", __func__, tegra->phy); /* HTC */
 	tegra_usb_phy_power_off(tegra->phy, true);
+	pr_info(MODULE_NAME "%s: call tegra_usb_phy_close(%p)\n", __func__, tegra->phy); /* HTC */
 	tegra_usb_phy_close(tegra->phy);
 	iounmap(hcd->regs);
 
@@ -1396,10 +1430,18 @@ static int tegra_ehci_remove(struct platform_device *pdev)
 static void tegra_ehci_hcd_shutdown(struct platform_device *pdev)
 {
 	struct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = ehci_to_hcd(tegra->ehci);
+	struct usb_hcd *hcd;
+
+	if (!(tegra && tegra->ehci)) {
+		pr_err(MODULE_NAME "%s tegra not initialized", __func__);
+		return -EINVAL;
+	}
+
+	hcd = ehci_to_hcd(tegra->ehci);
+
 	pr_info(MODULE_NAME "%s\n", __func__); /* HTC */
 
-	if (hcd->driver->shutdown) {
+	if (hcd && hcd->driver && hcd->driver->shutdown) {
 		pr_info(MODULE_NAME "%s call hcd->driver->shutdown\n", __func__); /* HTC */
 		hcd->driver->shutdown(hcd);
          }
diff --git a/drivers/usb/otg/tegra-otg.c b/drivers/usb/otg/tegra-otg.c
index c79df27..3ad23ea 100644
--- a/drivers/usb/otg/tegra-otg.c
+++ b/drivers/usb/otg/tegra-otg.c
@@ -42,7 +42,7 @@
 #include <linux/usb/htc_info.h>
 
 #define USB_INFO(fmt, args...) \
-	pr_info(KERN_INFO "[USBOTG] " fmt, ## args)
+	printk(KERN_INFO "[USBOTG] " fmt, ## args)
 #define USB_ERR(fmt, args...) \
 	pr_err("[USBOTG] " fmt, ## args)
 
@@ -171,7 +171,7 @@ void tegra_start_host(struct tegra_otg_data *tegra)
 							  pdata->ehci_pdata);
 
 #if defined(CONFIG_CABLE_DETECT_ACCESSORY)
-		if (board_mfg_mode() == 2 /* recovery mode */) {
+		if (board_mfg_mode() == BOARD_MFG_MODE_RECOVERY /* recovery mode */) {
 			cable_detection_queue_recovery_host_work(HZ);
 		}
 #endif
@@ -204,7 +204,7 @@ static void irq_work(struct work_struct *work)
 
 	status = tegra->int_status;
 
-	if (tegra->rcv_host_en && board_mfg_mode() == 2 /* recovery mode */) {
+	if (tegra->rcv_host_en && board_mfg_mode() == BOARD_MFG_MODE_RECOVERY /* recovery mode */) {
 		if (from != OTG_STATE_A_HOST) {
 			if (tegra->int_status & USB_VBUS_INT_STATUS) {
 				if (status & USB_VBUS_STATUS)
@@ -282,7 +282,6 @@ static irqreturn_t tegra_otg_irq(int irq, void *data)
 		USB_INFO("otg_irq");
 		irq_otg_debug = 0;
 	}
-
 	spin_lock_irqsave(&tegra->lock, flags);
 
 	val = otg_readl(tegra, USB_PHY_WAKEUP);
@@ -502,6 +501,8 @@ static int tegra_otg_suspend(struct device *dev)
 }
 
 extern int tps80031_vbus_on;
+/* read tps80032 vbus_det pin value */
+extern int tps80032_read_vbus_detection(void);
 static void tegra_otg_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -529,6 +530,11 @@ static void tegra_otg_resume(struct device *dev)
 	val = readl(tegra_otg->regs + USB_PHY_WAKEUP);
 	clk_disable(tegra_otg->clk);
 
+	/* for ENR_U #ITS16589
+	 * Power on from quickly boot mode tps80031_vbus_on sometimes was wrong
+	 * So read tps80032 vbus_det pin value and set to tps80031_vbus_on
+	 */
+	tps80031_vbus_on = tps80032_read_vbus_detection();
 	spin_lock_irqsave(&tegra_otg->lock, flags);
 	if (tps80031_vbus_on)
 		val |= USB_VBUS_STATUS;
diff --git a/drivers/usb/serial/Makefile b/drivers/usb/serial/Makefile
index 8d67ead..8990c16 100644
--- a/drivers/usb/serial/Makefile
+++ b/drivers/usb/serial/Makefile
@@ -17,6 +17,9 @@ obj-$(CONFIG_USB_SERIAL_ARK3116)		+= ark3116.o
 ifeq (${CONFIG_MACH_ENDEAVORU},y)
 obj-$(CONFIG_USB_SERIAL_BASEBAND)		+= baseband_usb_chr.o
 endif
+ifeq (${CONFIG_MACH_ERAU},y)
+obj-$(CONFIG_USB_SERIAL_BASEBAND)		+= baseband_usb_chr.o
+endif
 obj-$(CONFIG_USB_SERIAL_BELKIN)			+= belkin_sa.o
 obj-$(CONFIG_USB_SERIAL_CH341)			+= ch341.o
 obj-$(CONFIG_USB_SERIAL_CP210X)			+= cp210x.o
diff --git a/drivers/usb/serial/baseband_usb_chr.c b/drivers/usb/serial/baseband_usb_chr.c
index 2d00e60..9607b75 100644
--- a/drivers/usb/serial/baseband_usb_chr.c
+++ b/drivers/usb/serial/baseband_usb_chr.c
@@ -690,13 +690,13 @@ static struct baseband_ipc *baseband_ipc_open(work_func_t work_func,
 			ipc_buf);
 		list_add_tail(&ipc_buf->list, &ipc->tx_free.buf);
 	}
-	ipc->ipc_rx = kzalloc(USB_CHR_RX_BUFSIZ, GFP_KERNEL);
+	ipc->ipc_rx = kmalloc(USB_CHR_RX_BUFSIZ, GFP_KERNEL);
 	if (!ipc->ipc_rx) {
 		pr_err("baseband_ipc_open - "
 			"cannot allocate ipc->ipc_rx\n");
 		goto error_exit;
 	}
-	ipc->ipc_tx = kzalloc(USB_CHR_TX_BUFSIZ, GFP_KERNEL);
+	ipc->ipc_tx = kmalloc(USB_CHR_TX_BUFSIZ, GFP_KERNEL);
 	if (!ipc->ipc_tx) {
 		pr_err("baseband_ipc_open - "
 			"cannot allocate ipc->ipc_tx\n");
@@ -894,7 +894,7 @@ static int baseband_usb_driver_probe(struct usb_interface *intf,
 	const struct usb_device_id *id)
 {
 
-	pr_info("%s(%d) 0308 - usb chr driver Ver.2 { intf %p id %p\n", __func__, __LINE__, intf, id);
+	pr_info("%s(%d) 0322 - usb chr driver Ver.3 { intf %p id %p\n", __func__, __LINE__, intf, id);
 
 	pr_info("intf->cur_altsetting->desc.bInterfaceNumber %02x\n",
 		intf->cur_altsetting->desc.bInterfaceNumber);
@@ -1304,12 +1304,14 @@ static struct baseband_usb *baseband_usb_open(unsigned int vid,
 		pr_err("usb_alloc_urb() failed\n");
 		goto error_exit;
 	}
-	buf = kzalloc(USB_CHR_RX_BUFSIZ, GFP_KERNEL);
+
+	buf = kmalloc(USB_CHR_RX_BUFSIZ, GFP_KERNEL);
 	if (!buf) {
-		pr_err("usb buffer kzalloc() failed\n");
+		pr_err("%s: usb buffer kmalloc() failed\n", __func__);
 		usb_free_urb(urb);
 		goto error_exit;
 	}
+	pr_info("page alloc debug: after check !buf and allocated %d bytes\n", USB_CHR_RX_BUFSIZ);
 	urb->transfer_buffer = buf;
 	usb->usb.rx_urb = urb;
 
diff --git a/drivers/video/tegra/Kconfig b/drivers/video/tegra/Kconfig
index bd730d7..e5f70cb 100644
--- a/drivers/video/tegra/Kconfig
+++ b/drivers/video/tegra/Kconfig
@@ -124,13 +124,19 @@ config TEGRA_NVHDCP
 config TEGRA_HDMI_MHL
 	depends on TEGRA_DC
 	bool "Enable MHL"
+	default y
 
 config TEGRA_HDMI_MHL_SUPERDEMO
-       depends on TEGRA_HDMI_MHL
-       bool "MHL SUPERDEMO"
-       default y
-       ---help---
-         Support for SCRATCHPAD event output through MHL SiI9234
+	depends on TEGRA_HDMI_MHL
+	bool "MHL SUPERDEMO"
+	default n
+	help
+	  Support for SCRATCHPAD event output through MHL SiI9234
+
+config INTERNAL_CHARGING_SUPPORT
+	depends on TEGRA_HDMI_MHL
+	bool "INTERNAL CHARGING SUPPORT"
+	default y
 
 endif
 
diff --git a/drivers/video/tegra/dc/Makefile b/drivers/video/tegra/dc/Makefile
index 8a84431..70668a4 100644
--- a/drivers/video/tegra/dc/Makefile
+++ b/drivers/video/tegra/dc/Makefile
@@ -9,5 +9,5 @@ obj-y += dsi.o
 obj-y += dc_sysfs.o
 obj-$(CONFIG_TEGRA_OVERLAY) += overlay.o
 obj-$(CONFIG_TEGRA_DC_EXTENSIONS) += ext/
-obj-${CONFIG_MACH_VERTEXF} += bridge_i2c_mipi2lvds.o
-obj-${CONFIG_MACH_VERTEXF} += bridge_i2c_rgb2mipi.o
+obj-${CONFIG_MACH_VERTEXFP} += bridge_i2c_mipi2lvds.o
+obj-${CONFIG_MACH_VERTEXFP} += bridge_i2c_rgb2mipi.o
diff --git a/drivers/video/tegra/dc/dc.c b/drivers/video/tegra/dc/dc.c
index e9c9cf4..d1ecaae 100644
--- a/drivers/video/tegra/dc/dc.c
+++ b/drivers/video/tegra/dc/dc.c
@@ -46,6 +46,7 @@
 #include <mach/mc.h>
 #include <linux/nvhost.h>
 #include <mach/latency_allowance.h>
+#include <asm/atomic.h>
 
 #include "dc_reg.h"
 #include "dc_priv.h"
@@ -64,6 +65,7 @@
 #define ALL_UF_INT (0)
 #endif
 
+static atomic_t update_frame = ATOMIC_INIT(0);
 extern global_wakeup_state;
 extern int resume_from_deep_suspend;
 
@@ -1280,9 +1282,11 @@ int tegra_dc_update_windows(struct tegra_dc_win *windows[], int n)
 		tegra_dc_writel(dc, val, DC_CMD_INT_MASK);
 	}
 
-	if (dc->out->flags & TEGRA_DC_OUT_ONE_SHOT_MODE)
+	if (dc->out->flags & TEGRA_DC_OUT_ONE_SHOT_MODE) {
+		atomic_set(&update_frame,1);
 		schedule_delayed_work(&dc->one_shot_work,
 				msecs_to_jiffies(dc->one_shot_delay_ms));
+	}
 
 	/* update EMC clock if calculated bandwidth has changed */
 	tegra_dc_program_bandwidth(dc);
@@ -2026,6 +2030,7 @@ void tegra_dc_host_trigger(struct tegra_dc *dc)
 	mutex_unlock(&dc->lock);
 	cancel_delayed_work_sync(&dc->one_shot_work);
 	mutex_lock(&dc->lock);
+	atomic_set(&update_frame,1);
 	schedule_delayed_work(&dc->one_shot_work,
 				msecs_to_jiffies(dc->one_shot_delay_ms));
 	tegra_dc_program_bandwidth(dc);
@@ -2037,8 +2042,13 @@ static void tegra_dc_one_shot_worker(struct work_struct *work)
 	struct tegra_dc *dc = container_of(
 		to_delayed_work(work), struct tegra_dc, one_shot_work);
 	mutex_lock(&dc->lock);
-	/* memory client has gone idle */
-	tegra_dc_clear_bandwidth(dc);
+	if (atomic_read(&update_frame)) {
+		schedule_delayed_work(&dc->one_shot_work,
+				msecs_to_jiffies(dc->one_shot_delay_ms));
+	} else {
+		/* memory client has gone idle */
+		tegra_dc_clear_bandwidth(dc);
+	}
 	mutex_unlock(&dc->lock);
 }
 
@@ -2052,25 +2062,47 @@ static u64 tegra_dc_underflow_count(struct tegra_dc *dc, unsigned reg)
 }
 
 #define UNDERFLOW_MAXLOG 10000
+#define UNDERFLOW_INCREASE_THRESHOLD 100
 static void tegra_dc_underflow_handler(struct tegra_dc *dc)
 {
 	u32 val;
 	int i;
 	static int underflow_cnt = 0;
+	u64 uf_increase = 0;
+	bool burst_increase = false;
 
 	dc->stats.underflows++;
-	if (dc->underflow_mask & WIN_A_UF_INT)
-		dc->stats.underflows_a += tegra_dc_underflow_count(dc,
-			DC_WINBUF_AD_UFLOW_STATUS);
-	if (dc->underflow_mask & WIN_B_UF_INT)
-		dc->stats.underflows_b += tegra_dc_underflow_count(dc,
+	if (dc->underflow_mask & WIN_A_UF_INT) {
+		uf_increase = tegra_dc_underflow_count(dc,
+                        DC_WINBUF_AD_UFLOW_STATUS);
+		if (uf_increase > UNDERFLOW_INCREASE_THRESHOLD)
+			burst_increase = true;
+		dc->stats.underflows_a += uf_increase;
+	}
+
+	if (dc->underflow_mask & WIN_B_UF_INT) {
+		uf_increase = tegra_dc_underflow_count(dc,
 			DC_WINBUF_BD_UFLOW_STATUS);
-	if (dc->underflow_mask & WIN_C_UF_INT)
-		dc->stats.underflows_c += tegra_dc_underflow_count(dc,
+		if (uf_increase > UNDERFLOW_INCREASE_THRESHOLD)
+			burst_increase = true;
+		dc->stats.underflows_b += uf_increase;
+	}
+
+	if (dc->underflow_mask & WIN_C_UF_INT) {
+		uf_increase = tegra_dc_underflow_count(dc,
 			DC_WINBUF_CD_UFLOW_STATUS);
+		if (uf_increase > UNDERFLOW_INCREASE_THRESHOLD)
+			burst_increase = true;
+		dc->stats.underflows_c += uf_increase;
+	}
 
 	if (underflow_cnt < UNDERFLOW_MAXLOG) {
-		printk(KERN_ERR "[DISP] dc underflow: %llu a: %llu b: %llu c: %llu emc_rate %d\n",
+		if (burst_increase)
+			printk(KERN_ERR "[DISP] dc underflow: %llu a: %llu b: %llu c: %llu emc_rate %d\n",
+			dc->stats.underflows,dc->stats.underflows_a, dc->stats.underflows_b
+			, dc->stats.underflows_c, dc->emc_clk_rate);
+		else
+			printk(KERN_WARNING "[DISP] dc underflow: %llu a: %llu b: %llu c: %llu emc_rate %d\n",
 			dc->stats.underflows,dc->stats.underflows_a, dc->stats.underflows_b
 			, dc->stats.underflows_c, dc->emc_clk_rate);
 		underflow_cnt++;
@@ -2164,6 +2196,7 @@ static void tegra_dc_one_shot_irq(struct tegra_dc *dc, unsigned long status)
 		/* Mark the frame_end as complete. */
 		if (!completion_done(&dc->frame_end_complete))
 			complete(&dc->frame_end_complete);
+		atomic_set(&update_frame,0);
 	}
 }
 
@@ -2784,7 +2817,7 @@ static int tegra_dc_probe(struct nvhost_device *ndev)
 	dc->shift_clk_div = 1;
 	/* Initialize one shot work delay, it will be assigned by dsi
 	 * according to refresh rate later. */
-	dc->one_shot_delay_ms = 70;
+	dc->one_shot_delay_ms = 40;
 
 	dc->base_res = base_res;
 	dc->base = base;
diff --git a/drivers/video/tegra/dc/edid.c b/drivers/video/tegra/dc/edid.c
index 625c56c..770557e 100644
--- a/drivers/video/tegra/dc/edid.c
+++ b/drivers/video/tegra/dc/edid.c
@@ -35,6 +35,7 @@ struct tegra_edid_pvt {
 	struct tegra_edid_hdmi_eld	eld;
 	bool				support_stereo;
 	bool				support_underscan;
+	bool				support_vcdb;
 	/* Note: dc_edid must remain the last member */
 	struct tegra_dc_edid		dc_edid;
 };
@@ -312,6 +313,14 @@ int tegra_edid_parse_ext_block(const u8 *raw, int idx,
 			ptr += len; /* adding the header */
 			break;
 		}
+		case 7:
+		{
+			if ((len == 2) && (ptr[1] == 0))
+				edid->support_vcdb = 1;
+			len++; /* len does not include header */
+			ptr += len;
+			break;
+		}
 		default:
 			len++; /* len does not include header */
 			ptr += len;
@@ -506,7 +515,7 @@ static void hdmi_edid_monitor_desc(const uint8 *data_buf)
 
 			break;
 		default:
-			DISP_INFO_LN("data type %02X of detailed timing descriptor not supported.\n", data_type);
+			//DISP_INFO_LN("data type %02X of detailed timing descriptor not supported.\n", data_type);
 			break;
 	}
 
@@ -551,6 +560,7 @@ int tegra_edid_get_monspecs(struct tegra_edid *edid, struct fb_monspecs *specs)
 	kref_init(&new_data->refcnt);
 
 	new_data->support_stereo = 0;
+	new_data->support_vcdb = 0;
 
 	data = new_data->dc_edid.buf;
 
@@ -644,6 +654,14 @@ int tegra_edid_underscan_supported(struct tegra_edid *edid)
 	return edid->data->support_underscan;
 }
 
+int tegra_edid_vcdb_supported(struct tegra_edid *edid)
+{
+	if ((!edid) || (!edid->data))
+		return 0;
+
+	return edid->data->support_vcdb;
+}
+
 int tegra_edid_get_eld(struct tegra_edid *edid, struct tegra_edid_hdmi_eld *elddata)
 {
 	if (!elddata || !edid->data)
diff --git a/drivers/video/tegra/dc/edid.h b/drivers/video/tegra/dc/edid.h
index 77db36f..41944f7 100644
--- a/drivers/video/tegra/dc/edid.h
+++ b/drivers/video/tegra/dc/edid.h
@@ -59,4 +59,5 @@ struct tegra_dc_edid *tegra_edid_get_data(struct tegra_edid *edid);
 void tegra_edid_put_data(struct tegra_dc_edid *data);
 
 int tegra_edid_underscan_supported(struct tegra_edid *edid);
+int tegra_edid_vcdb_supported(struct tegra_edid *edid);
 #endif
diff --git a/drivers/video/tegra/dc/external_common.h b/drivers/video/tegra/dc/external_common.h
index d90ca3a..c6b27c4 100644
--- a/drivers/video/tegra/dc/external_common.h
+++ b/drivers/video/tegra/dc/external_common.h
@@ -2,6 +2,13 @@
 #ifndef __EXTERNAL_COMMON_H__
 #define __EXTERNAL_COMMON_H__
 
+#include <mach/cable_detect.h>
+
+#ifdef CONFIG_TEGRA_HDMI_MHL
+extern bool IsD0Mode(void);
+extern void update_mhl_status(bool isMHL, enum usb_connect_type statMHL);
+#endif
+
 #ifdef CONFIG_TEGRA_HDMI_MHL_SUPERDEMO
 typedef unsigned char uint8;
 typedef int uint16;
diff --git a/drivers/video/tegra/dc/hdmi.c b/drivers/video/tegra/dc/hdmi.c
index ee2d3a4..eaed9c7 100644
--- a/drivers/video/tegra/dc/hdmi.c
+++ b/drivers/video/tegra/dc/hdmi.c
@@ -837,6 +837,14 @@ static bool tegra_dc_hdmi_detect(struct tegra_dc *dc)
 	if (!tegra_dc_hdmi_hpd(dc))
 		goto fail;
 
+#ifdef CONFIG_TEGRA_HDMI_MHL
+	if (!IsD0Mode()) {
+		DISP_INFO_LN("Sii9244 is not in D0 mode!");
+		update_mhl_status(false, CONNECT_TYPE_UNKNOWN);
+		goto fail;
+	}
+#endif
+
 	err = tegra_edid_get_monspecs(hdmi->edid, &specs);
 	if (err < 0) {
 		dev_err(&dc->ndev->dev, "error reading edid\n");
@@ -907,7 +915,8 @@ static void tegra_dc_hdmi_suspend(struct tegra_dc *dc)
 	struct tegra_dc_hdmi_data *hdmi = tegra_dc_get_outdata(dc);
 	unsigned long flags;
 
-	tegra_nvhdcp_suspend(hdmi->nvhdcp);
+	/* move to hdmi_hdcp_early_suspend and called by sii9234_early_suspend */
+	//tegra_nvhdcp_suspend(hdmi->nvhdcp);
 	spin_lock_irqsave(&hdmi->suspend_lock, flags);
 	hdmi->suspended = true;
 	spin_unlock_irqrestore(&hdmi->suspend_lock, flags);
@@ -929,6 +938,21 @@ static void tegra_dc_hdmi_resume(struct tegra_dc *dc)
 				   msecs_to_jiffies(30));
 
 	spin_unlock_irqrestore(&hdmi->suspend_lock, flags);
+	/* move to hdmi_hdcp_late_resume and called by sii9234_late_resume */
+	//tegra_nvhdcp_resume(hdmi->nvhdcp);
+}
+
+void hdmi_hdcp_early_suspend()
+{
+	struct tegra_dc *dc_hdmi = tegra_dc_get_dc(1);
+	struct tegra_dc_hdmi_data *hdmi = tegra_dc_get_outdata(dc_hdmi);
+	tegra_nvhdcp_suspend(hdmi->nvhdcp);
+}
+
+void hdmi_hdcp_late_resume()
+{
+	struct tegra_dc *dc_hdmi = tegra_dc_get_dc(1);
+	struct tegra_dc_hdmi_data *hdmi = tegra_dc_get_outdata(dc_hdmi);
 	tegra_nvhdcp_resume(hdmi->nvhdcp);
 }
 
@@ -1464,6 +1488,8 @@ static void tegra_dc_hdmi_setup_avi_infoframe(struct tegra_dc *dc, bool dvi)
 	struct tegra_dc_hdmi_data *hdmi = tegra_dc_get_outdata(dc);
 	struct hdmi_avi_infoframe avi;
 
+	tegra_dc_writel(hdmi->dc, 0x00000000, DC_DISP_BORDER_COLOR);
+
 	if (dvi) {
 		tegra_hdmi_writel(hdmi, 0x0,
 				  HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_CTRL);
@@ -1481,6 +1507,8 @@ static void tegra_dc_hdmi_setup_avi_infoframe(struct tegra_dc *dc, bool dvi)
 		} else {
 			avi.m = HDMI_AVI_M_16_9;
 			avi.vic = 3;
+			avi.q = tegra_edid_vcdb_supported(hdmi->edid);
+			tegra_dc_writel(hdmi->dc, 0x00101010, DC_DISP_BORDER_COLOR);
 		}
 	} else if (dc->mode.v_active == 576) {
 		/* CEC modes 17 and 18 differ only by the pysical size of the
@@ -1507,7 +1535,10 @@ static void tegra_dc_hdmi_setup_avi_infoframe(struct tegra_dc *dc, bool dvi)
 		/* VIC for both 1080p and 1080p 3D mode */
 		avi.m = HDMI_AVI_M_16_9;
 		if (dc->mode.h_front_porch == 88)
-			avi.vic = 16; /* 60 Hz */
+			if (74250000 == dc->mode.pclk)
+				avi.vic = 34; /* 30 Hz */
+			else
+				avi.vic = 16; /* 60 Hz */
 		else if (dc->mode.h_front_porch == 528)
 			avi.vic = 31; /* 50 Hz */
 		else
@@ -1666,7 +1697,7 @@ static void tegra_dc_hdmi_enable(struct tegra_dc *dc)
 
 	tegra_hdmi_writel(hdmi,
 			  (dc->ndev->id ? HDMI_SRC_DISPLAYB : HDMI_SRC_DISPLAYA) |
-			  ARM_VIDEO_RANGE_LIMITED,
+			  ARM_VIDEO_RANGE_FULL,
 			  HDMI_NV_PDISP_INPUT_CONTROL);
 
 	clk_disable(hdmi->disp1_clk);
diff --git a/drivers/video/tegra/fb.c b/drivers/video/tegra/fb.c
index 43218b2..ec012d9 100644
--- a/drivers/video/tegra/fb.c
+++ b/drivers/video/tegra/fb.c
@@ -36,6 +36,7 @@
 
 #include <mach/dc.h>
 #include <mach/fb.h>
+#include <mach/board_htc.h>
 #include <linux/nvhost.h>
 #include <mach/nvmap.h>
 
@@ -43,6 +44,11 @@
 #include "nvmap/nvmap.h"
 #include "dc/dc_priv.h"
 
+#define ONMODE_CHARGE() ((board_mfg_mode() == BOARD_MFG_MODE_NORMAL) && \
+							(board_zchg_mode() & 0x2) && \
+							(dc == tegra_fb->win->dc))
+
+
 /* Pad pitch to 16-byte boundary. */
 #define TEGRA_LINEAR_PITCH_ALIGNMENT 16
 
@@ -210,6 +216,24 @@ static int tegra_fb_pan_display(struct fb_var_screeninfo *var,
 	char __iomem *flush_end;
 	u32 addr;
 
+	int i;
+	struct tegra_dc *dc = tegra_dc_get_dc(0);
+	/*
+	This is only for china sku suspend/resume battery update and only for DC0
+	Initialize window. It wouldn't support yuv in framebuffer.
+	Therefore, we set RGBX as default and disable the other windows.
+	*/
+	struct tegra_dc_win *dcwins[DC_N_WINDOWS];
+	if (ONMODE_CHARGE()) {
+		for (i = 0; i < DC_N_WINDOWS; i++) {
+			dcwins[i] = tegra_dc_get_window(tegra_fb->win->dc, i);
+			dcwins[i]->fmt = TEGRA_WIN_FMT_R8G8B8A8;
+			if (tegra_fb->win != dcwins[i])
+				dcwins[i]->flags &= ~TEGRA_WIN_FLAG_ENABLED;
+			else
+				dcwins[i]->flags |= TEGRA_WIN_FLAG_ENABLED;
+		}
+	}
 	if (!tegra_fb->win->cur_handle) {
 		flush_start = info->screen_base + (var->yoffset * info->fix.line_length);
 		flush_end = flush_start + (var->yres * info->fix.line_length);
@@ -232,10 +256,16 @@ static int tegra_fb_pan_display(struct fb_var_screeninfo *var,
 		tegra_fb->win->out_h = var->yres;
 		tegra_fb->win->z = 0;
 		tegra_fb->win->stride = info->fix.line_length;
-		tegra_dc_update_windows(&tegra_fb->win, 1);
-		tegra_dc_sync_windows(&tegra_fb->win, 1);
+		if (ONMODE_CHARGE()) {
+			/*Update all of windows, not only window a, b or c*/
+			tegra_dc_update_windows(dcwins, DC_N_WINDOWS);
+			tegra_dc_sync_windows(dcwins, DC_N_WINDOWS);
+		}
+		else {
+			tegra_dc_update_windows(&tegra_fb->win, 1);
+			tegra_dc_sync_windows(&tegra_fb->win, 1);
+		}
 	}
-
 	return 0;
 }
 
diff --git a/drivers/video/tegra/host/nvhost_syncpt.c b/drivers/video/tegra/host/nvhost_syncpt.c
index c005c98..db7bdff 100644
--- a/drivers/video/tegra/host/nvhost_syncpt.c
+++ b/drivers/video/tegra/host/nvhost_syncpt.c
@@ -24,6 +24,12 @@
 #include "nvhost_syncpt.h"
 #include "dev.h"
 
+#if CONFIG_VIDEO_RAWCHIP
+/*HTC_start*/
+#include <media/rawchip/Yushan_API.h>
+#include <media/rawchip/rawchip.h>
+/*HTC_end*/
+#endif
 #define MAX_STUCK_CHECK_COUNT 15
 
 /**
@@ -210,7 +216,12 @@ int nvhost_syncpt_wait_timeout(struct nvhost_syncpt *sp, u32 id,
 				"%s: syncpoint id %d (%s) stuck waiting %d, timeout=%d\n",
 				 current->comm, id, syncpt_op(sp).name(sp, id),
 				 thresh, timeout);
-
+/* HTC_start */
+#if CONFIG_VIDEO_RAWCHIP
+tegra_rawchip_block_iotcl(TRUE);
+Yushan_dump_register();
+#endif
+/* HTC_end */
 			syncpt_op(sp).debug(sp);
 			if (check_count > MAX_STUCK_CHECK_COUNT) {
 				if (low_timeout) {
diff --git a/drivers/video/tegra/nvmap/nvmap.h b/drivers/video/tegra/nvmap/nvmap.h
index 2670ff9..1c8ddf3 100644
--- a/drivers/video/tegra/nvmap/nvmap.h
+++ b/drivers/video/tegra/nvmap/nvmap.h
@@ -3,7 +3,7 @@
  *
  * GPU memory management driver for Tegra
  *
- * Copyright (c) 2010-2011, NVIDIA Corporation.
+ * Copyright (c) 2010-2012, NVIDIA Corporation.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -88,10 +88,36 @@ struct nvmap_handle {
 	struct mutex lock;
 };
 
+#define NVMAP_DEFAULT_PAGE_POOL_SIZE 8192
+#define NVMAP_NUM_POOLS 2
+#define NVMAP_UC_POOL 0
+#define NVMAP_WC_POOL 1
+
+struct nvmap_page_pool {
+	spinlock_t lock;
+	int npages;
+	struct page **page_array;
+	struct mutex shrink_lock;
+	struct page **shrink_array;
+	int max_pages;
+};
+
+int nvmap_page_pool_init(struct nvmap_page_pool *pool, int flags);
+struct page *nvmap_page_pool_alloc(struct nvmap_page_pool *pool);
+bool nvmap_page_pool_release(struct nvmap_page_pool *pool, struct page *page);
+int nvmap_page_pool_get_free_count(struct nvmap_page_pool *pool);
+
 struct nvmap_share {
 	struct tegra_iovmm_client *iovmm;
 	wait_queue_head_t pin_wait;
 	struct mutex pin_lock;
+	union {
+		struct nvmap_page_pool pools[NVMAP_NUM_POOLS];
+		struct {
+			struct nvmap_page_pool uc_pool;
+			struct nvmap_page_pool wc_pool;
+		};
+	};
 #ifdef CONFIG_NVMAP_RECLAIM_UNPINNED_VM
 	struct mutex mru_lock;
 	struct list_head *mru_lists;
diff --git a/drivers/video/tegra/nvmap/nvmap_dev.c b/drivers/video/tegra/nvmap/nvmap_dev.c
index 89fda40..b62f648 100644
--- a/drivers/video/tegra/nvmap/nvmap_dev.c
+++ b/drivers/video/tegra/nvmap/nvmap_dev.c
@@ -3,7 +3,7 @@
  *
  * User-space interface to nvmap
  *
- * Copyright (c) 2011, NVIDIA Corporation.
+ * Copyright (c) 2011-2012, NVIDIA Corporation.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -1183,6 +1183,11 @@ static int nvmap_probe(struct platform_device *pdev)
 
 	init_waitqueue_head(&dev->iovmm_master.pin_wait);
 	mutex_init(&dev->iovmm_master.pin_lock);
+	nvmap_page_pool_init(&dev->iovmm_master.uc_pool,
+		NVMAP_HANDLE_UNCACHEABLE);
+	nvmap_page_pool_init(&dev->iovmm_master.wc_pool,
+		NVMAP_HANDLE_WRITE_COMBINE);
+
 	dev->iovmm_master.iovmm =
 		tegra_iovmm_alloc_client(dev_name(&pdev->dev), NULL,
 			&(dev->dev_user));
@@ -1309,6 +1314,12 @@ static int nvmap_probe(struct platform_device *pdev)
 				dev, &debug_iovmm_clients_fops);
 			debugfs_create_file("allocations", 0664, iovmm_root,
 				dev, &debug_iovmm_allocations_fops);
+			debugfs_create_u32("uc_page_pool_npages",
+				S_IRUGO|S_IWUSR, iovmm_root,
+				&dev->iovmm_master.uc_pool.npages);
+			debugfs_create_u32("wc_page_pool_npages",
+				S_IRUGO|S_IWUSR, iovmm_root,
+				&dev->iovmm_master.wc_pool.npages);
 		}
 	}
 
diff --git a/drivers/video/tegra/nvmap/nvmap_handle.c b/drivers/video/tegra/nvmap/nvmap_handle.c
index 07117e9..5a5b007 100644
--- a/drivers/video/tegra/nvmap/nvmap_handle.c
+++ b/drivers/video/tegra/nvmap/nvmap_handle.c
@@ -3,7 +3,7 @@
  *
  * Handle allocation and freeing routines for nvmap
  *
- * Copyright (c) 2009-2011, NVIDIA Corporation.
+ * Copyright (c) 2009-2012, NVIDIA Corporation.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -62,6 +62,212 @@
  * preserve kmalloc space, if the array of pages exceeds PAGELIST_VMALLOC_MIN,
  * the array is allocated using vmalloc. */
 #define PAGELIST_VMALLOC_MIN	(PAGE_SIZE * 2)
+#define NVMAP_TEST_PAGE_POOL_SHRINKER 0
+
+static struct page *nvmap_alloc_pages_exact(gfp_t gfp, size_t size);
+
+#define CPA_RESTORE_AND_FREE_PAGES(array, idx) \
+do { \
+	if (idx) \
+		set_pages_array_wb(array, idx); \
+	while (idx--) \
+		__free_page(array[idx]); \
+} while (0)
+
+#define FILL_PAGE_ARRAY(to_free, pool, array, idx) \
+do { \
+	while (to_free--) { \
+		page = nvmap_page_pool_alloc(&pool); \
+		if (!page) \
+			break; \
+		array[idx++] = page; \
+	} \
+} while (0)
+
+static int nvmap_page_pool_shrink(struct shrinker *shrinker,
+				 int nr_to_scan, gfp_t gfp_mask)
+{
+	int shrink_pages = nr_to_scan;
+	int wc_free_pages, uc_free_pages;
+	struct nvmap_share *share = nvmap_get_share_from_dev(nvmap_dev);
+	int wc_pages_to_free = 0, uc_pages_to_free = 0;
+	struct page *page;
+	int uc_idx = 0, wc_idx = 0;
+
+	pr_debug("%s: sh_pages=%d", __func__, shrink_pages);
+	shrink_pages = shrink_pages % 2 ? shrink_pages + 1 : shrink_pages;
+	wc_free_pages = nvmap_page_pool_get_free_count(&share->wc_pool);
+	uc_free_pages = nvmap_page_pool_get_free_count(&share->uc_pool);
+
+	if (shrink_pages == 0)
+		return wc_free_pages + uc_free_pages;
+
+	if (!(gfp_mask & __GFP_WAIT))
+		return -1;
+
+	if (wc_free_pages >= uc_free_pages) {
+		wc_pages_to_free = wc_free_pages - uc_free_pages;
+		if (wc_pages_to_free >= shrink_pages)
+			wc_pages_to_free = shrink_pages;
+		else {
+			shrink_pages -= wc_pages_to_free;
+			wc_pages_to_free += shrink_pages / 2;
+			uc_pages_to_free = shrink_pages / 2;
+		}
+	}  else {
+		uc_pages_to_free = uc_free_pages - wc_free_pages;
+		if (uc_pages_to_free >= shrink_pages)
+			uc_pages_to_free = shrink_pages;
+		else {
+			shrink_pages -= uc_pages_to_free;
+			uc_pages_to_free += shrink_pages / 2;
+			wc_pages_to_free = shrink_pages / 2;
+		}
+	}
+
+	mutex_lock(&share->uc_pool.shrink_lock);
+	FILL_PAGE_ARRAY(uc_pages_to_free, share->uc_pool,
+		share->uc_pool.shrink_array, uc_idx);
+	CPA_RESTORE_AND_FREE_PAGES(share->uc_pool.shrink_array, uc_idx);
+	mutex_unlock(&share->uc_pool.shrink_lock);
+
+	mutex_lock(&share->wc_pool.shrink_lock);
+	FILL_PAGE_ARRAY(wc_pages_to_free, share->wc_pool,
+		share->wc_pool.shrink_array, wc_idx);
+	CPA_RESTORE_AND_FREE_PAGES(share->wc_pool.shrink_array, wc_idx);
+	mutex_unlock(&share->wc_pool.shrink_lock);
+
+	wc_free_pages = nvmap_page_pool_get_free_count(&share->wc_pool);
+	uc_free_pages = nvmap_page_pool_get_free_count(&share->uc_pool);
+	pr_debug("%s: free pages=%d", __func__, wc_free_pages+uc_free_pages);
+	return wc_free_pages + uc_free_pages;
+}
+
+static struct shrinker nvmap_page_pool_shrinker = {
+	.shrink = nvmap_page_pool_shrink,
+	.seeks = 1,
+};
+
+#if NVMAP_TEST_PAGE_POOL_SHRINKER
+static int shrink_state;
+static int shrink_set(const char *arg, const struct kernel_param *kp)
+{
+	int cpu = smp_processor_id();
+	unsigned long long t1, t2;
+	int total_pages, free_pages;
+	int nr_to_scan;
+
+	nr_to_scan = 0;
+	total_pages = nvmap_page_pool_shrink(NULL, nr_to_scan, GFP_KERNEL);
+	t1 = cpu_clock(cpu);
+	nr_to_scan = 32768 * 4 - 1;
+	free_pages = nvmap_page_pool_shrink(NULL, nr_to_scan, GFP_KERNEL);
+	t2 = cpu_clock(cpu);
+	pr_info("%s: time=%lldns, total_pages=%d, free_pages=%d",
+		__func__, t2-t1, total_pages, free_pages);
+	shrink_state = 1;
+	return 0;
+}
+
+static int shrink_get(char *buff, const struct kernel_param *kp)
+{
+	return param_get_int(buff, kp);
+}
+
+static struct kernel_param_ops shrink_ops = {
+	.get = shrink_get,
+	.set = shrink_set,
+};
+
+module_param_cb(shrink, &shrink_ops, &shrink_state, 0644);
+#endif
+int nvmap_page_pool_init(struct nvmap_page_pool *pool, int flags)
+{
+	struct page *page;
+	int i;
+	static int reg = 1;
+	struct sysinfo info;
+
+	si_meminfo(&info);
+	spin_lock_init(&pool->lock);
+	mutex_init(&pool->shrink_lock);
+	pool->npages = 0;
+	/* Use 1/4th of total ram for page pools.
+	 *  1/8th for wc and 1/8th for uc.
+	 */
+	pool->max_pages = info.totalram >> 3;
+	if (pool->max_pages <= 0)
+		pool->max_pages = NVMAP_DEFAULT_PAGE_POOL_SIZE;
+	pr_info("nvmap %s page pool size=%d pages",
+		flags == NVMAP_HANDLE_UNCACHEABLE ? "uc" : "wc",
+		pool->max_pages);
+	pool->page_array = vmalloc(sizeof(void *) * pool->max_pages);
+	pool->shrink_array = vmalloc(sizeof(struct page *) * pool->max_pages);
+	if (!pool->page_array || !pool->shrink_array)
+		goto fail;
+
+	if (reg) {
+		reg = 0;
+		register_shrinker(&nvmap_page_pool_shrinker);
+	}
+
+	for (i = 0; i < pool->max_pages; i++) {
+		page = nvmap_alloc_pages_exact(GFP_NVMAP,
+				PAGE_SIZE);
+		if (!page)
+			return 0;
+		if (flags == NVMAP_HANDLE_WRITE_COMBINE)
+			set_pages_array_wc(&page, 1);
+		else if (flags == NVMAP_HANDLE_UNCACHEABLE)
+			set_pages_array_uc(&page, 1);
+		if (!nvmap_page_pool_release(pool, page)) {
+			set_pages_array_wb(&page, 1);
+			__free_page(page);
+			return 0;
+		}
+	}
+	return 0;
+fail:
+	pool->max_pages = 0;
+	vfree(pool->shrink_array);
+	vfree(pool->page_array);
+	return -ENOMEM;
+}
+
+struct page *nvmap_page_pool_alloc(struct nvmap_page_pool *pool)
+{
+	struct page *page = NULL;
+
+	spin_lock(&pool->lock);
+	if (pool->npages > 0)
+		page = pool->page_array[--pool->npages];
+	spin_unlock(&pool->lock);
+	return page;
+}
+
+bool nvmap_page_pool_release(struct nvmap_page_pool *pool,
+				  struct page *page)
+{
+	int ret = false;
+
+	spin_lock(&pool->lock);
+	if (pool->npages < pool->max_pages) {
+		pool->page_array[pool->npages++] = page;
+		ret = true;
+	}
+	spin_unlock(&pool->lock);
+	return ret;
+}
+
+int nvmap_page_pool_get_free_count(struct nvmap_page_pool *pool)
+{
+	int count;
+
+	spin_lock(&pool->lock);
+	count = pool->npages;
+	spin_unlock(&pool->lock);
+	return count;
+}
 
 static inline void *altalloc(size_t len)
 {
@@ -84,10 +290,11 @@ static inline void altfree(void *ptr, size_t len)
 
 void _nvmap_handle_free(struct nvmap_handle *h)
 {
-	struct nvmap_device *dev = h->dev;
-	unsigned int i, nr_page;
+	struct nvmap_share *share = nvmap_get_share_from_dev(h->dev);
+	unsigned int i, nr_page, page_index = 0;
+	struct nvmap_page_pool *pool = NULL;
 
-	if (nvmap_handle_remove(dev, h) != 0)
+	if (nvmap_handle_remove(h->dev, h) != 0)
 		return;
 
 	if (!h->alloc)
@@ -104,18 +311,38 @@ void _nvmap_handle_free(struct nvmap_handle *h)
 	BUG_ON(h->size & ~PAGE_MASK);
 	BUG_ON(!h->pgalloc.pages);
 
-	nvmap_mru_remove(nvmap_get_share_from_dev(dev), h);
+	nvmap_mru_remove(share, h);
+
+	/* Add to page pools, if necessary */
+	if (h->flags == NVMAP_HANDLE_WRITE_COMBINE)
+		pool = &share->wc_pool;
+	else if (h->flags == NVMAP_HANDLE_UNCACHEABLE)
+		pool = &share->uc_pool;
+
+	if (pool) {
+		while (page_index < nr_page) {
+			if (!nvmap_page_pool_release(pool,
+			    h->pgalloc.pages[page_index]))
+				break;
+			page_index++;
+		}
+	}
+
+	if (page_index == nr_page)
+		goto skip_attr_restore;
 
 	/* Restore page attributes. */
 	if (h->flags == NVMAP_HANDLE_WRITE_COMBINE ||
 	    h->flags == NVMAP_HANDLE_UNCACHEABLE ||
 	    h->flags == NVMAP_HANDLE_INNER_CACHEABLE)
-		set_pages_array_wb(h->pgalloc.pages, nr_page);
+		set_pages_array_wb(&h->pgalloc.pages[page_index],
+				nr_page - page_index);
 
+skip_attr_restore:
 	if (h->pgalloc.area)
 		tegra_iovmm_free_vm(h->pgalloc.area);
 
-	for (i = 0; i < nr_page; i++)
+	for (i = page_index; i < nr_page; i++)
 		__free_page(h->pgalloc.pages[i]);
 
 	altfree(h->pgalloc.pages, nr_page * sizeof(struct page *));
@@ -148,9 +375,10 @@ static int handle_page_alloc(struct nvmap_client *client,
 			     struct nvmap_handle *h, bool contiguous)
 {
 	size_t size = PAGE_ALIGN(h->size);
+	struct nvmap_share *share = nvmap_get_share_from_dev(h->dev);
 	unsigned int nr_page = size >> PAGE_SHIFT;
 	pgprot_t prot;
-	unsigned int i = 0;
+	unsigned int i = 0, page_index = 0;
 	struct page **pages;
 
 	pages = altalloc(nr_page * sizeof(*pages));
@@ -171,6 +399,22 @@ static int handle_page_alloc(struct nvmap_client *client,
 
 	} else {
 		for (i = 0; i < nr_page; i++) {
+			pages[i] = NULL;
+
+			/* Get pages from pool if there are any */
+			if (h->flags == NVMAP_HANDLE_WRITE_COMBINE)
+				pages[i] = nvmap_page_pool_alloc(
+						&share->wc_pool);
+			else if (h->flags == NVMAP_HANDLE_UNCACHEABLE)
+				pages[i] = nvmap_page_pool_alloc(
+						&share->uc_pool);
+
+			if (!pages[i])
+				break;
+			page_index++;
+		}
+
+		for (; i < nr_page; i++) {
 			pages[i] = nvmap_alloc_pages_exact(GFP_NVMAP,
 				PAGE_SIZE);
 			if (!pages[i])
@@ -188,14 +432,21 @@ static int handle_page_alloc(struct nvmap_client *client,
 #endif
 	}
 
+	if (nr_page == page_index)
+		goto skip_attr_change;
+
 	/* Update the pages mapping in kernel page table. */
 	if (h->flags == NVMAP_HANDLE_WRITE_COMBINE)
-		set_pages_array_wc(pages, nr_page);
+		set_pages_array_wc(&pages[page_index],
+				nr_page - page_index);
 	else if (h->flags == NVMAP_HANDLE_UNCACHEABLE)
-		set_pages_array_uc(pages, nr_page);
+		set_pages_array_uc(&pages[page_index],
+				nr_page - page_index);
 	else if (h->flags == NVMAP_HANDLE_INNER_CACHEABLE)
-		set_pages_array_iwb(pages, nr_page);
+		set_pages_array_iwb(&pages[page_index],
+				nr_page - page_index);
 
+skip_attr_change:
 	h->size = size;
 	h->pgalloc.pages = pages;
 	h->pgalloc.contig = contiguous;
@@ -203,8 +454,10 @@ static int handle_page_alloc(struct nvmap_client *client,
 	return 0;
 
 fail:
-	while (i--)
+	while (i--) {
+		set_pages_array_wb(&pages[i], 1);
 		__free_page(pages[i]);
+	}
 	altfree(pages, nr_page * sizeof(*pages));
 	wmb();
 	return -ENOMEM;
diff --git a/drivers/video/tegra/sii9234/Kconfig b/drivers/video/tegra/sii9234/Kconfig
index ced7a34..5d97503 100644
--- a/drivers/video/tegra/sii9234/Kconfig
+++ b/drivers/video/tegra/sii9234/Kconfig
@@ -6,11 +6,5 @@
 
 menu "Miscellaneous I2C Chip support II"
 
-config TEGRA_HDMI_MHL_SUPERDEMO
-       depends on TEGRA_HDMI_MHL
-       bool "MHL SUPERDEMO"
-       default y
-       ---help---
-         Support for SCRATCHPAD event output through MHL SiI9234
 
 endmenu
diff --git a/drivers/video/tegra/sii9234/TPI.c b/drivers/video/tegra/sii9234/TPI.c
index 4a6e7a2..688e94b 100644
--- a/drivers/video/tegra/sii9234/TPI.c
+++ b/drivers/video/tegra/sii9234/TPI.c
@@ -1204,4 +1204,5 @@ void D2ToD3(void)
 	TPI_DEBUG_PRINT(("D2 To D3 mode\n"));
 	I2C_WriteByte(HDMI_SLAVE_ADDR, 0x01, 0x03);
 	I2C_WriteByte(TPID_SLAVE_ADDR, 0x3D, I2C_ReadByte(TPID_SLAVE_ADDR, 0x3D) & 0xFE);
+	fwPowerState = POWER_STATE_D3;
 }
diff --git a/drivers/video/tegra/sii9234/sii9234.c b/drivers/video/tegra/sii9234/sii9234.c
index 43a2ef9..8f650cd 100644
--- a/drivers/video/tegra/sii9234/sii9234.c
+++ b/drivers/video/tegra/sii9234/sii9234.c
@@ -55,10 +55,8 @@ typedef struct {
 	void (*mhl_1v2_power)(bool enable);
 	struct delayed_work init_delay_work;
 	struct delayed_work init_complete_work;
+	struct delayed_work irq_timeout_work;
 	struct delayed_work mhl_on_delay_work;
-#ifdef CONFIG_INTERNAL_CHARGING_SUPPORT
-	struct delayed_work detect_charger_work;
-#endif
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	struct early_suspend early_suspend;
 #endif
@@ -117,10 +115,13 @@ static DEFINE_MUTEX(mhl_early_suspend_sem);
 bool g_bEnterEarlySuspend = false;
 static bool g_bGotUsbBus = false;
 static bool g_bNeedSimulateCableOut = false;
+bool mhl_wakeuped = false;
 //static bool g_bInitCompleted = false;
 bool g_bInitCompleted = false;
 static bool sii9244_interruptable = false;
+static bool need_simulate_cable_out = false;
 #define MHL_RCP_KEYEVENT
+#define MHL_ISR_TIMEOUT 5
 
 #ifdef MHL_RCP_KEYEVENT
 struct input_dev *input_dev;
@@ -135,33 +136,23 @@ static bool g_touch_pressed[MHL_SII9234_TOUCH_FINGER_NUM_MAX] = {false};
 static void Mhl_Proc_Remote_Event(T_MHL_SII9234_INFO *pInfo);
 static void Mhl_Proc_Reset_Key_Status(void);
 #endif
+
+extern void hdmi_hdcp_early_suspend();
+extern void hdmi_hdcp_late_resume();
+
 /*********************************************************************
 	Functions
 **********************************************************************/
 #ifdef CONFIG_CABLE_DETECT_ACCESSORY
 static DEFINE_MUTEX(mhl_notify_sem);
-#ifdef CONFIG_INTERNAL_CHARGING_SUPPORT
-static bool gPollDetect = false;
-static void detect_charger_handler(struct work_struct *w)
-{
-	T_MHL_SII9234_INFO *pInfo = container_of(
-			w, T_MHL_SII9234_INFO, detect_charger_work.work);
-
-	mutex_lock(&mhl_early_suspend_sem);
-
-	PR_DISP_DEBUG("%s: query status every 2 second\n", __func__);
-	SiiMhlTxReadDevcap(0x02);
-
-	mutex_unlock(&mhl_early_suspend_sem);
-
-	queue_delayed_work(pInfo->wq, &pInfo->detect_charger_work, HZ*2);
-}
-#endif
 
 void update_mhl_status(bool isMHL, enum usb_connect_type statMHL)
 {
 	T_MHL_SII9234_INFO *pInfo = sii9234_info_ptr;
 
+	if (!pInfo)
+		return;
+
 	PR_DISP_DEBUG("%s: -+-+-+-+- MHL is %sconnected, status = %d -+-+-+-+-\n",
 		__func__, isMHL?"":"NOT ", statMHL);
 	pInfo->isMHL = isMHL;
@@ -169,18 +160,6 @@ void update_mhl_status(bool isMHL, enum usb_connect_type statMHL)
 
 	queue_work(pInfo->wq, &pInfo->mhl_notifier_work);
 
-#ifdef CONFIG_INTERNAL_CHARGING_SUPPORT
-	if (isMHL && statMHL == CONNECT_TYPE_NONE) {
-		if (!gPollDetect) {
-			gPollDetect = true;
-			queue_delayed_work(pInfo->wq, &pInfo->detect_charger_work, HZ/2);
-		}
-	} else {
-		gPollDetect = false;
-		cancel_delayed_work(&pInfo->detect_charger_work);
-	}
-#endif
-
 #ifdef CONFIG_TEGRA_HDMI_MHL_SUPERDEMO
 	Mhl_Proc_Reset_Key_Status();
 #endif
@@ -195,7 +174,8 @@ static void send_mhl_connect_notify(struct work_struct *w)
 	if (!pInfo)
 		return;
 
-	PR_DISP_DEBUG("%s: %d\n", __func__, pInfo->isMHL);
+	PR_DISP_DEBUG("%s: isMHL(%d), charging_type(%d)\n", __func__, pInfo->isMHL, pInfo->statMHL);
+
 	mutex_lock(&mhl_notify_sem);
 	list_for_each_entry(mhl_notifier,
 		&g_lh_mhl_detect_notifier_list,
@@ -416,6 +396,10 @@ static void sii9234_irq_do_work(struct work_struct *work)
 		uint8_t		eventParameter;
 
 		PR_DISP_DEBUG("MHL ISR\n");
+
+		need_simulate_cable_out = false;
+		cancel_delayed_work(&pInfo->irq_timeout_work);
+
 		SiiMhlTxGetEvents(&event, &eventParameter);
 #ifdef CONFIG_TEGRA_HDMI_MHL_SUPERDEMO
 		Mhl_Proc_Remote_Event(pInfo);
@@ -430,7 +414,6 @@ static void sii9234_irq_do_work(struct work_struct *work)
 void sii9234_disableIRQ(void)
 {
 	T_MHL_SII9234_INFO *pInfo = sii9234_info_ptr;
-	pInfo->isMHL = false;
 	cancel_work_sync(&sii9234_irq_work);
 	if (sii9244_interruptable) {
 		PR_DISP_INFO("Disable Sii9244 IRQ\n");
@@ -524,6 +507,7 @@ static DEVICE_ATTR(rcp_event, 0644, NULL, write_keyevent);
 void sii9234_mhl_device_wakeup(void)
 {
 	int err;
+	int ret = 0 ;
 	T_MHL_SII9234_INFO *pInfo = sii9234_info_ptr;
 
 	PR_DISP_INFO("%s\n", __func__);
@@ -534,8 +518,6 @@ void sii9234_mhl_device_wakeup(void)
 		return;
 	}
 
-	pInfo->isMHL = true;
-
 	/* Power ON */
 	if (pInfo->pwrCtrl)
 		pInfo->pwrCtrl(1);
@@ -549,7 +531,29 @@ void sii9234_mhl_device_wakeup(void)
 
 	sii9244_interruptable = true;
 	PR_DISP_INFO("Enable Sii9244 IRQ\n");
+
+	/* request irq pin again, for solving MHL_INT is captured to INUT LOW */
+	if(mhl_wakeuped) {
+		disable_irq_nosync(pInfo->irq);
+		free_irq(pInfo->irq, pInfo);
+
+		ret = request_irq(pInfo->irq, sii9234_irq_handler, IRQF_TRIGGER_LOW, "mhl_sii9234_evt", pInfo);
+		if (ret < 0) {
+			PR_DISP_DEBUG("%s: request_irq(%d) failed for gpio %d (%d)\n",
+					__func__, pInfo->irq, pInfo->intr_pin, ret);
+			ret = -EIO;
+		}
+	}
+
 	enable_irq(pInfo->irq);
+	mhl_wakeuped = true;
+
+	/* switch to D0, we now depends on Sii9244 to detect the connection by MHL interrupt */
+	/* if there is no IRQ in the following steps , the status of connect will be in-correct and cannot be recovered */
+	/* add a mechanism to simulate cable out to prevent this case. */
+	need_simulate_cable_out = true;
+	queue_delayed_work(pInfo->wq, &pInfo->irq_timeout_work, HZ * MHL_ISR_TIMEOUT);
+
 }
 
 static void init_delay_handler(struct work_struct *w)
@@ -566,6 +570,27 @@ static void init_complete_handler(struct work_struct *w)
 	g_bInitCompleted = true;
 }
 
+static void irq_timeout_handler(struct work_struct *w)
+{
+	if(need_simulate_cable_out) {
+		T_MHL_SII9234_INFO *pInfo = sii9234_info_ptr;
+		int ret = 0 ;
+		/*need to request_irq again on 8960 VLE, or this prevention is not working*/
+		PR_DISP_INFO("%s , There is no MHL ISR simulate cable out.\n", __func__);
+		disable_irq_nosync(pInfo->irq);
+		TPI_Init(sii9234_info_ptr->board_params);
+		free_irq(pInfo->irq, pInfo);
+		ret = request_irq(pInfo->irq, sii9234_irq_handler, IRQF_TRIGGER_LOW, "mhl_sii9234_evt", pInfo);
+		if (ret < 0) {
+			PR_DISP_DEBUG("%s: request_irq(%d) failed for gpio %d (%d)\n",
+				__func__, pInfo->irq, pInfo->intr_pin, ret);
+			ret = -EIO;
+		}
+		enable_irq(pInfo->irq);
+		update_mhl_status(false, CONNECT_TYPE_UNKNOWN);
+	}
+}
+
 static int sii9234_resume(struct i2c_client *client)
 {
 	T_MHL_SII9234_INFO *pInfo = sii9234_info_ptr;
@@ -619,6 +644,8 @@ static void sii9234_early_suspend(struct early_suspend *h)
 		PR_DISP_INFO("Disable Sii9244 IRQ\n");
 		disable_irq_nosync(pInfo->irq);
 		sii9244_interruptable = false;
+
+		hdmi_hdcp_early_suspend();
 	}
 
 	/* Check already power on or not?*/
@@ -643,6 +670,8 @@ static void sii9234_late_resume(struct early_suspend *h)
 		PR_DISP_INFO("Enable Sii9244 IRQ\n");
 		enable_irq(pInfo->irq);
 		sii9244_interruptable = true;
+
+		hdmi_hdcp_late_resume();
 	}
 
 	queue_delayed_work(pInfo->wq, &pInfo->mhl_on_delay_work, HZ);
@@ -653,29 +682,24 @@ static void sii9234_late_resume(struct early_suspend *h)
 
 static void mhl_on_delay_handler(struct work_struct *w)
 {
+	T_MHL_SII9234_INFO *pInfo = sii9234_info_ptr;
 	PR_DISP_DEBUG("%s(%d, %d)\n", __func__, g_bEnterEarlySuspend, g_bNeedSimulateCableOut);
 
 	mutex_lock(&mhl_early_suspend_sem);
 	if (IsMHLConnection()) {
 		//fill_black_screen();
-#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
-		hdcp_deauthenticate();
-#endif
-		g_bNeedSimulateCableOut = false;
 		sii9234_EnableTMDS();
 		PR_DISP_DEBUG("MHL has connected. No SimulateCableOut!!!\n");
 		mutex_unlock(&mhl_early_suspend_sem);
 		return;
 	}
-
-	if (!g_bEnterEarlySuspend && g_bNeedSimulateCableOut) {
-#if 0
-		if (pInfo->mhl_1v2_power)
-			pInfo->mhl_1v2_power(0);
-		update_mhl_status(false, CONNECT_TYPE_UNKNOWN);
-#endif
-		g_bNeedSimulateCableOut = false;
-		g_bGotUsbBus = false;
+	else {
+		if(pInfo->isMHL){
+			/*MHL dongle plugged but no HDMI calbe*/
+			PR_DISP_DEBUG("notify cable out, re-init cable & mhl\n");
+			update_mhl_status(false, CONNECT_TYPE_UNKNOWN);
+			TPI_Init(sii9234_info_ptr->board_params);
+		}
 	}
 	mutex_unlock(&mhl_early_suspend_sem);
 }
@@ -749,11 +773,9 @@ static int sii9234_probe(struct i2c_client *client,
 
 	INIT_DELAYED_WORK(&pInfo->init_delay_work, init_delay_handler);
 	INIT_DELAYED_WORK(&pInfo->init_complete_work, init_complete_handler);
+	INIT_DELAYED_WORK(&pInfo->irq_timeout_work, irq_timeout_handler);
 	INIT_DELAYED_WORK(&pInfo->mhl_on_delay_work, mhl_on_delay_handler);
 
-#ifdef CONFIG_INTERNAL_CHARGING_SUPPORT
-	INIT_DELAYED_WORK(&pInfo->detect_charger_work, detect_charger_handler);
-#endif
 	ret = request_irq(pInfo->irq, sii9234_irq_handler, IRQF_TRIGGER_LOW, "mhl_sii9234_evt", pInfo);
 	if (ret < 0) {
 		PR_DISP_DEBUG("%s: request_irq(%d) failed for gpio %d (%d)\n",
diff --git a/drivers/video/tegra/sii9234/sii_mhltx.c b/drivers/video/tegra/sii9234/sii_mhltx.c
index 0db82c6..673c1cb 100644
--- a/drivers/video/tegra/sii9234/sii_mhltx.c
+++ b/drivers/video/tegra/sii9234/sii_mhltx.c
@@ -212,43 +212,13 @@ void	MhlTxDriveStates(void)
 }
 
 #ifdef CONFIG_INTERNAL_CHARGING_SUPPORT
-
 bool Tri_state_dongle_GPIO0(void)
 {
 	bool result = true;
 
-#if 1
-
-#define	INTR_CBUS1_DESIRED_MASK			(BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6)
-#define	UNMASK_CBUS1_INTERRUPTS			I2C_WriteByte(CBUS_SLAVE_ADDR, 0x09, INTR_CBUS1_DESIRED_MASK)
-#define	MASK_CBUS1_INTERRUPTS			I2C_WriteByte(CBUS_SLAVE_ADDR, 0x09, 0x00)
-#define	INTR_CBUS2_DESIRED_MASK			(BIT_2 | BIT_3 | BIT_4)
-#define	UNMASK_CBUS2_INTERRUPTS			I2C_WriteByte(CBUS_SLAVE_ADDR, 0x1F, INTR_CBUS2_DESIRED_MASK)
-#define	MASK_CBUS2_INTERRUPTS			I2C_WriteByte(CBUS_SLAVE_ADDR, 0x1F, 0x00)
-
-	int timeout = 100;
-
-	MASK_CBUS1_INTERRUPTS;
-	MASK_CBUS2_INTERRUPTS;
-
-
-	return result;
-
-
-	while (mscCmdInProgress && --timeout)
-		hr_msleep(1);
-
-	TPI_DEBUG_PRINT(("%s: timeout = %d\n", __func__, timeout));
-
-	if (!timeout) {
-		result = false;
-		goto l_end;
-	}
-#endif
-	I2C_WriteByte(CBUS_SLAVE_ADDR, 0x13, 0x33);
-	I2C_WriteByte(CBUS_SLAVE_ADDR, 0x14, 0x80);
-	I2C_WriteByte(CBUS_SLAVE_ADDR, 0x12, 0x08);
-
+	I2C_WriteByte(CBUS_SLAVE_ADDR,0x13, 0x33);       // enable backdoor access
+	I2C_WriteByte(CBUS_SLAVE_ADDR,0x14, 0x80);
+	I2C_WriteByte(CBUS_SLAVE_ADDR,0x12, 0x08);
 
 	I2C_WriteByte(CBUS_SLAVE_ADDR, 0xc0,  0xff);
 	I2C_WriteByte(CBUS_SLAVE_ADDR, 0xc1,  0x7F);
@@ -261,12 +231,6 @@ bool Tri_state_dongle_GPIO0(void)
 	I2C_WriteByte(CBUS_SLAVE_ADDR, 0x14, 0x00);
 	I2C_WriteByte(CBUS_SLAVE_ADDR, 0x12, 0x08);
 
-#if 1
-l_end:
-	UNMASK_CBUS2_INTERRUPTS;
-	UNMASK_CBUS1_INTERRUPTS;
-#endif
-
 	return result;
 }
 
@@ -326,23 +290,24 @@ void SiiMhlTxMscDetectCharger(uint8_t data1)
 			/* GPIO0_state=3; */
 
 			mscCmdInProgress = false;
-			SiiMhlTxReadDevcap(02);
+			SiiMhlTxReadDevcap(0x02);
 			mscCmdInProgress = false;
 			Chk_Dongle_Step = 1;
+			return;
 		}
 
 		if (Chk_Dongle_Step == 1) {
 
 			mscCmdInProgress = false;
 
-			if ((data1 & 0x10)) {
+			if (data1 & 0x10) {
 				/* Turn off phone Vbus output ; */
 				Low_dongle_GPIO0();
 
 				/* GPIO0_state = 0;  */
-				SiiMhlTxReadDevcap(02);
 				mscCmdInProgress = false;
 				Chk_Dongle_Step = 2;
+				return;
 			} else {
 
 				Chk_Dongle_Step = 0;
@@ -352,8 +317,8 @@ void SiiMhlTxMscDetectCharger(uint8_t data1)
 				/* turn on phone VBUS output.; */
 				TPI_DEBUG_PRINT(("No charger!!\n"));
 
-				if (gStatusMHL != CONNECT_TYPE_NONE) {
-					gStatusMHL = CONNECT_TYPE_NONE;
+				if (gStatusMHL != CONNECT_TYPE_INTERNAL) {
+					gStatusMHL = CONNECT_TYPE_INTERNAL;
 					ProcessMhlStatus(true, false);
 				}
 			}
@@ -397,9 +362,9 @@ void	SiiMhlTxMscCommandDone(uint8_t data1)
 
 #ifdef CONFIG_INTERNAL_CHARGING_SUPPORT
 		SiiMhlTxMscDetectCharger(data1);
-#endif
-
+#else
 		mhlTxConfig.mscState	= MSC_STATE_POW_DONE;
+#endif
 	} else if ((MHL_READ_DEVCAP == mhlTxConfig.mscLastCommand) &&
 			(0x0A == mhlTxConfig.mscLastOffset)) {
 		mhlTxConfig.mscState	= MSC_STATE_RCP_READY;
diff --git a/drivers/video/tegra/sii9234/sii_mhltx.h b/drivers/video/tegra/sii9234/sii_mhltx.h
index 978cf51..816cf4d 100644
--- a/drivers/video/tegra/sii9234/sii_mhltx.h
+++ b/drivers/video/tegra/sii9234/sii_mhltx.h
@@ -70,7 +70,8 @@ extern void sii9234_send_keyevent(uint32_t key, uint32_t type);
 extern	uint8_t	rcpSupportTable[];
 #ifdef CONFIG_INTERNAL_CHARGING_SUPPORT
 extern void ProcessMhlStatus(bool, bool);
-extern int mscCmdInProgress;
+extern uint8_t mscCmdInProgress;
 extern enum usb_connect_type gStatusMHL;
+extern int CBUS_SLAVE_ADDR;
 #endif
 
diff --git a/include/htc/log.h b/include/htc/log.h
index aea65b3..b064f7c 100644
--- a/include/htc/log.h
+++ b/include/htc/log.h
@@ -1,32 +1,6 @@
 #ifndef __HTC_LOG_H
 #define __HTC_LOG_H
 
-//#define CONFIG_SPIN_LOCK_PRINT
-//#undef CONFIG_SPIN_LOCK_PRINT
-#ifdef CONFIG_SPIN_LOCK_PRINT
-#define PM_SP_FORMATION "[SP] "
-#define sp_pr_emerg(fmt, ...)    printk( KERN_EMERG   pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#define sp_pr_alert(fmt, ...)    printk( KERN_ALERT   pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#define sp_pr_crit(fmt, ...)     printk( KERN_CRIT    pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#define sp_pr_err(fmt, ...)      printk( KERN_ERR     pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#define sp_pr_warning(fmt, ...)  printk( KERN_WARNING pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#define sp_pr_warn               pm_pr_warning
-#define sp_pr_notice(fmt, ...)   printk( KERN_NOTICE  pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#define sp_pr_info(fmt, ...)     printk( KERN_INFO    pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#define sp_pr_debug(fmt, ...)     printk( KERN_INFO    pr_fmt( PM_SP_FORMATION fmt), ##__VA_ARGS__)
-#else
-#define sp_pr_emerg(fmt, ...) do {;} while(0)
-#define sp_pr_alert(fmt, ...) do {;} while(0)
-#define sp_pr_crit(fmt, ...) do {;} while(0)
-#define sp_pr_err(fmt, ...) do {;} while(0) 
-#define sp_pr_warning(fmt, ...) do {;} while(0)
-#define sp_pr_warn               pm_pr_warning
-#define sp_pr_notice(fmt, ...) do {;} while(0)
-#define sp_pr_info(fmt, ...) do {;} while(0)
-#define sp_pr_debug(fmt, ...) do {;} while(0)
-#endif
-
-
 #ifdef CONFIG_PM_R_DEBUG
 /**
  * Power Manager [R] log
diff --git a/include/linux/android_alarm.h b/include/linux/android_alarm.h
index f8f14e7..082452b 100644
--- a/include/linux/android_alarm.h
+++ b/include/linux/android_alarm.h
@@ -94,6 +94,10 @@ enum android_alarm_return_flags {
 /* Ack last alarm and wait for next */
 #define ANDROID_ALARM_WAIT                  _IO('a', 1)
 
+#ifdef CONFIG_ANDROID_RTC_CHANGE_WAIT
+#define ANDROID_RTC_CHANGE_WAIT             _IO('a', 2)
+#endif
+
 #define ALARM_IOW(c, type, size)            _IOW('a', (c) | ((type) << 4), size)
 /* Set alarm */
 #define ANDROID_ALARM_SET(type)             ALARM_IOW(2, type, struct timespec)
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index c468192..100ca99 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -88,6 +88,11 @@ struct fsl_usb2_platform_data {
 	unsigned	invert_pwr_fault:1;
         void		*phy_config;
 	enum fsl_usb2_phy_types usb_phy_type;
+	int		charger_type;
+	unsigned ur_gpio;		/* UART_USB_SW */
+	unsigned tx_gpio;		/* UART1_DEBUG_TX */
+	unsigned rx_gpio;		/* UART1_DEBUG_RX */
+	unsigned chg_gpio;		/* CHARGER_PIN_REC */
 };
 
 /* Flags in fsl_usb2_mph_platform_data */
diff --git a/include/linux/keyreset.h b/include/linux/keyreset.h
index a2ac49e..58da6b4 100644
--- a/include/linux/keyreset.h
+++ b/include/linux/keyreset.h
@@ -21,6 +21,7 @@
 
 struct keyreset_platform_data {
 	int (*reset_fn)(void);
+	bool (*swResetCheck)(void);
 	int *keys_up;
 	int keys_down[]; /* 0 terminated */
 };
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index a951b8a..0671f03 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -140,6 +140,7 @@ struct sdio_func_tuple;
 struct mmc_card {
 	struct mmc_host		*host;		/* the host this device belongs to */
 	struct device		dev;		/* the device */
+	struct device		*mmcblk_dev;	/* block device */
 	unsigned int		rca;		/* relative card address of device */
 	unsigned int		type;		/* card type */
 #define MMC_TYPE_MMC		0		/* MMC card */
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index bc334d0..57e8eb6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -158,6 +158,7 @@ struct mmc_host {
 	u32			ocr_avail_sd;	/* SD-specific OCR */
 	u32			ocr_avail_mmc;	/* MMC-specific OCR */
 	struct notifier_block	pm_notify;
+	int			burst_mode;
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
diff --git a/include/linux/nct1008.h b/include/linux/nct1008.h
index 5e1e72a..4f9e62a 100644
--- a/include/linux/nct1008.h
+++ b/include/linux/nct1008.h
@@ -45,6 +45,7 @@ struct nct1008_platform_data {
 	void (*alarm_fn)(bool raised);
 	void (*probe_callback)(struct nct1008_data *);
 	char *reg_name;
+	unsigned gpio;
 };
 
 struct nct1008_data {
diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 69e4518..ec3b055 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -231,6 +231,8 @@ struct platform_hibernation_ops {
 	void (*recover)(void);
 };
 
+u32 get_suspend_time(void);
+
 #ifdef CONFIG_HIBERNATION
 /* kernel/power/snapshot.c */
 extern void __register_nosave_region(unsigned long b, unsigned long e, int km);
diff --git a/include/linux/tegra_vibrator_enr.h b/include/linux/tegra_vibrator_enr.h
index 66d3ab6..f9f4dd9 100644
--- a/include/linux/tegra_vibrator_enr.h
+++ b/include/linux/tegra_vibrator_enr.h
@@ -13,7 +13,6 @@ struct vibrator_platform_data {
 	struct tegra_pwm_data pwm_data;
 	int pwm_gpio;
 	int ena_gpio;
-	int pwr_gpio;
 };
 
 #endif  //_TEGRA_VIBRATOR_ENR_H
diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 422c615..3148693 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -273,7 +273,6 @@ struct kim_data_s {
 	unsigned long baud_rate;
 	//wakelock
 	struct wake_lock ST_wakelock;
-	unsigned char rfkilltool;
 };
 
 /**
diff --git a/include/media/rawchip/Yushan_API.h b/include/media/rawchip/Yushan_API.h
index 9019581..5d80be8 100644
--- a/include/media/rawchip/Yushan_API.h
+++ b/include/media/rawchip/Yushan_API.h
@@ -701,7 +701,7 @@ int Yushan_get_AFSU(uint32_t *pAfStatsGreen);
 #if 0
 bool_t Yushan_Read_AF_Statistics(uint32_t  *sYushanAFStats);
 #endif
-void Reset_Yushan(void);
+void Reset_Yushan(Yushan_New_Context_Config_t *sYushanNewContextConfig);
 
 void select_mode(uint8_t mode);
 
diff --git a/include/media/s5k3h2y.h b/include/media/s5k3h2y.h
index be6b977..874ac4d 100644
--- a/include/media/s5k3h2y.h
+++ b/include/media/s5k3h2y.h
@@ -27,6 +27,7 @@
 #define S5K3H2Y_IOCTL_SET_GAIN			_IOW('o', 4, __u16)
 #define S5K3H2Y_IOCTL_GET_STATUS			_IOR('o', 5, __u8)
 #define S5K3H2Y_IOCTL_SET_GROUP_HOLD		_IOW('o', 6, struct s5k3h2y_ae)
+#define S5K3H2Y_IOCTL_RESET_RAWCHIP		_IOW('o', 12, struct s5k3h2y_mode)
 
 struct s5k3h2y_mode {
 	int xres;
diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index e8b9e1e..da8149e 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -771,7 +771,6 @@ struct hci_cp_write_page_scan_activity {
 	#define PAGE_SCAN_TYPE_STANDARD		0x00
 	#define PAGE_SCAN_TYPE_INTERLACED	0x01
 
-/* BlueTi Start */
 #define HCI_OP_READ_RSSI			0x1405
 struct hci_cp_read_rssi {
 	__le16   handle;
@@ -782,7 +781,6 @@ struct hci_rp_read_rssi {
 	__le16   handle;
 	__s8   	 rssi;
 } __packed;
-/* BlueTi End */
 
 #define HCI_OP_READ_LOCAL_AMP_INFO	0x1409
 struct hci_rp_read_local_amp_info {
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 18c75af..eb42fbf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -529,11 +529,11 @@ void hci_conn_check_pending(struct hci_dev *hdev);
 struct hci_chan *hci_chan_create(struct hci_conn *conn);
 int hci_chan_del(struct hci_chan *chan);
 void hci_chan_hash_flush(struct hci_conn *conn);
-/* BlueTi Start */
+
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, __u16 pkt_type, 
                         bdaddr_t *dst, __u8 addr_type, __u8 sec_level, 
                         __u8 auth_type);
-/* BlueTi End */
+
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
@@ -954,11 +954,12 @@ int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int mgmt_has_pending_stop_discov(struct hci_dev *hdev);
 int mgmt_interleaved_discovery(struct hci_dev *hdev);
 int mgmt_is_interleaved_discovery(struct hci_dev *hdev);
-/* BlueTi Start */
+
 int mgmt_read_rssi_complete(struct hci_dev *hdev, bdaddr_t* bdaddr, s8 rssi);
-/* BlueTi End */
 
 int mgmt_incomming_remote_class(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 dev_class[3]);
+int mgmt_remote_features(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 features[8]);
+
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
diff --git a/include/net/bluetooth/l2cap.h b/include/net/bluetooth/l2cap.h
index 76829d5..1a1bc2d 100644
--- a/include/net/bluetooth/l2cap.h
+++ b/include/net/bluetooth/l2cap.h
@@ -497,9 +497,8 @@ struct l2cap_chan {
 
 	void		*data;
 	struct l2cap_ops *ops;
-/* BlueTi Start */
+
 	__u32 		addr_type;
-/* BlueTi End */
 };
 
 struct l2cap_ops {
diff --git a/include/net/bluetooth/mgmt.h b/include/net/bluetooth/mgmt.h
index 3c271a3..efbf053 100644
--- a/include/net/bluetooth/mgmt.h
+++ b/include/net/bluetooth/mgmt.h
@@ -243,7 +243,6 @@ struct mgmt_cp_resolve_name {
 	bdaddr_t bdaddr;
 } __packed;
 
-/* BlueTi Start */
 #define MGMT_OP_READ_RSSI_LEVEL		0x00F1
 struct mgmt_cp_read_rssi_level {
 	bdaddr_t bdaddr;
@@ -252,7 +251,12 @@ struct mgmt_rp_read_rssi_level {
 	bdaddr_t bdaddr;
 	__s8 rssi;
 } __packed;
-/* BlueTi End */
+
+#define MGMT_EV_REMOTE_FEATURES		0x00F2
+struct mgmt_ev_remote_features {
+	bdaddr_t bdaddr;
+	uint8_t features[8];
+} __packed;
 
 #define MGMT_EV_CMD_COMPLETE		0x0001
 struct mgmt_ev_cmd_complete {
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index 3815b00..e1ffd1d 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -1856,8 +1856,10 @@ static inline void hci_remote_features_evt(struct hci_dev *hdev, struct sk_buff
 	if (!conn)
 		goto unlock;
 
-	if (!ev->status)
+	if (!ev->status){
 		memcpy(conn->features, ev->features, 8);
+		mgmt_remote_features(hdev, &conn->dst, ev->features);
+	}
 
 	if (conn->state != BT_CONFIG)
 		goto unlock;
@@ -2048,11 +2050,10 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 	case HCI_OP_WRITE_CA_TIMEOUT:
 		hci_cc_write_ca_timeout(hdev, skb);
 		break;
-/* BlueTi Start */
+
 	case HCI_OP_READ_RSSI:
 		hci_cc_read_rssi(hdev,skb);
 		break;
-/* BlueTi End */
 
 	case HCI_OP_READ_LOCAL_AMP_INFO:
 		hci_cc_read_local_amp_info(hdev, skb);
diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index efad272..6d7c6cf 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -1314,6 +1314,7 @@ static void l2cap_retransmit_one_frame(struct l2cap_chan *chan, u16 tx_seq)
 	struct sk_buff *skb, *tx_skb;
 	u16 fcs;
 	u32 control;
+	int err;
 
 	skb = skb_peek(&chan->tx_q);
 	if (!skb)
@@ -1337,6 +1338,12 @@ static void l2cap_retransmit_one_frame(struct l2cap_chan *chan, u16 tx_seq)
 	tx_skb = skb_clone(skb, GFP_ATOMIC);
 	bt_cb(skb)->retries++;
 
+        if (IS_ERR(tx_skb)) {
+		err = PTR_ERR(tx_skb);
+		BT_ERR("tx_skb err:%d", err);
+		return;
+	}
+
 	control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
 	control &= __get_sar_mask(chan);
 
@@ -1380,6 +1387,9 @@ static int l2cap_ertm_send(struct l2cap_chan *chan)
 
 		bt_cb(skb)->retries++;
 
+		if (IS_ERR(tx_skb))
+			return PTR_ERR(tx_skb);
+
 		control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
 		control &= __get_sar_mask(chan);
 
@@ -2783,8 +2793,12 @@ static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr
 	}
 
 	/* Store config. */
-	memcpy(chan->conf_req + chan->conf_len, req->data, len);
-	chan->conf_len += len;
+	if (len < 65) {
+		memcpy(chan->conf_req + chan->conf_len, req->data, len);
+		chan->conf_len += len;
+	} else {
+		BT_ERR("Buffer overflow in conf_req");
+	}
 
 	if (flags & 0x0001) {
 		/* Incomplete config. Send empty response. */
@@ -3757,6 +3771,13 @@ static void l2cap_check_srej_gap(struct l2cap_chan *chan, u16 tx_seq)
 			break;
 
 		skb = skb_dequeue(&chan->srej_q);
+
+		if (IS_ERR(skb)) {
+			err = PTR_ERR(skb);
+			BT_ERR("tx_skb err:%d", err);
+			return;
+		}
+
 		control = __set_ctrl_sar(chan, bt_cb(skb)->sar);
 		err = l2cap_reassemble_sdu(chan, skb, control);
 
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index 0947e05..a540d8d 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -855,6 +855,10 @@ static void l2cap_sock_kill(struct sock *sk)
 static int l2cap_sock_shutdown(struct socket *sock, int how)
 {
 	struct sock *sk = sock->sk;
+
+	if (IS_ERR(sk))
+		return PTR_ERR(sk);
+
 	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	int err = 0;
 
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 2a8ae89..0485f41 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -1376,14 +1376,13 @@ static int pair_device(struct sock *sk, u16 index, unsigned char *data, u16 len)
 		auth_type = HCI_AT_DEDICATED_BONDING_MITM;
 
 	entry = hci_find_adv_entry(hdev, &cp->bdaddr);
-/* BlueTi Start */
+
 	if (entry)
 		conn = hci_connect(hdev, LE_LINK, 0, &cp->bdaddr, BT_ADDR_INVALID, sec_level,
 								auth_type);
 	else
 		conn = hci_connect(hdev, ACL_LINK, 0, &cp->bdaddr, BT_ADDR_INVALID, sec_level,
 								auth_type);
-/* BlueTi End */
 
 	if (IS_ERR(conn)) {
 		err = PTR_ERR(conn);
@@ -1511,7 +1510,6 @@ failed:
 	return err;
 }
 
-/* BlueTi Start */
 static int read_rssi_level(struct sock *sk, u16 index, unsigned char *data, u16 len)
 {
 	struct mgmt_cp_read_rssi_level *mgmt_cp = (void *) data;
@@ -1561,8 +1559,6 @@ failed:
 	return err;
 }
 
-/* BlueTi End */
-
 static void encrypt_complete(struct pending_cmd *cmd, u8 status)
 {
 	struct mgmt_rp_encrypt_link rp;
@@ -2262,11 +2258,9 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 	case MGMT_OP_CANCEL_RESOLVE_NAME:
 		err = cancel_resolve_name(sk, index, buf + sizeof(*hdr), len);
 		break;
-/* BlueTi Start */
 	case MGMT_OP_READ_RSSI_LEVEL:
 		err = read_rssi_level(sk, index, buf + sizeof(*hdr), len);
 		break;
-/* BlueTi End */
 	default:
 		BT_DBG("Unknown op %u", opcode);
 		err = cmd_status(sk, index, opcode, 0x01);
@@ -2503,7 +2497,6 @@ int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)
 									NULL);
 }
 
-/* BlueTi Start */
 int mgmt_read_rssi_complete(struct hci_dev *hdev, bdaddr_t* bdaddr, s8 rssi)
 {
 	struct mgmt_rp_read_rssi_level rp;
@@ -2525,7 +2518,18 @@ int mgmt_read_rssi_complete(struct hci_dev *hdev, bdaddr_t* bdaddr, s8 rssi)
 
 	return err;
 }
-/* BlueTi End */
+
+int mgmt_remote_features(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 features[8])
+{
+	struct mgmt_ev_remote_features ev;
+
+	memset(&ev, 0, sizeof(ev));
+
+	bacpy(&ev.bdaddr, bdaddr);
+	memcpy(ev.features, features, sizeof(ev.features));
+
+	return mgmt_event(MGMT_EV_REMOTE_FEATURES, hdev, &ev, sizeof(ev), NULL);
+}
 
 int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 								u8 status)
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index 799f06e..f0c4f12 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -948,7 +948,11 @@ static void neigh_timer_handler(unsigned long arg)
 		write_unlock(&neigh->lock);
 		neigh->ops->solicit(neigh, skb);
 		atomic_inc(&neigh->probes);
-		kfree_skb(skb);
+
+#ifdef CONFIG_HTC_NET_MODIFY
+		if (skb)
+#endif
+		  kfree_skb(skb);
 	} else {
 out:
 		write_unlock(&neigh->lock);
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index cbb505b..81a98c7 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -400,7 +400,7 @@ config INET_DIAG
 	  Support for INET (TCP, DCCP, etc) socket monitoring interface used by
 	  native Linux tools such as ss. ss is included in iproute2, currently
 	  downloadable at:
-	  
+
 	    http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2
 
 	  If unsure, say Y.
@@ -531,7 +531,7 @@ config TCP_CONG_VENO
 	distinguishing to circumvent the difficult judgment of the packet loss
 	type. TCP Veno cuts down less congestion window in response to random
 	loss packets.
-	See <http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1177186> 
+	See <http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1177186>
 
 config TCP_CONG_YEAH
 	tristate "YeAH TCP"
@@ -624,3 +624,8 @@ config TCP_MD5SIG
 	  on the Internet.
 
 	  If unsure, say N.
+
+config HTC_NET_MODIFY
+	tristate "HTC_NET_MODIFY"
+	---help---
+	This is for klockwork issue.
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index ff7d0b5..0ac61f3 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -975,6 +975,16 @@ __be32 inet_select_addr(const struct net_device *dev, __be32 dst, int scope)
 	struct net *net = dev_net(dev);
 
 	rcu_read_lock();
+
+	if (IS_ERR(dev) || (!dev)) {
+		printk(KERN_ERR "[NET] dev is NULL in %s!\n", __func__);
+		return addr;
+	}
+	if (IS_ERR(net) || (!net)) {
+		printk(KERN_ERR "[NET] net is NULL in %s!\n", __func__);
+		return addr;
+	}
+
 	in_dev = __in_dev_get_rcu(dev);
 	if (!in_dev)
 		goto no_in_dev;
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 5fe9b8b..4bdba7d 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -991,6 +991,11 @@ static void trie_rebalance(struct trie *t, struct tnode *tn)
 	t_key cindex, key;
 	struct tnode *tp;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (tn == NULL)
+        printk("[NET] tn == NULL in %s\n", __func__);
+#endif
+
 	key = tn->key;
 
 	while (tn != NULL && (tp = node_parent((struct rt_trie_node *)tn)) != NULL) {
@@ -1359,6 +1364,8 @@ static int check_leaf(struct fib_table *tb, struct trie *t, struct leaf *l,
 
 			if (fa->fa_tos && fa->fa_tos != flp->flowi4_tos)
 				continue;
+			if (fi->fib_dead)
+				continue;
 			if (fa->fa_info->fib_scope < flp->flowi4_scope)
 				continue;
 			fib_alias_accessed(fa);
@@ -1680,6 +1687,12 @@ int fib_table_delete(struct fib_table *tb, struct fib_config *cfg)
 		  &cfg->fc_nlinfo, 0);
 
 	l = fib_find_node(t, key);
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (l == NULL)
+        printk("[NET] l=NULL in %s\n", __func__);
+#endif
+
 	li = find_leaf_info(l, plen);
 
 	list_del_rcu(&fa->fa_list);
@@ -1793,6 +1806,11 @@ static struct leaf *trie_nextleaf(struct leaf *l)
 	if (!p)
 		return NULL;	/* trie with just one leaf */
 
+	if(IS_ERR(p)) {
+		printk(KERN_ERR "[NET]trie_nextleaf: p has been overide\n");
+		return NULL;
+	}
+
 	return leaf_walk_rcu(p, c);
 }
 
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 459c011..5c629ad 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -788,7 +788,11 @@ static int __ip_append_data(struct sock *sk, struct sk_buff_head *queue,
 	int exthdrlen;
 	int mtu;
 	int copy;
+#ifdef CONFIG_HTC_NET_MODIFY
+    int err=-1;
+#else
 	int err;
+#endif
 	int offset = 0;
 	unsigned int maxfraglen, fragheaderlen;
 	int csummode = CHECKSUM_NONE;
diff --git a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
index 73b4e91..7719605 100644
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@ -307,7 +307,7 @@ config IP_NF_TARGET_CLUSTERIP
 	  The CLUSTERIP target allows you to build load-balancing clusters of
 	  network servers without having a dedicated load-balancing
 	  router/server/switch.
-	
+
 	  To compile it as a module, choose M here.  If unsure, say N.
 
 config IP_NF_TARGET_ECN
@@ -316,7 +316,7 @@ config IP_NF_TARGET_ECN
 	depends on NETFILTER_ADVANCED
 	---help---
 	  This option adds a `ECN' target, which can be used in the iptables mangle
-	  table.  
+	  table.
 
 	  You can use this target to remove the ECN bits from the IPv4 header of
 	  an IP packet.  This is particularly useful, if you need to work around
@@ -342,7 +342,7 @@ config IP_NF_RAW
 	  This option adds a `raw' table to iptables. This table is the very
 	  first in the netfilter framework and hooks in at the PREROUTING
 	  and OUTPUT chains.
-	
+
 	  If you want to compile it as a module, say M here and read
 	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
 
@@ -354,7 +354,7 @@ config IP_NF_SECURITY
 	help
 	  This option adds a `security' table to iptables, for use
 	  with Mandatory Access Control (MAC) policy.
-	 
+
 	  If unsure, say N.
 
 endif # IP_NF_IPTABLES
@@ -393,3 +393,7 @@ endif # IP_NF_ARPTABLES
 
 endmenu
 
+config HTC_NET_MODIFY
+	tristate "HTC_NET_MODIFY"
+	---help---
+	This is for klockwork issue.
diff --git a/net/ipv4/netfilter/nf_nat_helper.c b/net/ipv4/netfilter/nf_nat_helper.c
index 31427fb..425a5d4 100644
--- a/net/ipv4/netfilter/nf_nat_helper.c
+++ b/net/ipv4/netfilter/nf_nat_helper.c
@@ -394,6 +394,11 @@ nf_nat_seq_adjust(struct sk_buff *skb,
 	this_way = &nat->seq[dir];
 	other_way = &nat->seq[!dir];
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (this_way == NULL)
+        printk("[NET] this_way == NULL in %s\n", __func__);
+#endif
+
 	if (!skb_make_writable(skb, ip_hdrlen(skb) + sizeof(*tcph)))
 		return 0;
 
diff --git a/net/ipv4/netfilter/nf_nat_pptp.c b/net/ipv4/netfilter/nf_nat_pptp.c
index 4c06003..88d47b3 100644
--- a/net/ipv4/netfilter/nf_nat_pptp.c
+++ b/net/ipv4/netfilter/nf_nat_pptp.c
@@ -52,6 +52,14 @@ static void pptp_nat_expected(struct nf_conn *ct,
 	ct_pptp_info = &nfct_help(master)->help.ct_pptp_info;
 	nat_pptp_info = &nfct_nat(master)->help.nat_pptp_info;
 
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (ct_pptp_info == NULL)
+        printk("[NET] ct_pptp_info = NULL in %s\n", __func__);
+    if (nat_pptp_info == NULL)
+        printk("[NET] nat_pptp_info = NULL in %s\n", __func__);
+#endif
+
 	/* And here goes the grand finale of corrosion... */
 	if (exp->dir == IP_CT_DIR_ORIGINAL) {
 		pr_debug("we are PNS->PAC\n");
@@ -126,6 +134,13 @@ pptp_outbound_pkt(struct sk_buff *skb,
 	ct_pptp_info  = &nfct_help(ct)->help.ct_pptp_info;
 	nat_pptp_info = &nfct_nat(ct)->help.nat_pptp_info;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (ct_pptp_info == NULL)
+        printk("[NET] ct_pptp_info = NULL in %s\n", __func__);
+    if (nat_pptp_info == NULL)
+        printk("[NET] nat_pptp_info = NULL in %s\n", __func__);
+#endif
+
 	new_callid = ct_pptp_info->pns_call_id;
 
 	switch (msg = ntohs(ctlh->messageType)) {
@@ -195,6 +210,13 @@ pptp_exp_gre(struct nf_conntrack_expect *expect_orig,
 	ct_pptp_info  = &nfct_help(ct)->help.ct_pptp_info;
 	nat_pptp_info = &nfct_nat(ct)->help.nat_pptp_info;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (ct_pptp_info == NULL)
+        printk("[NET] ct_pptp_info = NULL in %s\n", __func__);
+    if (nat_pptp_info == NULL)
+        printk("[NET] nat_pptp_info = NULL in %s\n", __func__);
+#endif
+
 	/* save original PAC call ID in nat_info */
 	nat_pptp_info->pac_call_id = ct_pptp_info->pac_call_id;
 
@@ -225,6 +247,12 @@ pptp_inbound_pkt(struct sk_buff *skb,
 	unsigned int pcid_off;
 
 	nat_pptp_info = &nfct_nat(ct)->help.nat_pptp_info;
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (nat_pptp_info == NULL)
+        printk("[NET] nat_pptp_info = NULL in %s\n", __func__);
+#endif
+
 	new_pcid = nat_pptp_info->pns_call_id;
 
 	switch (msg = ntohs(ctlh->messageType)) {
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index b2144df..b4e690a 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -2620,8 +2620,7 @@ static struct rtable *ip_route_output_slow(struct net *net,
 		fl4.saddr = FIB_RES_PREFSRC(net, res);
 
 	dev_out = FIB_RES_DEV(res);
-	if (dev_out == NULL)
-	{
+	if (dev_out == NULL) {
 		printk(KERN_ERR "[NET] dev_null is NULL in %s!\n", __func__);
 		goto out;
 	}
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 8e2718f..6bae061 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -791,6 +791,11 @@ static ssize_t do_tcp_sendpages(struct sock *sk, struct page **pages, int poffse
 		int offset = poffset % PAGE_SIZE;
 		int size = min_t(size_t, psize, PAGE_SIZE - offset);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+        if (skb == NULL)
+            printk("[NET] skb = NULL in %s\n", __func__);
+#endif
+
 		if (!tcp_send_head(sk) || (copy = size_goal - skb->len) <= 0) {
 new_segment:
 			if (!sk_stream_memory_free(sk))
@@ -963,6 +968,12 @@ int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 			int max = size_goal;
 
 			skb = tcp_write_queue_tail(sk);
+
+#ifdef CONFIG_HTC_NET_MODIFY
+        if (skb == NULL)
+            printk("[NET] skb = NULL in %s\n", __func__);
+#endif
+
 			if (tcp_send_head(sk)) {
 				if (skb->ip_summed == CHECKSUM_NONE)
 					max = mss_now;
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index bef9f04..c33df88 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -2016,6 +2016,12 @@ int tcp_use_frto(struct sock *sk)
 	if (tcp_skb_is_last(sk, skb))
 		return 1;
 	skb = tcp_write_queue_next(sk, skb);	/* Skips head */
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (skb == NULL)
+        printk("[NET] skb = NULL in %s\n", __func__);
+#endif
+
 	tcp_for_write_queue_from(skb, sk) {
 		if (skb == tcp_send_head(sk))
 			break;
@@ -2083,6 +2089,12 @@ void tcp_enter_frto(struct sock *sk)
 	tp->undo_retrans = 0;
 
 	skb = tcp_write_queue_head(sk);
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (skb == NULL)
+        printk("[NET] skb = NULL in %s\n", __func__);
+#endif
+
 	if (TCP_SKB_CB(skb)->sacked & TCPCB_RETRANS)
 		tp->undo_marker = 0;
 	if (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_RETRANS) {
@@ -2311,6 +2323,11 @@ static inline int tcp_head_timedout(struct sock *sk)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (sk == NULL)
+        printk("[NET] sk = NULL in %s\n", __func__);
+#endif
+
 	return tp->packets_out &&
 	       tcp_skb_timedout(sk, tcp_write_queue_head(sk));
 }
@@ -2481,6 +2498,11 @@ static void tcp_timeout_skbs(struct sock *sk)
 	if (tp->scoreboard_skb_hint == NULL)
 		skb = tcp_write_queue_head(sk);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (skb == NULL)
+        printk("[NET] skb = NULL in %s\n", __func__);
+#endif
+
 	tcp_for_write_queue_from(skb, sk) {
 		if (skb == tcp_send_head(sk))
 			break;
@@ -2518,6 +2540,11 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)
 		cnt = 0;
 	}
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (skb == NULL)
+        printk("[NET] skb = NULL in %s\n", __func__);
+#endif
+
 	tcp_for_write_queue_from(skb, sk) {
 		if (skb == tcp_send_head(sk))
 			break;
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 17388c7..00fe398 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -2237,6 +2237,11 @@ void tcp_xmit_retransmit_queue(struct sock *sk)
 		last_lost = tp->snd_una;
 	}
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (skb == NULL)
+        printk("[NET] skb = NULL in %s\n", __func__);
+#endif
+
 	tcp_for_write_queue_from(skb, sk) {
 		__u8 sacked = TCP_SKB_CB(skb)->sacked;
 
diff --git a/net/ipv6/Kconfig b/net/ipv6/Kconfig
index 36d7437..15f6c47 100644
--- a/net/ipv6/Kconfig
+++ b/net/ipv6/Kconfig
@@ -16,7 +16,7 @@ menuconfig IPV6
 	  For specific information about IPv6 under Linux, read the HOWTO at
 	  <http://www.bieringer.de/linux/IPv6/>.
 
-	  To compile this protocol support as a module, choose M here: the 
+	  To compile this protocol support as a module, choose M here: the
 	  module will be called ipv6.
 
 if IPV6
@@ -28,14 +28,14 @@ config IPV6_PRIVACY
 	  support.  With this option, additional periodically-altered
 	  pseudo-random global-scope unicast address(es) will be assigned to
 	  your interface(s).
-	
+
 	  We use our standard pseudo-random algorithm to generate the
           randomized interface identifier, instead of one described in RFC 3041.
 
 	  By default the kernel does not generate temporary addresses.
 	  To use temporary addresses, do
-	
-	        echo 2 >/proc/sys/net/ipv6/conf/all/use_tempaddr 
+
+	        echo 2 >/proc/sys/net/ipv6/conf/all/use_tempaddr
 
 	  See <file:Documentation/networking/ip-sysctl.txt> for details.
 
@@ -251,3 +251,8 @@ config IPV6_PIMSM_V2
 	  If unsure, say N.
 
 endif # IPV6
+
+config HTC_NET_MODIFY
+	tristate "HTC_NET_MODIFY"
+	---help---
+	This is for klockwork issue.
\ No newline at end of file
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index c443f49..8dfe0e4 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -2189,7 +2189,7 @@ static int inet6_addr_add(struct net *net, int ifindex, struct in6_addr *pfx,
 
 	ifp = ipv6_add_addr(idev, pfx, plen, scope, ifa_flags);
 
-	if (!IS_ERR(ifp)) {
+	if (!IS_ERR(ifp) && ifp != NULL) {
 		spin_lock_bh(&ifp->lock);
 		ifp->valid_lft = valid_lft;
 		ifp->prefered_lft = prefered_lft;
@@ -2294,7 +2294,7 @@ static void add_addr(struct inet6_dev *idev, const struct in6_addr *addr,
 	struct inet6_ifaddr *ifp;
 
 	ifp = ipv6_add_addr(idev, addr, plen, scope, IFA_F_PERMANENT);
-	if (!IS_ERR(ifp)) {
+	if (!IS_ERR(ifp) && ifp != NULL) {
 		spin_lock_bh(&ifp->lock);
 		ifp->flags &= ~IFA_F_TENTATIVE;
 		spin_unlock_bh(&ifp->lock);
@@ -2388,7 +2388,7 @@ static void addrconf_add_linklocal(struct inet6_dev *idev, struct in6_addr *addr
 
 
 	ifp = ipv6_add_addr(idev, addr, 64, IFA_LINK, addr_flags);
-	if (!IS_ERR(ifp)) {
+	if (!IS_ERR(ifp) && ifp != NULL) {
 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, idev->dev, 0, 0);
 		addrconf_dad_start(ifp, 0);
 		in6_ifa_put(ifp);
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 4e191a4..07a4ab9 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -790,8 +790,12 @@ static int ipv6_gso_send_check(struct sk_buff *skb)
 		ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr)]);
 
 	if (likely(ops && ops->gso_send_check)) {
-		skb_reset_transport_header(skb);
-		err = ops->gso_send_check(skb);
+		if (skb != NULL) {
+			skb_reset_transport_header(skb);
+			err = ops->gso_send_check(skb);
+		}
+		else
+			printk(KERN_ERR "[NET]skb == NULL in af_inet6.c ->skb_reset_transport_header\n");
 	}
 	rcu_read_unlock();
 
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 7548905..8a7cb56 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -977,8 +977,10 @@ struct fib6_node * fib6_locate(struct fib6_node *root,
 
 static struct rt6_info *fib6_find_prefix(struct net *net, struct fib6_node *fn)
 {
-	if (fn->fn_flags&RTN_ROOT)
-		return net->ipv6.ip6_null_entry;
+	if (fn != NULL) {
+		if (fn->fn_flags&RTN_ROOT)
+			return net->ipv6.ip6_null_entry;
+	}
 
 	while(fn) {
 		if(fn->left)
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index a83e920..bb2e507 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -149,7 +149,8 @@ err:
 	IP6_INC_STATS_BH(net, idev, IPSTATS_MIB_INHDRERRORS);
 drop:
 	rcu_read_unlock();
-	kfree_skb(skb);
+	if (skb != NULL)
+		kfree_skb(skb);
 	return NET_RX_DROP;
 }
 
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 46cf7be..56c9be5 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -1156,7 +1156,7 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	int hh_len;
 	int mtu;
 	int copy;
-	int err;
+	int err = 0;
 	int offset = 0;
 	int csummode = CHECKSUM_NONE;
 	__u8 tx_flags = 0;
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index 76b8937..a1a8ac8 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -1218,9 +1218,13 @@ int igmp6_event_query(struct sk_buff *skb)
 				else
 					ma->mca_flags &= ~MAF_GSQUERY;
 			}
-			if (!(ma->mca_flags & MAF_GSQUERY) ||
-			    mld_marksources(ma, ntohs(mlh2->mld2q_nsrcs), mlh2->mld2q_srcs))
-				igmp6_group_queried(ma, max_delay);
+			if (mlh2 != NULL) {
+				if (!(ma->mca_flags & MAF_GSQUERY) ||
+				    mld_marksources(ma, ntohs(mlh2->mld2q_nsrcs), mlh2->mld2q_srcs))
+					igmp6_group_queried(ma, max_delay);
+			} else {
+				printk(KERN_ERR "[NET]mlh2 = null at ipv6 mcast.c\n");
+			}
 			spin_unlock_bh(&ma->mca_lock);
 			break;
 		}
diff --git a/net/ipv6/mip6.c b/net/ipv6/mip6.c
index 9b21048..941db87 100644
--- a/net/ipv6/mip6.c
+++ b/net/ipv6/mip6.c
@@ -163,6 +163,11 @@ static int mip6_destopt_output(struct xfrm_state *x, struct sk_buff *skb)
 	hao = mip6_padn((char *)(dstopt + 1),
 			calc_padlen(sizeof(*dstopt), 6));
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (hao == NULL)
+        printk("[NET] hao = NULL in %s\n", __func__);
+#endif
+
 	hao->type = IPV6_TLV_HAO;
 	BUILD_BUG_ON(sizeof(*hao) != 18);
 	hao->length = sizeof(*hao) - 2;
diff --git a/net/ipv6/netfilter/Kconfig b/net/ipv6/netfilter/Kconfig
index 5bbf531..a8426f5 100644
--- a/net/ipv6/netfilter/Kconfig
+++ b/net/ipv6/netfilter/Kconfig
@@ -215,10 +215,14 @@ config IP6_NF_SECURITY
        help
          This option adds a `security' table to iptables, for use
          with Mandatory Access Control (MAC) policy.
-        
+
          If unsure, say N.
 
 endif # IP6_NF_IPTABLES
 
 endmenu
 
+config HTC_NET_MODIFY
+	tristate "HTC_NET_MODIFY"
+	---help---
+	This is for klockwork issue.
diff --git a/net/ipv6/netfilter/ip6t_rt.c b/net/ipv6/netfilter/ip6t_rt.c
index d8488c5..ceb1b3f 100644
--- a/net/ipv6/netfilter/ip6t_rt.c
+++ b/net/ipv6/netfilter/ip6t_rt.c
@@ -112,6 +112,11 @@ static bool rt_mt6(const struct sk_buff *skb, struct xt_action_param *par)
 					sizeof(_reserved),
 					&_reserved);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (rp == NULL)
+        printk("[NET] rp = NULL in %s\n", __func__);
+#endif
+
 		ret = (*rp == 0);
 	}
 
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index 4a1c3b4..7300c81 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -578,7 +578,13 @@ static int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
 		skb = csum_skb;
 	}
 
-	offset += skb_transport_offset(skb);
+	if (skb != NULL)
+		offset += skb_transport_offset(skb);
+	else {
+		printk(KERN_ERR "[NET]skb == NULL in raw.c at rawv6_push_pending_frames\n");
+		goto out;
+	}
+
 	if (skb_copy_bits(skb, offset, &csum, 2))
 		BUG();
 
diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c
index 07beeb0..69cc4d9 100644
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -364,6 +364,12 @@ found:
 		fq->q.fragments = skb;
 
 	dev = skb->dev;
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (dev == NULL)
+        printk("[NET] dev = NULL in %s\n", __func__);
+#endif
+
 	if (dev) {
 		fq->iif = dev->ifindex;
 		skb->dev = NULL;
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index b31a2f3..ffa9849 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -103,7 +103,7 @@ int udp_v6_get_port(struct sock *sk, unsigned short snum)
 {
 	unsigned int hash2_nulladdr =
 		udp6_portaddr_hash(sock_net(sk), &in6addr_any, snum);
-	unsigned int hash2_partial = 
+	unsigned int hash2_partial =
 		udp6_portaddr_hash(sock_net(sk), &inet6_sk(sk)->rcv_saddr, 0);
 
 	/* precompute partial secondary hash */
@@ -1173,6 +1173,12 @@ back_from_confirm:
 do_append_data:
 	up->len += ulen;
 	getfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (dst == NULL)
+        printk("[NET] dst = NULL in %s\n", __func__);
+#endif
+
 	err = ip6_append_data(sk, getfrag, msg->msg_iov, ulen,
 		sizeof(struct udphdr), hlimit, tclass, opt, &fl6,
 		(struct rt6_info*)dst,
diff --git a/net/ipv6/xfrm6_output.c b/net/ipv6/xfrm6_output.c
index 49a91c5..af3a920 100644
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@ -94,6 +94,11 @@ static int __xfrm6_output(struct sk_buff *skb)
 	struct dst_entry *dst = skb_dst(skb);
 	struct xfrm_state *x = dst->xfrm;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (x == NULL)
+        printk("[NET] x = NULL in %s\n", __func__);
+#endif
+
 	if ((x && x->props.mode == XFRM_MODE_TUNNEL) &&
 	    ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||
 		dst_allfrag(skb_dst(skb)))) {
diff --git a/net/key/af_key.c b/net/key/af_key.c
index 7db86ff..f541a03 100644
--- a/net/key/af_key.c
+++ b/net/key/af_key.c
@@ -272,8 +272,8 @@ static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,
 
 	if (one_sk != NULL)
 		err = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);
-
-	kfree_skb(skb2);
+	if (skb2 != NULL)
+		kfree_skb(skb2);
 	kfree_skb(skb);
 	return err;
 }
@@ -1321,6 +1321,12 @@ static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_
 
 	if (hdr->sadb_msg_seq) {
 		x = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);
+
+#ifdef CONFIG_HTC_NET_MODIFY
+        if (xdaddr == NULL)
+            printk("[NET] xdaddr = NULL in %s\n", __func__);
+#endif
+
 		if (x && xfrm_addr_cmp(&x->id.daddr, xdaddr, family)) {
 			xfrm_state_put(x);
 			x = NULL;
@@ -3570,6 +3576,10 @@ static int pfkey_sendmsg(struct kiocb *kiocb,
 out:
 	if (err && hdr && pfkey_error(hdr, err, sk) == 0)
 		err = 0;
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (skb)
+#endif
 	kfree_skb(skb);
 
 	return err ? : len;
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index 5bd5c61..2f222e8 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -11,7 +11,7 @@ config NETFILTER_NETLINK_QUEUE
 	help
 	  If this option is enabled, the kernel will include support
 	  for queueing packets via NFNETLINK.
-	  
+
 config NETFILTER_NETLINK_LOG
 	tristate "Netfilter LOG over NFNETLINK interface"
 	default m if NETFILTER_ADVANCED=n
@@ -1005,7 +1005,7 @@ config NETFILTER_XT_MATCH_REALM
 	  This option adds a `realm' match, which allows you to use the realm
 	  key from the routing subsystem inside iptables.
 
-	  This match pretty much resembles the CONFIG_NET_CLS_ROUTE4 option 
+	  This match pretty much resembles the CONFIG_NET_CLS_ROUTE4 option
 	  in tc world.
 
 	  If you want to compile it as a module, say M here and read
@@ -1027,7 +1027,7 @@ config NETFILTER_XT_MATCH_SCTP
 	depends on NETFILTER_ADVANCED
 	default IP_SCTP
 	help
-	  With this option enabled, you will be able to use the 
+	  With this option enabled, you will be able to use the
 	  `sctp' match in order to match on SCTP source/destination ports
 	  and SCTP chunk types.
 
@@ -1121,6 +1121,11 @@ config NETFILTER_XT_MATCH_U32
 
 	  Details and examples are in the kernel module source.
 
+config HTC_NET_MODIFY
+	tristate "HTC_NET_MODIFY"
+	---help---
+	This is for klockwork issu
+
 endif # NETFILTER_XTABLES
 
 endmenu
diff --git a/net/netfilter/nf_conntrack_broadcast.c b/net/netfilter/nf_conntrack_broadcast.c
index 4e99cca..f02520e 100644
--- a/net/netfilter/nf_conntrack_broadcast.c
+++ b/net/netfilter/nf_conntrack_broadcast.c
@@ -56,7 +56,7 @@ int nf_conntrack_broadcast_help(struct sk_buff *skb,
 		goto out;
 
 	exp = nf_ct_expect_alloc(ct);
-	if (exp == NULL)
+	if (exp == NULL || help == NULL)
 		goto out;
 
 	exp->tuple                = ct->tuplehash[IP_CT_DIR_REPLY].tuple;
diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c
index cd1e8e0..4a9d7ad 100644
--- a/net/netfilter/nf_conntrack_expect.c
+++ b/net/netfilter/nf_conntrack_expect.c
@@ -51,7 +51,7 @@ void nf_ct_unlink_expect_report(struct nf_conntrack_expect *exp,
 	net->ct.expect_count--;
 
 	hlist_del(&exp->lnode);
-	if (!(exp->flags & NF_CT_EXPECT_USERSPACE))
+	if (!(exp->flags & NF_CT_EXPECT_USERSPACE) && master_help != NULL)
 		master_help->expecting[exp->class]--;
 
 	nf_ct_expect_event_report(IPEXP_DESTROY, exp, pid, report);
@@ -353,10 +353,13 @@ static void evict_oldest_expect(struct nf_conn *master,
 	struct nf_conntrack_expect *exp, *last = NULL;
 	struct hlist_node *n;
 
-	hlist_for_each_entry(exp, n, &master_help->expectations, lnode) {
-		if (exp->class == new->class)
-			last = exp;
-	}
+	if (master_help != NULL) {
+		hlist_for_each_entry(exp, n, &master_help->expectations, lnode) {
+			if (exp->class == new->class)
+				last = exp;
+		}
+	} else
+		printk(KERN_WARNING "[NET] master_help=NULL in evict_oldest_expect()\n");
 
 	if (last && del_timer(&last->timeout)) {
 		nf_ct_unlink_expect(last);
@@ -369,6 +372,11 @@ static inline int refresh_timer(struct nf_conntrack_expect *i)
 	struct nf_conn_help *master_help = nfct_help(i->master);
 	const struct nf_conntrack_expect_policy *p;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (master_help == NULL)
+        printk("[NET] master_help = NULL in %s\n", __func__);
+#endif
+
 	if (!del_timer(&i->timeout))
 		return 0;
 
@@ -438,7 +446,7 @@ out:
 	return ret;
 }
 
-int nf_ct_expect_related_report(struct nf_conntrack_expect *expect, 
+int nf_ct_expect_related_report(struct nf_conntrack_expect *expect,
 				u32 pid, int report)
 {
 	int ret;
diff --git a/net/netfilter/nf_conntrack_ftp.c b/net/netfilter/nf_conntrack_ftp.c
index e17cb7c..b73211a 100644
--- a/net/netfilter/nf_conntrack_ftp.c
+++ b/net/netfilter/nf_conntrack_ftp.c
@@ -393,6 +393,11 @@ static int help(struct sk_buff *skb,
 	ends_in_nl = (fb_ptr[datalen - 1] == '\n');
 	seq = ntohl(th->seq) + datalen;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (ct_ftp_info == NULL)
+        printk("[NET] ct_ftp_info = NULL in %s\n", __func__);
+#endif
+
 	/* Look up to see if we're just after a \n. */
 	if (!find_nl_seq(ntohl(th->seq), ct_ftp_info, dir)) {
 		/* Now if this ends in \n, update ftp info. */
diff --git a/net/netfilter/nf_conntrack_h323_main.c b/net/netfilter/nf_conntrack_h323_main.c
index 18b2ce5..fcc4e2c 100644
--- a/net/netfilter/nf_conntrack_h323_main.c
+++ b/net/netfilter/nf_conntrack_h323_main.c
@@ -124,6 +124,11 @@ static int get_tpkt_data(struct sk_buff *skb, unsigned int protoff,
 	int tpktlen;
 	int tpktoff;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	/* Get TCP header */
 	th = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);
 	if (th == NULL)
@@ -1259,6 +1264,12 @@ static int expect_q931(struct sk_buff *skb, struct nf_conn *ct,
 	struct nf_conntrack_expect *exp;
 	typeof(nat_q931_hook) nat_q931;
 
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	/* Look for the first related address */
 	for (i = 0; i < count; i++) {
 		if (get_h225_addr(ct, *data, &taddr[i], &addr, &port) &&
@@ -1369,6 +1380,12 @@ static int process_rrq(struct sk_buff *skb, struct nf_conn *ct,
 	int ret;
 	typeof(set_ras_addr_hook) set_ras_addr;
 
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	pr_debug("nf_ct_ras: RRQ\n");
 
 	ret = expect_q931(skb, ct, ctinfo, data,
@@ -1406,6 +1423,11 @@ static int process_rcf(struct sk_buff *skb, struct nf_conn *ct,
 	struct nf_conntrack_expect *exp;
 	typeof(set_sig_addr_hook) set_sig_addr;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	pr_debug("nf_ct_ras: RCF\n");
 
 	set_sig_addr = rcu_dereference(set_sig_addr_hook);
@@ -1454,6 +1476,12 @@ static int process_urq(struct sk_buff *skb, struct nf_conn *ct,
 	int ret;
 	typeof(set_sig_addr_hook) set_sig_addr;
 
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	pr_debug("nf_ct_ras: URQ\n");
 
 	set_sig_addr = rcu_dereference(set_sig_addr_hook);
@@ -1487,6 +1515,11 @@ static int process_arq(struct sk_buff *skb, struct nf_conn *ct,
 	union nf_inet_addr addr;
 	typeof(set_h225_addr_hook) set_h225_addr;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	pr_debug("nf_ct_ras: ARQ\n");
 
 	set_h225_addr = rcu_dereference(set_h225_addr_hook);
diff --git a/net/netfilter/nf_conntrack_helper.c b/net/netfilter/nf_conntrack_helper.c
index 1bdfea3..a1df310 100644
--- a/net/netfilter/nf_conntrack_helper.c
+++ b/net/netfilter/nf_conntrack_helper.c
@@ -212,6 +212,12 @@ static void __nf_conntrack_helper_unregister(struct nf_conntrack_helper *me,
 		hlist_for_each_entry_safe(exp, n, next,
 					  &net->ct.expect_hash[i], hnode) {
 			struct nf_conn_help *help = nfct_help(exp->master);
+
+#ifdef CONFIG_HTC_NET_MODIFY
+            if (help == NULL)
+                printk("[NET] help = NULL in %s\n", __func__);
+#endif
+
 			if ((rcu_dereference_protected(
 					help->helper,
 					lockdep_is_held(&nf_conntrack_lock)
diff --git a/net/netfilter/nf_conntrack_pptp.c b/net/netfilter/nf_conntrack_pptp.c
index 0889448..82f9806 100644
--- a/net/netfilter/nf_conntrack_pptp.c
+++ b/net/netfilter/nf_conntrack_pptp.c
@@ -177,6 +177,11 @@ static void pptp_destroy_siblings(struct nf_conn *ct)
 	const struct nf_conn_help *help = nfct_help(ct);
 	struct nf_conntrack_tuple t;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help = NULL in %s\n", __func__);
+#endif
+
 	nf_ct_gre_keymap_destroy(ct);
 
 	/* try original (pns->pac) tuple */
@@ -274,6 +279,11 @@ pptp_inbound_pkt(struct sk_buff *skb,
 	__be16 cid = 0, pcid = 0;
 	typeof(nf_nat_pptp_hook_inbound) nf_nat_pptp_inbound;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	msg = ntohs(ctlh->messageType);
 	pr_debug("inbound control message %s\n", pptp_msg_name[msg]);
 
@@ -400,6 +410,11 @@ pptp_outbound_pkt(struct sk_buff *skb,
 	__be16 cid = 0, pcid = 0;
 	typeof(nf_nat_pptp_hook_outbound) nf_nat_pptp_outbound;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	msg = ntohs(ctlh->messageType);
 	pr_debug("outbound control message %s\n", pptp_msg_name[msg]);
 
@@ -518,6 +533,11 @@ conntrack_pptp_help(struct sk_buff *skb, unsigned int protoff,
 	int ret;
 	u_int16_t msg;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (info == NULL)
+        printk("[NET] info = NULL in %s\n", __func__);
+#endif
+
 	/* don't do any tracking before tcp handshake complete */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY)
diff --git a/net/netfilter/nf_conntrack_proto_gre.c b/net/netfilter/nf_conntrack_proto_gre.c
index cf616e5..c01a7a7 100644
--- a/net/netfilter/nf_conntrack_proto_gre.c
+++ b/net/netfilter/nf_conntrack_proto_gre.c
@@ -146,6 +146,11 @@ void nf_ct_gre_keymap_destroy(struct nf_conn *ct)
 	struct nf_conn_help *help = nfct_help(ct);
 	enum ip_conntrack_dir dir;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help = NULL in %s\n", __func__);
+#endif
+
 	pr_debug("entering for ct %p\n", ct);
 
 	write_lock_bh(&net_gre->keymap_lock);
diff --git a/net/netfilter/nf_conntrack_sane.c b/net/netfilter/nf_conntrack_sane.c
index d9e2773..f93e36c 100644
--- a/net/netfilter/nf_conntrack_sane.c
+++ b/net/netfilter/nf_conntrack_sane.c
@@ -76,6 +76,12 @@ static int help(struct sk_buff *skb,
 	struct sane_reply_net_start *reply;
 
 	ct_sane_info = &nfct_help(ct)->help.ct_sane_info;
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (ct_sane_info == NULL)
+        printk("[NET] ct_sane_info = NULL in %s\n", __func__);
+#endif
+
 	/* Until there's been traffic both ways, don't look in packets. */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED+IP_CT_IS_REPLY)
@@ -126,6 +132,12 @@ static int help(struct sk_buff *skb,
 	}
 
 	reply = sb_ptr;
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (reply == NULL)
+        printk("[NET] reply is NULL in %s\n", __func__);
+#endif
+
 	if (reply->status != htonl(SANE_STATUS_SUCCESS)) {
 		/* saned refused the command */
 		pr_debug("nf_ct_sane: unsuccessful SANE_STATUS = %u\n",
diff --git a/net/netfilter/nf_conntrack_sip.c b/net/netfilter/nf_conntrack_sip.c
index cb5a285..43fbd4b 100644
--- a/net/netfilter/nf_conntrack_sip.c
+++ b/net/netfilter/nf_conntrack_sip.c
@@ -791,6 +791,11 @@ static int refresh_signalling_expectation(struct nf_conn *ct,
 	struct hlist_node *n, *next;
 	int found = 0;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
 	spin_lock_bh(&nf_conntrack_lock);
 	hlist_for_each_entry_safe(exp, n, next, &help->expectations, lnode) {
 		if (exp->class != SIP_EXPECT_SIGNALLING ||
@@ -816,6 +821,11 @@ static void flush_expectations(struct nf_conn *ct, bool media)
 	struct nf_conntrack_expect *exp;
 	struct hlist_node *n, *next;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
 	spin_lock_bh(&nf_conntrack_lock);
 	hlist_for_each_entry_safe(exp, n, next, &help->expectations, lnode) {
 		if ((exp->class != SIP_EXPECT_SIGNALLING) ^ media)
@@ -1077,6 +1087,11 @@ static int process_invite_response(struct sk_buff *skb, unsigned int dataoff,
 	struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
 	struct nf_conn_help *help = nfct_help(ct);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
 	if ((code >= 100 && code <= 199) ||
 	    (code >= 200 && code <= 299))
 		return process_sdp(skb, dataoff, dptr, datalen, cseq);
@@ -1093,6 +1108,12 @@ static int process_update_response(struct sk_buff *skb, unsigned int dataoff,
 	struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
 	struct nf_conn_help *help = nfct_help(ct);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
+
 	if ((code >= 100 && code <= 199) ||
 	    (code >= 200 && code <= 299))
 		return process_sdp(skb, dataoff, dptr, datalen, cseq);
@@ -1109,6 +1130,11 @@ static int process_prack_response(struct sk_buff *skb, unsigned int dataoff,
 	struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
 	struct nf_conn_help *help = nfct_help(ct);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
 	if ((code >= 100 && code <= 199) ||
 	    (code >= 200 && code <= 299))
 		return process_sdp(skb, dataoff, dptr, datalen, cseq);
@@ -1126,6 +1152,11 @@ static int process_invite_request(struct sk_buff *skb, unsigned int dataoff,
 	struct nf_conn_help *help = nfct_help(ct);
 	unsigned int ret;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
 	flush_expectations(ct, true);
 	ret = process_sdp(skb, dataoff, dptr, datalen, cseq);
 	if (ret == NF_ACCEPT)
@@ -1165,6 +1196,11 @@ static int process_register_request(struct sk_buff *skb, unsigned int dataoff,
 	int ret;
 	typeof(nf_nat_sip_expect_hook) nf_nat_sip_expect;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
 	/* Expected connections can not register again. */
 	if (ct->status & IPS_EXPECTED)
 		return NF_ACCEPT;
@@ -1254,6 +1290,11 @@ static int process_register_response(struct sk_buff *skb, unsigned int dataoff,
 	unsigned int expires = 0;
 	int in_contact = 0, ret;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (help == NULL)
+        printk("[NET] help is NULL in %s\n", __func__);
+#endif
+
 	/* According to RFC 3261, "UAs MUST NOT send a new registration until
 	 * they have received a final response from the registrar for the
 	 * previous one or the previous REGISTER request has timed out".
diff --git a/net/netfilter/xt_qtaguid.c b/net/netfilter/xt_qtaguid.c
index 9ccdc48..cc275e1 100644
--- a/net/netfilter/xt_qtaguid.c
+++ b/net/netfilter/xt_qtaguid.c
@@ -1341,6 +1341,12 @@ static int iface_netdev_event_handler(struct notifier_block *nb,
 				      unsigned long event, void *ptr) {
 	struct net_device *dev = ptr;
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (dev == NULL)
+        printk("[NET] dev is NULL in %s\n", __func__);
+        return NOTIFY_DONE;
+#endif
+
 	if (unlikely(module_passive))
 		return NOTIFY_DONE;
 
@@ -1650,7 +1656,7 @@ static bool qtaguid_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	}
 
 	if (IS_ERR(sk) || (!sk)) {
-		printk(KERN_ERR "[NET] sk is NULL in %s!\n", __func__);
+		printk(KERN_ERR "[NET] sk is NULL or out of range in %s!\n", __func__);
 		res = false;
 		goto ret_res;
 	}
diff --git a/net/rfkill/core.c b/net/rfkill/core.c
index dafeaeb..761b59b 100644
--- a/net/rfkill/core.c
+++ b/net/rfkill/core.c
@@ -783,15 +783,17 @@ EXPORT_SYMBOL(rfkill_resume_polling);
 
 static int rfkill_suspend(struct device *dev, pm_message_t state)
 {
+#if 0
 	struct rfkill *rfkill = to_rfkill(dev);
 
 	rfkill_pause_polling(rfkill);
-
+#endif
 	return 0;
 }
 
 static int rfkill_resume(struct device *dev)
 {
+#if 0
 	struct rfkill *rfkill = to_rfkill(dev);
 	bool cur;
 
@@ -801,7 +803,7 @@ static int rfkill_resume(struct device *dev)
 	}
 
 	rfkill_resume_polling(rfkill);
-
+#endif
 	return 0;
 }
 #endif
diff --git a/net/sched/Kconfig b/net/sched/Kconfig
index a7a5583..67bacfd 100644
--- a/net/sched/Kconfig
+++ b/net/sched/Kconfig
@@ -567,6 +567,11 @@ config NET_CLS_IND
 	  classification based on the incoming device. This option is
 	  likely to disappear in favour of the metadata ematch.
 
+config HTC_NET_MODIFY
+	tristate "HTC_NET_MODIFY"
+	---help---
+	This is for klockwork issu
+
 endif # NET_SCHED
 
 config NET_SCH_FIFO
diff --git a/net/sched/sch_mq.c b/net/sched/sch_mq.c
index ec5cbc8..cfa2763 100644
--- a/net/sched/sch_mq.c
+++ b/net/sched/sch_mq.c
@@ -145,6 +145,14 @@ static int mq_graft(struct Qdisc *sch, unsigned long cl, struct Qdisc *new,
 	struct netdev_queue *dev_queue = mq_queue_get(sch, cl);
 	struct net_device *dev = qdisc_dev(sch);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (dev_queue == NULL)
+        printk("[NET] dev_queue is NULL in %s\n", __func__);
+
+    if (dev == NULL)
+        printk("[NET] dev is NULL in %s\n", __func__);
+#endif
+
 	if (dev->flags & IFF_UP)
 		dev_deactivate(dev);
 
@@ -180,6 +188,11 @@ static int mq_dump_class(struct Qdisc *sch, unsigned long cl,
 {
 	struct netdev_queue *dev_queue = mq_queue_get(sch, cl);
 
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (dev_queue == NULL)
+        printk("[NET] dev_queue is NULL in %s\n", __func__);
+#endif
+
 	tcm->tcm_parent = TC_H_ROOT;
 	tcm->tcm_handle |= TC_H_MIN(cl);
 	tcm->tcm_info = dev_queue->qdisc_sleeping->handle;
diff --git a/net/unix/Kconfig b/net/unix/Kconfig
index 5a69733..7a76795 100644
--- a/net/unix/Kconfig
+++ b/net/unix/Kconfig
@@ -19,3 +19,7 @@ config UNIX
 
 	  Say Y unless you know what you are doing.
 
+config HTC_NET_MODIFY
+	tristate "HTC_NET_MODIFY"
+	---help---
+	This is for klockwork issu
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index b1d75be..b3df619 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -1212,7 +1212,12 @@ out_unlock:
 		unix_state_unlock(other);
 
 out:
-	kfree_skb(skb);
+
+#ifdef CONFIG_HTC_NET_MODIFY
+    if (skb)
+#endif
+	    kfree_skb(skb);
+
 	if (newsk)
 		unix_release_sock(newsk, 0);
 	if (other)
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 17a6055..093ebae 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -2747,8 +2747,10 @@ int snd_hda_create_spdif_share_sw(struct hda_codec *codec,
 	if (!mout->dig_out_nid)
 		return 0;
 	/* ATTENTION: here mout is passed as private_data, instead of codec */
-	return snd_hda_ctl_add(codec, mout->dig_out_nid,
-			      snd_ctl_new1(&spdif_share_sw, mout));
+	struct snd_kcontrol *SND_KCTL = snd_ctl_new1(&spdif_share_sw, mout);
+	if(!SND_KCTL)
+		return 0;
+	return snd_hda_ctl_add(codec, mout->dig_out_nid, SND_KCTL);
 }
 EXPORT_SYMBOL_HDA(snd_hda_create_spdif_share_sw);
 
diff --git a/sound/pci/hda/hda_eld.c b/sound/pci/hda/hda_eld.c
index f8dfcbc..799a55c 100644
--- a/sound/pci/hda/hda_eld.c
+++ b/sound/pci/hda/hda_eld.c
@@ -27,6 +27,7 @@
 #include <asm/unaligned.h>
 #include "hda_codec.h"
 #include "hda_local.h"
+#define SHOW_ELD_DATA 0
 
 enum eld_versions {
 	ELD_VER_CEA_861D	= 2,
@@ -152,7 +153,7 @@ static unsigned char hdmi_get_eld_byte(struct hda_codec *codec, hda_nid_t nid,
 	val = snd_hda_codec_read(codec, nid, 0,
 					AC_VERB_GET_HDMI_ELDD, byte_index);
 
-#ifdef BE_PARANOID
+#if SHOW_ELD_DATA
 	printk(KERN_INFO "HDMI: ELD data byte %d: 0x%x\n", byte_index, val);
 #endif
 
@@ -328,6 +329,7 @@ static int hdmi_update_lpcm_sad_eld (struct hda_codec *codec, hda_nid_t nid,
 	int i, j;
 	u32 val, sad_base;
 	struct cea_sad *a;
+      snd_printd(KERN_INFO "hdmi_update_lpcm_sad_eld\n");
 
 	val = hdmi_get_eld_byte(codec, nid, 0);
 	e->eld_ver = GET_BITS(val, 3, 5);
diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c
index 09fb920..030bfd7 100644
--- a/sound/pci/hda/hda_generic.c
+++ b/sound/pci/hda/hda_generic.c
@@ -696,8 +696,10 @@ static int create_mixer(struct hda_codec *codec, struct hda_gnode *node,
 		if (is_loopback)
 			add_input_loopback(codec, node->nid, HDA_INPUT, index);
 		snd_printdd("[%s] NID=0x%x, DIR=IN, IDX=0x%x\n", name, node->nid, index);
-		err = snd_hda_ctl_add(codec, node->nid,
-					snd_ctl_new1(&knew, codec));
+		struct snd_kcontrol *SND_KCTL = snd_ctl_new1(&knew, codec);
+		if(!SND_KCTL)
+			return -1;
+		err = snd_hda_ctl_add(codec, node->nid, SND_KCTL);
 		if (err < 0)
 			return err;
 		created = 1;
@@ -831,8 +833,10 @@ static int build_input_controls(struct hda_codec *codec)
 	}
 
 	/* create input MUX if multiple sources are available */
-	err = snd_hda_ctl_add(codec, spec->adc_node->nid,
-			      snd_ctl_new1(&cap_sel, codec));
+	struct snd_kcontrol *SND_KCTL = snd_ctl_new1(&cap_sel, codec);
+	if(!SND_KCTL)
+		return -1;
+	err = snd_hda_ctl_add(codec, spec->adc_node->nid, SND_KCTL);
 	if (err < 0)
 		return err;
 
@@ -850,8 +854,10 @@ static int build_input_controls(struct hda_codec *codec)
 			HDA_CODEC_VOLUME(name, adc_node->nid,
 					 spec->input_mux.items[i].index,
 					 HDA_INPUT);
-		err = snd_hda_ctl_add(codec, adc_node->nid,
-					snd_ctl_new1(&knew, codec));
+		struct snd_kcontrol *SND_CTL = snd_ctl_new1(&knew, codec);
+		if(!SND_CTL)
+			return -1;
+		err = snd_hda_ctl_add(codec, adc_node->nid, SND_CTL);
 		if (err < 0)
 			return err;
 	}
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index 6d03a82..687e5ea 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -2629,8 +2629,9 @@ static int __devinit check_position_fix(struct azx *chip, int fix)
 		return POS_FIX_LPIB;
 	case AZX_DRIVER_GENERIC:
 		/* AMD chipsets also don't work with position-buffer */
-		if (chip->pci->vendor == PCI_VENDOR_ID_AMD)
-			return POS_FIX_LPIB;
+		if (chip->pci)
+			if (chip->pci->vendor == PCI_VENDOR_ID_AMD)
+				return POS_FIX_LPIB;
 		break;
 	}
 
@@ -2745,7 +2746,7 @@ static int __devinit azx_create(struct snd_card *card, struct pci_dev *pci,
 				struct azx **rchip)
 {
 	struct azx *chip;
-	int i, err;
+	int i, err = -EINVAL;
 	unsigned short gcap;
 	static struct snd_device_ops ops = {
 		.dev_free = azx_dev_free,
@@ -2802,6 +2803,8 @@ static int __devinit azx_create(struct snd_card *card, struct pci_dev *pci,
 	/* Fix up base address on ULI M5461 */
 	if (chip->driver_type == AZX_DRIVER_ULI) {
 		u16 tmp3;
+		if(!pci)
+			return -EINVAL;
 		pci_read_config_word(pci, 0x40, &tmp3);
 		pci_write_config_word(pci, 0x40, tmp3 | 0x10);
 		pci_write_config_dword(pci, PCI_BASE_ADDRESS_1, 0);
@@ -2857,7 +2860,7 @@ static int __devinit azx_create(struct snd_card *card, struct pci_dev *pci,
 
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 		if (res == NULL) {
-			err = EINVAL;
+			err = -EINVAL;
 			goto errout;
 		}
 
diff --git a/sound/pci/hda/patch_ca0110.c b/sound/pci/hda/patch_ca0110.c
index 46c8bf4..7cf1194 100644
--- a/sound/pci/hda/patch_ca0110.c
+++ b/sound/pci/hda/patch_ca0110.c
@@ -144,7 +144,10 @@ static int _add_switch(struct hda_codec *codec, hda_nid_t nid, const char *pfx,
 	struct snd_kcontrol_new knew =
 		HDA_CODEC_MUTE_MONO(namestr, nid, chan, 0, type);
 	sprintf(namestr, "%s %s Switch", pfx, dirstr[dir]);
-	return snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));
+	struct snd_kcontrol *SND_CTL = snd_ctl_new1(&knew, codec);
+	if(!SND_CTL)
+		return -1;
+	return snd_hda_ctl_add(codec, nid, SND_CTL);
 }
 
 static int _add_volume(struct hda_codec *codec, hda_nid_t nid, const char *pfx,
@@ -155,7 +158,10 @@ static int _add_volume(struct hda_codec *codec, hda_nid_t nid, const char *pfx,
 	struct snd_kcontrol_new knew =
 		HDA_CODEC_VOLUME_MONO(namestr, nid, chan, 0, type);
 	sprintf(namestr, "%s %s Volume", pfx, dirstr[dir]);
-	return snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));
+	struct snd_kcontrol *SND_CTL = snd_ctl_new1(&knew, codec);
+	if(!SND_CTL)
+		return -1;
+	return snd_hda_ctl_add(codec, nid, SND_CTL);
 }
 
 #define add_out_switch(codec, nid, pfx)	_add_switch(codec, nid, pfx, 3, 0)
diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c
index 067982f..78bbff9 100644
--- a/sound/pci/hda/patch_cirrus.c
+++ b/sound/pci/hda/patch_cirrus.c
@@ -501,6 +501,8 @@ static int add_mute(struct hda_codec *codec, const char *name, int index,
 	knew.private_value = pval;
 	snprintf(tmp, sizeof(tmp), "%s %s Switch", name, dir_sfx[dir]);
 	*kctlp = snd_ctl_new1(&knew, codec);
+	if(!(*kctlp))
+		return -1;
 	(*kctlp)->id.subdevice = HDA_SUBDEV_AMP_FLAG;
 	return snd_hda_ctl_add(codec, 0, *kctlp);
 }
@@ -515,6 +517,8 @@ static int add_volume(struct hda_codec *codec, const char *name,
 	knew.private_value = pval;
 	snprintf(tmp, sizeof(tmp), "%s %s Volume", name, dir_sfx[dir]);
 	*kctlp = snd_ctl_new1(&knew, codec);
+	if(!(*kctlp))
+		return -1;
 	(*kctlp)->id.subdevice = HDA_SUBDEV_AMP_FLAG;
 	return snd_hda_ctl_add(codec, 0, *kctlp);
 }
@@ -533,12 +537,18 @@ static void fix_volume_caps(struct hda_codec *codec, hda_nid_t dac)
 
 static int add_vmaster(struct hda_codec *codec, hda_nid_t dac)
 {
+	if(!codec)
+		return -1;
 	struct cs_spec *spec = codec->spec;
+	if(!spec)
+		return -1;
 	unsigned int tlv[4];
 	int err;
 
 	spec->vmaster_sw =
 		snd_ctl_make_virtual_master("Master Playback Switch", NULL);
+	if(!spec->vmaster_sw)
+		return -1;
 	err = snd_hda_ctl_add(codec, dac, spec->vmaster_sw);
 	if (err < 0)
 		return err;
@@ -546,6 +556,8 @@ static int add_vmaster(struct hda_codec *codec, hda_nid_t dac)
 	snd_hda_set_vmaster_tlv(codec, dac, HDA_OUTPUT, tlv);
 	spec->vmaster_vol =
 		snd_ctl_make_virtual_master("Master Playback Volume", tlv);
+	if(!spec->vmaster_vol)
+		return -1;
 	err = snd_hda_ctl_add(codec, dac, spec->vmaster_vol);
 	if (err < 0)
 		return err;
@@ -555,7 +567,11 @@ static int add_vmaster(struct hda_codec *codec, hda_nid_t dac)
 static int add_output(struct hda_codec *codec, hda_nid_t dac, int idx,
 		      int num_ctls, int type)
 {
+	if(!codec)
+		return -1;
 	struct cs_spec *spec = codec->spec;
+	if(!spec)
+		return -1;
 	const char *name;
 	int err, index;
 	struct snd_kcontrol *kctl;
@@ -597,6 +613,8 @@ static int add_output(struct hda_codec *codec, hda_nid_t dac, int idx,
 		       HDA_COMPOSE_AMP_VAL(dac, 3, 0, HDA_OUTPUT), 0, &kctl);
 	if (err < 0)
 		return err;
+	if(!spec->vmaster_sw)
+		return -1;
 	err = snd_ctl_add_slave(spec->vmaster_sw, kctl);
 	if (err < 0)
 		return err;
@@ -796,8 +814,10 @@ static int build_input(struct hda_codec *codec)
 	}
 	
 	if (spec->num_inputs > 1 && !spec->mic_detect) {
-		err = snd_hda_ctl_add(codec, 0,
-				      snd_ctl_new1(&cs_capture_source, codec));
+		struct snd_kcontrol *SND_CTL = snd_ctl_new1(&cs_capture_source, codec);
+		if(!SND_CTL)
+			return -1;
+		err = snd_hda_ctl_add(codec, 0, SND_CTL);
 		if (err < 0)
 			return err;
 	}
diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c
index 4ceec34..444423a 100644
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@ -851,6 +851,7 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo,
        {
 				snd_printk(KERN_WARNING
 					   "hdmi_pcm_open(): eld is null\n");
+			return -EINVAL;
        }
 
        if(codec==0 )
@@ -858,18 +859,24 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo,
 				snd_printk(KERN_WARNING
 					   "hdmi_pcm_open(): codec is null\n");
        }
-       if(codec->preset==0)
+       if(codec && codec->preset==0)
        {
 				snd_printk(KERN_WARNING
 					   "hdmi_pcm_open(): codec preset is null\n");
+			return -EINVAL;
        }
 #ifdef CONFIG_SND_HDA_PLATFORM_NVIDIA_TEGRA
-#if 0 //Remove Audio delay for ELD
+#if 0
+	if(!codec)
+		return -EINVAL;
 	if ((codec->preset->id == 0x10de0020) &&
 	    (!eld->eld_valid || !eld->sad_count)) {
 		int err = 0;
 		unsigned long timeout;
 
+		snd_printk(KERN_WARNING
+			   "hdmi_pcm_open(): step1\n");
+
 		if (!eld->eld_valid) {
 			err = tegra_hdmi_setup_hda_presence();
 			if (err < 0) {
@@ -879,6 +886,9 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo,
 			}
 		}
 
+		snd_printk(KERN_WARNING
+			   "hdmi_pcm_open(): step2\n");
+
 		timeout = jiffies + msecs_to_jiffies(5000);
 		for (;;) {
 			if (eld->eld_valid && eld->sad_count)
@@ -893,9 +903,14 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo,
 		}
 	}
 #else
+	if(!codec)
+		return -EINVAL;
 	if ((codec->preset->id == 0x10de0020) &&
 	    (!eld->eld_valid || !eld->sad_count || !eld->lpcm_sad_ready)) {
 
+		snd_printk(KERN_WARNING
+			   "hdmi_pcm_open(): step1\n");
+
 		if (!eld->eld_valid) {
 			if (tegra_hdmi_setup_hda_presence() < 0) {
 				snd_printk(KERN_WARNING
@@ -903,6 +918,8 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo,
 				return -ENODEV;
 			}
 		}
+		snd_printk(KERN_WARNING
+			   "hdmi_pcm_open(): step2\n");
 
 		if (!eld->lpcm_sad_ready)
 			return -EAGAIN;
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index 4145c3c..3af6ec9 100644
